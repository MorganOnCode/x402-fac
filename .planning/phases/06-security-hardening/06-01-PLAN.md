---
phase: 06-security-hardening
plan: 06-01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/plugins/error-handler.test.ts
  - tests/unit/routes/health.test.ts
  - vitest.config.ts
autonomous: true

must_haves:
  truths:
    - "Error handler plugin has >90% statement coverage and >80% branch coverage"
    - "Health endpoint has >90% statement coverage with degraded/unhealthy/down paths tested"
    - "Coverage thresholds raised to enforce minimum quality bar"
    - "All error sanitization branches exercised in production mode"
    - "Sentry capture verified for 500+ errors"
  artifacts:
    - path: "tests/unit/plugins/error-handler.test.ts"
      provides: "Comprehensive error handler tests covering all sanitization branches"
      exports: []
    - path: "tests/unit/routes/health.test.ts"
      provides: "Health endpoint unit tests covering degraded, unhealthy, and error states"
      exports: []
    - path: "vitest.config.ts"
      provides: "Raised coverage thresholds preventing regression"
      exports: []
  key_links:
    - from: "tests/unit/plugins/error-handler.test.ts"
      to: "src/plugins/error-handler.ts"
      via: "Tests all branches of sanitizeMessage and error handler"
      pattern: "sanitizeMessage|INTERNAL_ERROR|SERVER_|CONFIG_|statusCode.*500"
    - from: "tests/unit/routes/health.test.ts"
      to: "src/routes/health.ts"
      via: "Tests checkRedis error path, degraded/unhealthy status logic"
      pattern: "checkRedis|degraded|unhealthy|status.*down"
---

<objective>
Close the two most critical coverage gaps identified by the Phase 1-5 audit: the error handler plugin (86.95% stmts / 63.15% branches — sanitization logic and Sentry capture untested) and the health endpoint (75% stmts / 22.22% branches — degraded/unhealthy/down states untested). Raise coverage thresholds to prevent regression.

Purpose: These are security-critical code paths. The error handler controls what information leaks to clients in production. The health endpoint determines operational status. Both must be thoroughly tested before the facilitator is shared or deployed.

Output: `tests/unit/plugins/error-handler.test.ts`, `tests/unit/routes/health.test.ts`, updated `vitest.config.ts`
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/plugins/error-handler.ts
@src/routes/health.ts
@vitest.config.ts
@tests/integration/health.test.ts
@tests/security/controls.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Error handler plugin unit tests</name>
  <files>tests/unit/plugins/error-handler.test.ts</files>
  <action>
Create a new unit test file for the error handler plugin. Test the following scenarios:

**Production mode error sanitization (`sanitizeMessage`):**

1. **Rate limit (429)** — message passes through unchanged:
   - Send a request that triggers rate limit, verify the response message is the original rate limit message (not sanitized)

2. **Internal error (code: `INTERNAL_ERROR`)** — message sanitized to generic:
   - Throw an error with `code: 'INTERNAL_ERROR'` from a test route, verify response message is `'An internal error occurred'`

3. **Server error (code: `SERVER_TIMEOUT`)** — message sanitized:
   - Throw an error with code starting with `SERVER_`, verify response message is `'An internal error occurred'`

4. **Config error (code: `CONFIG_INVALID`)** — message passes through:
   - Throw an error with code starting with `CONFIG_`, verify the original message is returned

5. **Client error (code: `VERIFY_INVALID_FORMAT`, 400)** — message passes through:
   - Throw a 400-level error with a domain code, verify the original message is returned

6. **500 error triggers Sentry capture:**
   - Mock `Sentry.captureException`, throw a 500 error, verify Sentry was called with the error and request context (requestId, url, method)

7. **400 error does NOT trigger Sentry:**
   - Mock `Sentry.captureException`, throw a 400 error, verify Sentry was NOT called

**Development mode behavior:**

8. **Dev mode includes stack trace:**
   - Create server with `isDev: true`, throw an error, verify response includes `stack` field

9. **Dev mode returns raw message (no sanitization):**
   - Create server with `isDev: true`, throw an `INTERNAL_ERROR`, verify the raw message is returned (not sanitized)

**Not-found handler:**

10. **404 returns structured error:**
    - Request a non-existent route, verify response has `code: 'NOT_FOUND'`, `statusCode: 404`, and includes the route in the message

**Implementation approach:**

Create the server with a test-specific route that throws configurable errors:

```typescript
server.post('/test-error', async (request) => {
  const { statusCode, code, message } = request.body as any;
  const err = new Error(message) as any;
  err.statusCode = statusCode;
  err.code = code;
  throw err;
});
```

Use `server.inject()` to call this route with different error configurations.

For Sentry mocking, mock `../src/instrument.js` to provide a mock `Sentry` object with `captureException` as `vi.fn()`.

For production vs dev mode, create separate server instances with `env: 'production'` and `env: 'development'`.
  </action>
  <verify>
- `pnpm test tests/unit/plugins/error-handler.test.ts` passes
- At least 10 test cases covering all branches
- `pnpm test:coverage` shows error-handler.ts >90% statements and >80% branches
  </verify>
  <done>Error handler plugin fully tested with all sanitization branches, Sentry capture, dev/prod mode differences, and 404 handler covered.</done>
</task>

<task type="auto">
  <name>Task 2: Health endpoint unit tests</name>
  <files>tests/unit/routes/health.test.ts</files>
  <action>
Create a new unit test file for the health endpoint that tests all status determination paths. The integration test at `tests/integration/health.test.ts` only covers the happy path (all up → healthy → 200). This file covers the error and degraded paths.

**Test scenarios:**

1. **All dependencies up → healthy (200):**
   - Mock Redis ping succeeds, verify `status: 'healthy'`, HTTP 200

2. **Redis down, IPFS up → degraded (200):**
   - Mock Redis ping to throw, verify `status: 'degraded'`, HTTP 200, Redis dependency shows `status: 'down'` with error message

3. **All dependencies down → unhealthy (503):**
   - Mock Redis ping to throw, mock IPFS to throw (for when it's implemented — currently checkIpfs always returns up, so this tests the outer `.catch()` wrapper at lines 55-60)
   - Since checkIpfs() currently returns up, we need to directly test the status logic: if both redis and ipfs report down → unhealthy, 503

4. **Redis not configured → up (placeholder):**
   - Don't decorate server with redis, verify Redis reports `status: 'up'`, `latency: 0` (placeholder behavior at line 22-24)

5. **Redis ping latency measured:**
   - Mock Redis ping with a small delay, verify `latency` field is present and > 0

6. **checkRedis catch handler (line 49-54):**
   - This is the outer Promise.all catch wrapper. Make `checkRedis` throw an unexpected error (not from redis.ping but from the function itself), verify it returns `{ status: 'down', error: '...' }`

7. **Response shape validation:**
   - Verify `timestamp` is ISO format, `uptime` is number > 0, `version` is string, `dependencies` has `redis` and `ipfs` keys

**Implementation approach:**

Test `checkRedis` and the route handler separately. For `checkRedis`, import the health routes plugin and test via `server.inject()` with different Redis mock states.

For controlling Redis behavior per test, use `beforeEach` to create a fresh server with the appropriate Redis mock configuration. Alternatively, use `vi.spyOn` on the decorated redis object to control ping behavior per test.
  </action>
  <verify>
- `pnpm test tests/unit/routes/health.test.ts` passes
- At least 7 test cases covering healthy/degraded/unhealthy paths
- `pnpm test:coverage` shows health.ts >90% statements and >50% branches
  </verify>
  <done>Health endpoint tested with degraded, unhealthy, and error scenarios. All status determination branches covered.</done>
</task>

<task type="auto">
  <name>Task 3: Raise coverage thresholds</name>
  <files>vitest.config.ts</files>
  <action>
Update `vitest.config.ts` coverage thresholds from the current low values to meaningful minimums that prevent regression:

Current:
```typescript
thresholds: {
  statements: 60,
  branches: 40,
  functions: 60,
  lines: 60,
}
```

New (based on current actuals of ~90/78/85/90):
```typescript
thresholds: {
  statements: 80,
  branches: 65,
  functions: 75,
  lines: 80,
}
```

These are set ~10% below current actuals to allow reasonable fluctuation while preventing significant regression. The gap between actuals and thresholds gives room for new code that starts uncovered before tests catch up.
  </action>
  <verify>
- `pnpm test:coverage` passes with the new thresholds
- No test failures
  </verify>
  <done>Coverage thresholds raised to 80/65/75/80 (statements/branches/functions/lines), enforcing a minimum quality bar.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds with zero errors
- `pnpm test` passes with all existing + new tests
- `pnpm test:coverage` passes with raised thresholds
- Error handler coverage >90% statements, >80% branches
- Health endpoint coverage >90% statements, >50% branches
- No regressions in existing 246 tests
</verification>

<success_criteria>
The two most critical coverage gaps (error handler and health endpoint) are closed. Coverage thresholds now enforce a minimum quality bar preventing silent regression. Foundation ready for Plan 06-02 (operational resilience) and Plan 06-03 (adversarial testing).
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-hardening/06-01-SUMMARY.md`
</output>
