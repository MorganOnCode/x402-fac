---
phase: 06-security-hardening
plan: 06-02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/chain/utxo-cache.ts
  - src/chain/utxo-reservation.ts
  - src/chain/config.ts
  - src/chain/redis-client.ts
  - config/config.example.json
  - tests/unit/chain/utxo-cache.test.ts
  - tests/unit/chain/utxo-reservation.test.ts
autonomous: true

must_haves:
  truths:
    - "All 4 silent .catch(() => {}) calls replaced with structured debug-level logging"
    - "L1 UTXO cache has a maximum size cap with eviction of oldest entries"
    - "Redis config schema supports password, username, and db fields"
    - "config.example.json shows Redis auth fields"
    - "Redis client factory uses auth fields when provided"
    - "Existing tests still pass — changes are backward compatible"
  artifacts:
    - path: "src/chain/utxo-cache.ts"
      provides: "UTXO cache with logged Redis failures and bounded L1 size"
      exports: ["UtxoCache", "createUtxoCache", "serializeWithBigInt", "deserializeWithBigInt"]
    - path: "src/chain/utxo-reservation.ts"
      provides: "UTXO reservation with logged Redis failures"
      exports: ["UtxoReservation", "createUtxoReservation"]
    - path: "src/chain/config.ts"
      provides: "ChainConfigSchema with Redis auth fields (password, username, db)"
      exports: ["ChainConfigSchema", "ChainConfig", "resolveBlockfrostUrl"]
    - path: "src/chain/redis-client.ts"
      provides: "Redis client factory using auth fields when present"
      exports: ["createRedisClient", "disconnectRedis"]
  key_links:
    - from: "src/chain/redis-client.ts"
      to: "src/chain/config.ts"
      via: "Uses redis config including new auth fields"
      pattern: "config\\.password|config\\.username|config\\.db"
    - from: "src/chain/utxo-cache.ts"
      to: "src/chain/utxo-cache.ts"
      via: "L1 cache eviction when max size exceeded"
      pattern: "MAX_L1_ENTRIES|l1\\.size|l1\\.delete"
---

<objective>
Fix the 4 silent Redis error swallowing locations (`.catch(() => {})`) with structured debug logging, bound the L1 UTXO cache to prevent unbounded memory growth, and add Redis authentication support to the config schema.

Purpose: Silent failures make debugging impossible in production. An unbounded cache is a memory exhaustion vector. Redis auth is a blocker for production deployment (Phase 7). All three are audit-identified gaps that must close before the facilitator can be shared.

Output: Modified `src/chain/utxo-cache.ts`, `src/chain/utxo-reservation.ts`, `src/chain/config.ts`, `src/chain/redis-client.ts`, `config/config.example.json`, updated tests.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/chain/utxo-cache.ts
@src/chain/utxo-reservation.ts
@src/chain/config.ts
@src/chain/redis-client.ts
@config/config.example.json
@tests/unit/chain/utxo-cache.test.ts
@tests/unit/chain/utxo-reservation.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace silent Redis .catch() with structured logging</name>
  <files>src/chain/utxo-cache.ts, src/chain/utxo-reservation.ts</files>
  <action>
Replace ALL 4 silent error swallowing patterns with debug-level structured logging. The pattern is the same at each location:

**Before (all 4 locations):**
```typescript
// eslint-disable-next-line @typescript-eslint/no-empty-function
this.redis.del(redisKey).catch(() => {});
```

**After:**
```typescript
this.redis.del(redisKey).catch((err: Error) => {
  this.logger.debug({ err: err.message, redisKey }, 'Redis fire-and-forget failed');
});
```

The 4 locations:
1. `src/chain/utxo-cache.ts:132` — `invalidate()` Redis DEL
2. `src/chain/utxo-reservation.ts:79` — `reserve()` Redis SET
3. `src/chain/utxo-reservation.ts:96` — `release()` Redis DEL
4. `src/chain/utxo-reservation.ts:196` — `cleanExpired()` Redis DEL

Use debug level (not warn/error) because:
- These are fire-and-forget by design — the in-memory state is the source of truth
- Redis failures here are not operationally critical (Redis will recover)
- But they must be visible in debug logs for troubleshooting

Remove the `// eslint-disable-next-line @typescript-eslint/no-empty-function` comments since the catch handlers are no longer empty.

For the SET in reservation.ts:79, the pattern is slightly different:
```typescript
this.redis.set(redisKey, JSON.stringify(reservation), 'PX', this.ttlMs).catch((err: Error) => {
  this.logger.debug({ err: err.message, redisKey }, 'Redis fire-and-forget failed');
});
```
  </action>
  <verify>
- `pnpm build` succeeds
- `pnpm test` passes (existing tests unaffected — mock Redis doesn't reject)
- `grep -r 'catch(() => {})' src/chain/` returns zero results
- All 4 locations now have structured logging in their catch handlers
  </verify>
  <done>All 4 silent Redis error swallowing locations replaced with debug-level structured logging. No more invisible failures.</done>
</task>

<task type="auto">
  <name>Task 2: Bound L1 UTXO cache size</name>
  <files>src/chain/utxo-cache.ts, tests/unit/chain/utxo-cache.test.ts</files>
  <action>
Add a maximum size cap to the L1 in-memory Map in `UtxoCache`. When the cap is exceeded, evict the oldest entry (by `expiresAt`).

**Implementation:**

1. Add a constant at the top of the class:
```typescript
private static readonly MAX_L1_ENTRIES = 10_000;
```

2. In the `set()` method, after writing to L1, check the size and evict if needed:
```typescript
// Evict oldest L1 entry if cap exceeded
if (this.l1.size > UtxoCache.MAX_L1_ENTRIES) {
  let oldestKey: string | null = null;
  let oldestExpiry = Infinity;
  for (const [key, entry] of this.l1) {
    if (entry.expiresAt < oldestExpiry) {
      oldestExpiry = entry.expiresAt;
      oldestKey = key;
    }
  }
  if (oldestKey) {
    this.l1.delete(oldestKey);
    this.logger.debug({ evictedAddress: oldestKey, cacheSize: this.l1.size }, 'L1 cache entry evicted (max size)');
  }
}
```

3. Also in `get()` when warming L1 from L2, apply the same eviction check.

**Tests to add in `utxo-cache.test.ts`:**

1. **L1 cache evicts oldest entry at max size:**
   - Create a cache, set MAX_L1_ENTRIES + 1 entries (use a lower cap for testing — expose the constant or test with enough entries to trigger)
   - Verify the oldest entry was evicted
   - Verify the newest entries are still present

Note: Since `MAX_L1_ENTRIES` is private static readonly, the test should create enough entries to verify the eviction behavior works. Alternatively, add a `maxL1Entries` option to the constructor with `MAX_L1_ENTRIES` as the default, allowing tests to use a lower value:

```typescript
private readonly maxL1Entries: number;

constructor(options: { redis: Redis; ttlMs: number; logger: FastifyBaseLogger; maxL1Entries?: number }) {
  // ...
  this.maxL1Entries = options.maxL1Entries ?? 10_000;
}
```

This is the preferred approach — it keeps the default high while making tests practical.
  </action>
  <verify>
- `pnpm test tests/unit/chain/utxo-cache.test.ts` passes
- New eviction test confirms oldest entry is removed when cap exceeded
- `pnpm build` succeeds
  </verify>
  <done>L1 UTXO cache bounded at 10,000 entries (configurable via constructor). Oldest entry evicted when cap exceeded. Memory exhaustion vector closed.</done>
</task>

<task type="auto">
  <name>Task 3: Add Redis auth fields to config schema</name>
  <files>src/chain/config.ts, src/chain/redis-client.ts, config/config.example.json</files>
  <action>
**1. Extend Redis config schema** in `src/chain/config.ts`:

Current (lines 57-62):
```typescript
redis: z
  .object({
    host: z.string().default('127.0.0.1'),
    port: z.number().int().min(1).max(65535).default(6379),
  })
  .default(() => ({ host: '127.0.0.1', port: 6379 })),
```

New:
```typescript
redis: z
  .object({
    host: z.string().default('127.0.0.1'),
    port: z.number().int().min(1).max(65535).default(6379),
    /** Redis password (sensitive — never log). Optional for local dev. */
    password: z.string().optional(),
    /** Redis username (Redis 6+ ACL). Optional. */
    username: z.string().optional(),
    /** Redis database number (0-15). Default 0. */
    db: z.number().int().min(0).max(15).default(0),
  })
  .default(() => ({ host: '127.0.0.1', port: 6379, db: 0 })),
```

**2. Use auth fields in Redis client factory** (`src/chain/redis-client.ts`):

Update the `createRedisClient` function to pass auth fields to ioredis:

```typescript
const client = new Redis({
  host: config.host,
  port: config.port,
  ...(config.password && { password: config.password }),
  ...(config.username && { username: config.username }),
  ...(config.db !== undefined && { db: config.db }),
  lazyConnect: true,
  maxRetriesPerRequest: 3,
  retryStrategy(times: number): number {
    return Math.min(times * 200, 2000);
  },
});
```

**3. Update config.example.json** to show the new fields:

Add after the existing redis section:
```json
"redis": {
  "host": "127.0.0.1",
  "port": 6379,
  "password": "",
  "db": 0
}
```

Use empty string for password (Zod will parse as optional since it's empty), or omit it with a comment. Since JSON doesn't support comments, just include the field with a placeholder-safe value.

Actually, since password is optional, just add a comment-like note in the example:
```json
"redis": {
  "host": "127.0.0.1",
  "port": 6379,
  "db": 0
}
```
Keep password omitted in example (it's optional). Operators who need auth will add it.
  </action>
  <verify>
- `pnpm build` succeeds
- `pnpm test` passes (existing tests don't provide password — backward compatible)
- Config schema accepts password, username, db fields
- Config schema works without password (optional, backward compatible)
  </verify>
  <done>Redis config schema supports password, username, and db. Redis client factory uses auth fields when provided. config.example.json updated. Backward compatible — no breaking changes.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds with zero errors
- `pnpm test` passes with all existing + new tests
- Zero silent `.catch(() => {})` in `src/chain/`
- L1 cache has a configurable max size with eviction
- Redis auth fields present in config schema and client factory
- No regressions in existing 246 tests
</verification>

<success_criteria>
Operational resilience gaps closed: Redis failures are logged (not silent), memory is bounded, and Redis auth is supported. All changes are backward compatible. Foundation ready for Plan 06-03 (security controls) and Plan 06-04 (checklist closure).
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-hardening/06-02-SUMMARY.md`
</output>
