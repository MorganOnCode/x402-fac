---
phase: 06-security-hardening
plan: 06-04
type: execute
wave: 3
depends_on: [06-03]
files_modified:
  - .planning/ROADMAP.md
  - .planning/phases/06-security-hardening/06-VERIFICATION.md
autonomous: true

must_haves:
  truths:
    - "ALL unchecked security items from Phases 1-5 in ROADMAP.md are either checked or documented as accepted risk"
    - "Final coverage report shows thresholds met"
    - "Phase 6 verification document summarizes security posture"
    - "No high/critical dependency vulnerabilities outstanding"
  artifacts:
    - path: ".planning/phases/06-security-hardening/06-VERIFICATION.md"
      provides: "Phase 6 security verification report with evidence for every checklist item"
      exports: []
    - path: ".planning/ROADMAP.md"
      provides: "Updated ROADMAP with all Phase 1-5 security checkboxes resolved"
      exports: []
  key_links:
    - from: ".planning/phases/06-security-hardening/06-VERIFICATION.md"
      to: ".planning/ROADMAP.md"
      via: "Maps each security checklist item to evidence of closure"
      pattern: "\\[x\\]|accepted risk"
---

<objective>
Walk through every unchecked security checklist item from Phases 1-5 in the ROADMAP, close each with evidence (test reference, code reference, or accepted risk documentation), mark Phase 6 security items as closed, run final coverage report, and produce the Phase 6 verification document.

Purpose: This is the final gate. Every security claim in the roadmap must be backed by evidence. Items that can't be proven must be documented as accepted risk with rationale. The verification document is the artifact that gives confidence to share and deploy.

Output: Updated `ROADMAP.md` (all checkboxes resolved), `06-VERIFICATION.md`
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-security-hardening/06-01-SUMMARY.md
@.planning/phases/06-security-hardening/06-02-SUMMARY.md
@.planning/phases/06-security-hardening/06-03-SUMMARY.md
@.auditing/AUDIT-claude.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Close Phase 1 security checklist</name>
  <files>.planning/ROADMAP.md</files>
  <action>
Walk through each Phase 1 security checklist item in ROADMAP.md and mark as checked with evidence:

**Phase 1 items (ROADMAP.md lines ~92-98):**

1. `[ ] Dependency scanning enabled (Dependabot)` → Check existing `.github/dependabot.yml`
2. `[ ] No secrets in repository (config.json gitignored)` → Check `.gitignore` contains `config/config.json`
3. `[ ] Security headers configured (helmet)` → Check `src/server.ts` registers `@fastify/helmet`
4. `[ ] Input validation on all endpoints (Zod)` → Check all POST routes use Zod `safeParse()`
5. `[ ] Error responses don't leak internal details in production` → Reference Plan 06-01 error handler tests + Plan 06-03 adversarial tests

For each item, verify the evidence exists in code/tests, then change `[ ]` to `[x]` in ROADMAP.md.

If any item cannot be verified, document it as accepted risk in the verification doc (Task 5).
  </action>
  <verify>
- All Phase 1 security checkboxes marked `[x]` or documented as accepted risk
  </verify>
  <done>Phase 1 security checklist fully resolved with evidence.</done>
</task>

<task type="auto">
  <name>Task 2: Close Phase 2 security checklist</name>
  <files>.planning/ROADMAP.md</files>
  <action>
Walk through Phase 2 security checklist items:

1. `[ ] Blockfrost API key stored in environment, not code` → Key is in `config/config.json` (file-based, gitignored). Not literally env vars but equivalent security. The checklist text says "environment" but the project uses config file. Mark as checked with note.
2. `[ ] API key not logged in any request/response logs` → Reference `src/chain/blockfrost-client.ts` JSDoc + Plan 06-03 adversarial test for leakage
3. `[ ] UTXO state integrity verified (no phantom UTXOs)` → UTXOs fetched fresh from Blockfrost, cached with TTL. No phantom UTXO risk in this architecture. Mark checked.
4. `[ ] Rate limiting prevents API key abuse` → Reference Plan 06-03 per-endpoint rate limits
5. `[ ] Error messages don't expose API key or internal state` → Reference Plan 06-03 adversarial tests for secret leakage

Mark each as `[x]` with inline evidence.
  </action>
  <verify>
- All Phase 2 security checkboxes marked `[x]`
  </verify>
  <done>Phase 2 security checklist fully resolved.</done>
</task>

<task type="auto">
  <name>Task 3: Close Phase 3, 4, 5 security checklists</name>
  <files>.planning/ROADMAP.md</files>
  <action>
Walk through Phase 3, 4, and 5 security checklist items:

**Phase 3:**
1. `[ ] All verification failures logged with details (but not secrets)` → Check verify-payment.ts logs + error handler tests
2. `[ ] UTXO model provides inherent replay protection` → Document: UTXO spent = gone from UTXO set. No nonces needed. Blockchain provides this.
3. `[ ] Address comparison uses canonical CBOR hex` → Check `checks.ts` uses `Address.to_hex()`
4. `[ ] Raw transaction CBOR not logged (could be large)` → Grep source for CBOR logging, confirm none
5. `[ ] OWASP ZAP scan on /verify endpoint passes` → Mark as accepted risk: OWASP ZAP not yet configured. Document as Phase 7 item (CI/CD).

**Phase 4:**
1. `[ ] No double-settlement possible (CBOR SHA-256 dedup in Redis)` → Reference settle-payment.ts `computeDedupKey()` + Plan 06-03 adversarial replay test
2. `[ ] Transaction re-verified before submission` → Check settle-payment.ts calls verifyPayment before submit
3. `[ ] 400 errors from Blockfrost not retried` → Check blockfrost-client.ts isRetryableError excludes 400
4. `[ ] Confirmation verified on correct network` → Check verification pipeline validates CAIP-2 chain ID
5. `[ ] Settlement errors don't expose internal state` → Reference error handler sanitization tests

**Phase 5:**
1. `[ ] Token policy IDs validated against known-good list` → Check token-registry.ts SUPPORTED_TOKENS
2. `[ ] No token confusion attacks possible` → Reference Plan 06-03 adversarial token confusion tests
3. `[ ] Decimal handling audited (no overflow/underflow)` → Check BigInt usage throughout (no floating point for lovelace)
4. `[ ] Fake token rejection (only whitelisted policy IDs accepted)` → Check checkTokenSupported in checks.ts
5. `[ ] Token metadata verified from on-chain source` → Mark as accepted risk: tokens are hardcoded, not fetched from on-chain registry. This is by design (security gate). Document.

Mark each as `[x]` or document as accepted risk.
  </action>
  <verify>
- All Phase 3, 4, 5 security checkboxes resolved
- Accepted risks documented with rationale
  </verify>
  <done>Phase 3, 4, 5 security checklists fully resolved. Accepted risks documented.</done>
</task>

<task type="auto">
  <name>Task 4: Close Phase 6 security checklist</name>
  <files>.planning/ROADMAP.md</files>
  <action>
Mark Phase 6's own security checklist items as closed:

1. `[ ] Rate limiting prevents brute-force and DoS on all endpoints` → Reference global + per-endpoint rate limits
2. `[ ] Body size limits prevent memory exhaustion attacks` → Reference 50KB bodyLimit in server.ts + security test
3. `[ ] Error responses verified: no internal state leakage in production mode` → Reference Plan 06-01 + 06-03 tests
4. `[ ] Dependency audit clean (zero high/critical)` → Reference Plan 06-03 audit results
5. `[ ] Coverage thresholds enforce minimum quality bar` → Reference Plan 06-01 threshold update

Mark each as `[x]`.
  </action>
  <verify>
- All Phase 6 security checkboxes marked `[x]`
  </verify>
  <done>Phase 6 security checklist closed.</done>
</task>

<task type="auto">
  <name>Task 5: Write Phase 6 verification document</name>
  <files>.planning/phases/06-security-hardening/06-VERIFICATION.md</files>
  <action>
Create the Phase 6 verification document summarizing the security posture after hardening.

**Structure:**

```markdown
# Phase 6: Security Hardening — Verification Report

## Summary

Phase 6 closed X security checklist items across Phases 1-6, raised coverage thresholds,
added Y adversarial security tests, and addressed Z audit-identified gaps.

## Coverage Report

(Paste final `pnpm test:coverage` summary)

## Security Checklist Closure

### Phase 1: Foundation
| Item | Status | Evidence |
|------|--------|----------|
| Dependency scanning | Closed | .github/dependabot.yml |
| ... | ... | ... |

### Phase 2: Chain Provider
(same format)

### Phase 3-5
(same format)

### Phase 6: Security Hardening
(same format)

## Accepted Risks

| Risk | Rationale | Mitigation |
|------|-----------|------------|
| OWASP ZAP not yet run | Requires CI/CD setup (Phase 7) | Manual API testing covers basic cases |
| Token metadata not from on-chain | Hardcoded registry is intentional security gate | Code review required to add tokens |
| ... | ... | ... |

## Remaining Audit Items

(Cross-reference with AUDIT-claude.md — which items from the audit are now resolved?)

## Test Summary

- Total tests: X (was 246)
- New security tests: Y
- Coverage: statements/branches/functions/lines
- Thresholds: enforced at 80/65/75/80
```

Run `pnpm test:coverage` to get the final numbers for the report.
  </action>
  <verify>
- 06-VERIFICATION.md exists with complete content
- All checklist items have clear evidence or accepted risk documentation
- Coverage numbers are current and accurate
  </verify>
  <done>Phase 6 verification document complete. Security posture fully documented with evidence for every claim.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm test` passes all tests
- `pnpm test:coverage` passes with enforced thresholds
- ALL security checkboxes in ROADMAP.md Phases 1-6 are `[x]` or documented accepted risk
- 06-VERIFICATION.md provides traceable evidence for every security claim
- No regressions from Plans 06-01 through 06-03
</verification>

<success_criteria>
Every security claim in the roadmap is backed by evidence. Accepted risks are documented with rationale. The facilitator's security posture is clear, honest, and verifiable. Phase 6 is complete. The codebase is ready for Phase 7 (Production Infrastructure).
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-hardening/06-04-SUMMARY.md`
</output>
