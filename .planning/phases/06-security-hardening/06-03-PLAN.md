---
phase: 06-security-hardening
plan: 06-03
type: execute
wave: 2
depends_on: [06-01, 06-02]
files_modified:
  - src/routes/verify.ts
  - src/routes/settle.ts
  - src/routes/status.ts
  - tests/security/controls.test.ts
  - tests/security/adversarial.test.ts
autonomous: true

must_haves:
  truths:
    - "Per-endpoint rate limits enforced on /verify, /settle, /status (tighter than global)"
    - "Adversarial tests validate replay protection, token confusion, malformed inputs, and secret leakage"
    - "API key (Blockfrost projectId) never appears in error responses or logs"
    - "Duplicate transaction submission returns idempotent result (not double-settlement)"
    - "npm audit reports zero high/critical vulnerabilities"
  artifacts:
    - path: "tests/security/adversarial.test.ts"
      provides: "Adversarial security test suite covering replay, token confusion, secret leakage"
      exports: []
    - path: "tests/security/controls.test.ts"
      provides: "Updated security controls with per-endpoint rate limit tests"
      exports: []
  key_links:
    - from: "tests/security/adversarial.test.ts"
      to: "src/routes/verify.ts"
      via: "Tests malformed CBOR, token confusion, and verification abuse"
      pattern: "verify|adversarial|replay|token.*confusion"
    - from: "tests/security/adversarial.test.ts"
      to: "src/settle/settle-payment.ts"
      via: "Tests dedup key prevents double settlement"
      pattern: "dedup|double.*settle|replay"
    - from: "src/routes/verify.ts"
      to: "src/server.ts"
      via: "Route-level rate limit config"
      pattern: "rateLimit|config.*sensitive"
---

<objective>
Implement per-endpoint rate limiting on sensitive routes (/verify, /settle, /status), create an adversarial security test suite that validates replay protection, token confusion defense, secret leakage prevention, and malformed input handling, and run a dependency vulnerability audit.

Purpose: The global rate limit (100 req/min) is too permissive for payment-critical endpoints. Adversarial tests prove the security properties documented in the Phase 1-5 security checklists. The dependency audit ensures no known vulnerabilities ship to production.

Output: Updated route files with rate limit config, `tests/security/adversarial.test.ts`, updated `tests/security/controls.test.ts`, dependency audit results.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/routes/verify.ts
@src/routes/settle.ts
@src/routes/status.ts
@src/server.ts
@src/config/schema.ts
@tests/security/controls.test.ts
@src/settle/settle-payment.ts
@src/verify/token-registry.ts
@src/chain/blockfrost-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Per-endpoint rate limiting on sensitive routes</name>
  <files>src/routes/verify.ts, src/routes/settle.ts, src/routes/status.ts, tests/security/controls.test.ts</files>
  <action>
Apply tighter rate limits to payment-critical endpoints using Fastify's route-level rate limit configuration. The `config.rateLimit.sensitive` field already exists in the schema (default: 20 req/min) but is NOT USED anywhere.

**Implementation:**

The `@fastify/rate-limit` plugin supports per-route configuration via the route `config` option. Apply it to `/verify`, `/settle`, and `/status`:

In each route file, add rate limit config to the route options. Example for `verify.ts`:

```typescript
fastify.post('/verify', {
  config: {
    rateLimit: {
      max: fastify.config.rateLimit.sensitive,
      timeWindow: fastify.config.rateLimit.windowMs,
    },
  },
}, async (request, reply) => {
  // existing handler
});
```

Apply the same pattern to `/settle` and `/status`.

**Note:** The route handler functions are currently async arrow functions passed as the second argument to `fastify.post()`. To add route options, restructure to use the three-argument form: `fastify.post(url, options, handler)`.

**Tests to add in `tests/security/controls.test.ts`:**

Add a test that verifies the sensitive endpoint rate limit is tighter than global:

```typescript
it('should enforce tighter rate limits on /verify', async () => {
  // Config sets sensitive: 1 for testing
  const res1 = await server.inject({ method: 'POST', url: '/verify', payload: {} });
  // First request goes through (may return 200 with validation error — that's fine)

  const res2 = await server.inject({ method: 'POST', url: '/verify', payload: {} });
  expect(res2.statusCode).toBe(429);
});
```

The existing test config already sets `sensitive: 1`, so this test should work with the current `beforeEach` setup.
  </action>
  <verify>
- `pnpm build` succeeds
- `pnpm test tests/security/controls.test.ts` passes
- Per-endpoint rate limit test confirms /verify is limited to `sensitive` rate (not global)
- /health still uses global rate limit (not sensitive)
  </verify>
  <done>Per-endpoint rate limits applied to /verify, /settle, /status using config.rateLimit.sensitive. Payment-critical endpoints protected with tighter limits.</done>
</task>

<task type="auto">
  <name>Task 2: Adversarial security test suite</name>
  <files>tests/security/adversarial.test.ts</files>
  <action>
Create a comprehensive adversarial test suite that validates the security properties from Phase 1-5 security checklists.

**Test categories:**

**1. Secret leakage prevention (2 tests):**

```typescript
describe('Secret Leakage Prevention', () => {
  it('should not include Blockfrost API key in error responses', async () => {
    // Make requests that fail in various ways
    // Search all response bodies for the test API key string
    // Verify it never appears
    const responses = [
      await server.inject({ method: 'POST', url: '/verify', payload: {} }),
      await server.inject({ method: 'POST', url: '/settle', payload: {} }),
      await server.inject({ method: 'GET', url: '/not-found' }),
    ];
    for (const res of responses) {
      expect(res.body).not.toContain('test-project-id');
    }
  });

  it('should not include seed phrase in error responses', async () => {
    // Same approach — verify seed phrase never leaks
  });
});
```

**2. Malformed input handling (3 tests):**

```typescript
describe('Malformed Input Handling', () => {
  it('should reject invalid JSON gracefully', async () => {
    const response = await server.inject({
      method: 'POST',
      url: '/verify',
      headers: { 'content-type': 'application/json' },
      payload: 'not-json{{{',
    });
    // Should return error, NOT crash
    expect(response.statusCode).toBeGreaterThanOrEqual(400);
    expect(response.statusCode).toBeLessThan(500);
  });

  it('should reject empty body on POST routes', async () => {
    const response = await server.inject({
      method: 'POST',
      url: '/verify',
    });
    expect(response.statusCode).toBe(200); // Our routes return 200 with error payload
    const body = response.json();
    expect(body.valid).toBe(false);
  });

  it('should handle extremely long string values without crash', async () => {
    const response = await server.inject({
      method: 'POST',
      url: '/verify',
      payload: {
        transaction: 'a'.repeat(50000), // At body limit
        paymentRequirements: { scheme: 'x'.repeat(1000) },
      },
    });
    // Should not crash — returns validation error
    expect(response.statusCode).toBeLessThan(500);
  });
});
```

**3. Replay protection (2 tests):**

```typescript
describe('Replay Protection', () => {
  it('should reject duplicate transaction via dedup key', async () => {
    // This tests the SHA-256 dedup in settle-payment.ts
    // Mock settlePayment to return duplicate_transaction for same CBOR
    // Submit same transaction twice, verify second returns dedup result
  });

  it('should return consistent result for idempotent resubmission', async () => {
    // Same transaction submitted twice should not double-settle
    // Mock shows the second call returns the original txHash
  });
});
```

**4. Token confusion defense (2 tests):**

```typescript
describe('Token Confusion Defense', () => {
  it('should reject unknown token policy IDs', async () => {
    // POST /verify with a fake policy ID that's not in SUPPORTED_TOKENS
    // Verify response includes 'unsupported_token' failure reason
  });

  it('should not accept USDM policy ID with DJED asset name', async () => {
    // Attempt to mix policy IDs and asset names
    // Verify the token registry correctly matches unit strings
  });
});
```

**5. Error response sanitization in production (2 tests):**

```typescript
describe('Production Error Sanitization', () => {
  it('should not include stack traces in production error responses', async () => {
    // Create server with env: 'production'
    // Trigger a 500 error
    // Verify no 'stack' field in response
  });

  it('should sanitize internal error messages in production', async () => {
    // Create server with env: 'production'
    // Trigger INTERNAL_ERROR
    // Verify message is generic
  });
});
```

**Implementation notes:**

- Use the same chain mock pattern as `tests/security/controls.test.ts`
- For replay/dedup tests, mock `settlePayment` at the module level (same as settle-route.test.ts)
- For token confusion tests, craft verify payloads with known-bad policy IDs
- Create production-mode server only for the sanitization tests (separate describe block with its own beforeEach/afterEach)
  </action>
  <verify>
- `pnpm test tests/security/adversarial.test.ts` passes
- At least 10 adversarial test cases
- All tests verify security properties, not just functionality
  </verify>
  <done>Adversarial security test suite covers secret leakage, malformed inputs, replay protection, token confusion, and production error sanitization.</done>
</task>

<task type="auto">
  <name>Task 3: Dependency vulnerability audit</name>
  <files>(no files modified — audit only)</files>
  <action>
Run `pnpm audit` to check for known vulnerabilities in dependencies.

**Steps:**

1. Run `pnpm audit` and capture output
2. If any high or critical vulnerabilities are found:
   - Check if they're in runtime dependencies (fix required) or dev dependencies (lower priority)
   - Update affected packages if safe to do so
   - Document any that cannot be fixed (e.g., transitive dependencies with no update available)
3. If zero high/critical: document the clean audit as evidence for security checklist closure

**Expected outcome:** Zero high/critical vulnerabilities in runtime dependencies. Dev dependency vulnerabilities documented but not blocking.

If the libsodium-wrappers-sumo override (0.8.2) has known vulnerabilities, document this as accepted risk (required for ESM compatibility, no alternative available).
  </action>
  <verify>
- `pnpm audit` output reviewed
- Zero high/critical vulnerabilities in runtime dependencies, OR documented accepted risks
  </verify>
  <done>Dependency audit complete. Vulnerability status documented for security checklist closure in Plan 06-04.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds with zero errors
- `pnpm test` passes with all existing + new tests
- Per-endpoint rate limits confirmed on /verify, /settle, /status
- Adversarial test suite covers ≥10 security scenarios
- `pnpm audit` results reviewed and documented
- No regressions in existing tests
</verification>

<success_criteria>
Security controls are tightened (per-endpoint rate limits), adversarial tests prove security properties (replay, leakage, confusion, sanitization), and dependency health is verified. Foundation ready for Plan 06-04 (security checklist closure and final verification).
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-hardening/06-03-SUMMARY.md`
</output>
