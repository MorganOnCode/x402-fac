---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - src/server.ts
  - src/index.ts
  - src/plugins/error-handler.ts
  - src/plugins/request-logger.ts
  - src/types/index.ts
  - tests/integration/server.test.ts
autonomous: true

must_haves:
  truths:
    - "Server starts and listens on configured port"
    - "Requests have correlation IDs (x-request-id header)"
    - "Request/response logging includes timestamps and correlation IDs"
    - "Security headers are set via helmet"
    - "Errors return consistent JSON format with domain codes"
  artifacts:
    - path: "src/server.ts"
      provides: "Fastify server factory"
      exports: ["createServer"]
    - path: "src/plugins/error-handler.ts"
      provides: "Custom error handler plugin"
      contains: "setErrorHandler"
    - path: "src/plugins/request-logger.ts"
      provides: "Request/response logging plugin"
      contains: "addHook"
  key_links:
    - from: "src/index.ts"
      to: "src/server.ts"
      via: "imports createServer"
      pattern: "import.*createServer"
    - from: "src/server.ts"
      to: "src/config/index.ts"
      via: "uses config for server setup"
      pattern: "import.*config"
    - from: "src/server.ts"
      to: "src/plugins/error-handler.ts"
      via: "registers plugin"
      pattern: "register.*errorHandler"
---

<objective>
Create the HTTP server foundation with Fastify, security plugins, and request/response logging.

Purpose: Establish the core server infrastructure that all API endpoints will be built on. Per CONTEXT.md, error responses are verbose in development and sanitized in production. Logging includes correlation IDs for request tracing.

Output: Working Fastify server with helmet, CORS, error handling, and structured logging.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Fastify server with security plugins</name>
  <files>
    src/server.ts
    src/types/index.ts
  </files>
  <action>
    1. Update src/types/index.ts with server types:
       ```typescript
       import type { FastifyInstance } from 'fastify';
       import type { Config } from '../config/index.js';

       export interface ServerOptions {
         config: Config;
       }

       // Augment Fastify types
       declare module 'fastify' {
         interface FastifyInstance {
           config: Config;
         }
       }
       ```

    2. Create src/server.ts:
       ```typescript
       import fastify, { FastifyInstance } from 'fastify';
       import helmet from '@fastify/helmet';
       import cors from '@fastify/cors';
       import { randomUUID } from 'node:crypto';
       import type { Config } from './config/index.js';
       import { errorHandlerPlugin } from './plugins/error-handler.js';
       import { requestLoggerPlugin } from './plugins/request-logger.js';

       export interface CreateServerOptions {
         config: Config;
       }

       export async function createServer(options: CreateServerOptions): Promise<FastifyInstance> {
         const { config } = options;
         const isDev = config.env === 'development';

         const server = fastify({
           logger: {
             level: config.logging.level,
             transport: config.logging.pretty
               ? {
                   target: 'pino-pretty',
                   options: {
                     colorize: true,
                     translateTime: 'HH:MM:ss Z',
                     ignore: 'pid,hostname',
                   },
                 }
               : undefined,
           },
           // Request ID handling
           requestIdHeader: 'x-request-id',
           genReqId: () => randomUUID(),
           // Disable default request logging (we use custom plugin)
           disableRequestLogging: true,
         });

         // Decorate server with config for access in routes
         server.decorate('config', config);

         // Security headers
         await server.register(helmet, {
           global: true,
           // CSP can be customized per-route if needed
           contentSecurityPolicy: isDev ? false : undefined,
         });

         // CORS - permissive in dev, restrictive in prod
         await server.register(cors, {
           origin: isDev ? true : false,
           methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
           allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID'],
         });

         // Custom plugins
         await server.register(errorHandlerPlugin, { isDev });
         await server.register(requestLoggerPlugin, { isDev });

         return server;
       }
       ```

    3. This task creates the server factory. Plugins are created in subsequent tasks.
  </action>
  <verify>
    - `pnpm typecheck` passes
    - src/server.ts exports createServer function
  </verify>
  <done>
    Fastify server factory created with helmet, CORS, and plugin registration. Server decorated with config.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement error handler and request logger plugins</name>
  <files>
    src/plugins/error-handler.ts
    src/plugins/request-logger.ts
  </files>
  <action>
    1. Create src/plugins/error-handler.ts:
       ```typescript
       import { FastifyPluginCallback, FastifyError } from 'fastify';
       import fp from 'fastify-plugin';

       interface ErrorHandlerOptions {
         isDev: boolean;
       }

       interface ErrorResponse {
         error: {
           code: string;
           message: string;
           statusCode: number;
           stack?: string;
         };
         requestId: string;
         timestamp: string;
       }

       const errorHandler: FastifyPluginCallback<ErrorHandlerOptions> = (fastify, options, done) => {
         const { isDev } = options;

         fastify.setErrorHandler((error: FastifyError, request, reply) => {
           const statusCode = error.statusCode ?? 500;
           const code = error.code ?? 'INTERNAL_ERROR';

           // Log the error
           request.log.error({
             err: error,
             code,
             statusCode,
           }, 'Request error');

           const response: ErrorResponse = {
             error: {
               code,
               message: isDev ? error.message : sanitizeMessage(error.message, code),
               statusCode,
               // Only include stack in development
               ...(isDev && error.stack && { stack: error.stack }),
             },
             requestId: request.id,
             timestamp: new Date().toISOString(),
           };

           reply.status(statusCode).send(response);
         });

         done();
       };

       function sanitizeMessage(message: string, code: string): string {
         // In production, return generic messages for internal errors
         if (code === 'INTERNAL_ERROR' || code.startsWith('SERVER_')) {
           return 'An internal error occurred';
         }
         // Config errors should be visible (they're startup issues)
         if (code.startsWith('CONFIG_')) {
           return message;
         }
         // Default: return the message (it's likely user-facing)
         return message;
       }

       export const errorHandlerPlugin = fp(errorHandler, {
         name: 'error-handler',
         fastify: '5.x',
       });
       ```

    2. Add fastify-plugin dependency if not present:
       `pnpm add fastify-plugin`

    3. Create src/plugins/request-logger.ts:
       ```typescript
       import { FastifyPluginCallback } from 'fastify';
       import fp from 'fastify-plugin';

       interface RequestLoggerOptions {
         isDev: boolean;
       }

       const requestLogger: FastifyPluginCallback<RequestLoggerOptions> = (fastify, options, done) => {
         const { isDev } = options;

         // Log incoming requests
         fastify.addHook('onRequest', async (request) => {
           const logData: Record<string, unknown> = {
             method: request.method,
             url: request.url,
             requestId: request.id,
             userAgent: request.headers['user-agent'],
           };

           // Full body in dev, metadata only in prod (per CONTEXT.md)
           if (isDev && request.body) {
             logData.body = request.body;
           }

           request.log.info(logData, 'Incoming request');
         });

         // Log completed responses
         fastify.addHook('onResponse', async (request, reply) => {
           const logData: Record<string, unknown> = {
             method: request.method,
             url: request.url,
             statusCode: reply.statusCode,
             responseTime: reply.elapsedTime,
             requestId: request.id,
           };

           // Log at appropriate level based on status code
           if (reply.statusCode >= 500) {
             request.log.error(logData, 'Request completed with server error');
           } else if (reply.statusCode >= 400) {
             request.log.warn(logData, 'Request completed with client error');
           } else {
             request.log.info(logData, 'Request completed');
           }
         });

         done();
       };

       export const requestLoggerPlugin = fp(requestLogger, {
         name: 'request-logger',
         fastify: '5.x',
       });
       ```
  </action>
  <verify>
    - `pnpm typecheck` passes
    - Both plugins export properly
  </verify>
  <done>
    Error handler sanitizes messages in production, shows stack in development. Request logger includes correlation IDs and respects body logging rules.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update entry point and add integration tests</name>
  <files>
    src/index.ts
    tests/integration/server.test.ts
  </files>
  <action>
    1. Update src/index.ts:
       ```typescript
       import { loadConfig } from './config/index.js';
       import { createServer } from './server.js';

       async function main(): Promise<void> {
         // Load and validate config (fails fast if invalid)
         const config = loadConfig();

         // Create server
         const server = await createServer({ config });

         // Start listening
         try {
           const address = await server.listen({
             host: config.server.host,
             port: config.server.port,
           });
           server.log.info(`Server listening at ${address}`);
         } catch (err) {
           server.log.error(err, 'Failed to start server');
           process.exit(1);
         }

         // Graceful shutdown
         const shutdown = async (signal: string) => {
           server.log.info(`Received ${signal}, shutting down...`);
           await server.close();
           process.exit(0);
         };

         process.on('SIGINT', () => shutdown('SIGINT'));
         process.on('SIGTERM', () => shutdown('SIGTERM'));
       }

       main().catch((err) => {
         console.error('Fatal error:', err);
         process.exit(1);
       });
       ```

    2. Create tests/integration/server.test.ts:
       ```typescript
       import { describe, it, expect, beforeAll, afterAll } from 'vitest';
       import { FastifyInstance } from 'fastify';
       import { createServer } from '@/server.js';
       import type { Config } from '@/config/index.js';

       describe('Server Integration', () => {
         let server: FastifyInstance;

         const testConfig: Config = {
           server: { host: '0.0.0.0', port: 0 }, // Port 0 = random available port
           logging: { level: 'error', pretty: false }, // Quiet logs in tests
           env: 'test',
         };

         beforeAll(async () => {
           server = await createServer({ config: testConfig });
           await server.listen({ port: 0 });
         });

         afterAll(async () => {
           await server.close();
         });

         it('should have security headers from helmet', async () => {
           const response = await server.inject({
             method: 'GET',
             url: '/nonexistent',
           });

           // Helmet sets these headers
           expect(response.headers['x-dns-prefetch-control']).toBe('off');
           expect(response.headers['x-frame-options']).toBe('SAMEORIGIN');
           expect(response.headers['x-content-type-options']).toBe('nosniff');
         });

         it('should return request ID in error responses', async () => {
           const response = await server.inject({
             method: 'GET',
             url: '/nonexistent',
             headers: {
               'x-request-id': 'test-request-123',
             },
           });

           const body = JSON.parse(response.body);
           expect(body.requestId).toBe('test-request-123');
         });

         it('should generate request ID if not provided', async () => {
           const response = await server.inject({
             method: 'GET',
             url: '/nonexistent',
           });

           const body = JSON.parse(response.body);
           expect(body.requestId).toBeDefined();
           expect(body.requestId).toMatch(/^[0-9a-f-]{36}$/); // UUID format
         });

         it('should return 404 for unknown routes', async () => {
           const response = await server.inject({
             method: 'GET',
             url: '/unknown-route',
           });

           expect(response.statusCode).toBe(404);
         });

         it('should include timestamp in error responses', async () => {
           const response = await server.inject({
             method: 'GET',
             url: '/nonexistent',
           });

           const body = JSON.parse(response.body);
           expect(body.timestamp).toBeDefined();
           expect(new Date(body.timestamp).getTime()).not.toBeNaN();
         });
       });
       ```
  </action>
  <verify>
    - `pnpm test` passes all tests including integration tests
    - `pnpm dev` starts server (requires config/config.json from Plan 03)
    - Server logs show request correlation IDs
  </verify>
  <done>
    Server starts with config, handles errors consistently, logs with correlation IDs. Integration tests verify security headers and error format.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `pnpm test` - all tests pass including integration tests
2. `pnpm dev` - server starts and logs startup message
3. `curl http://localhost:3000/test` - returns 404 with:
   - JSON error response
   - requestId field
   - timestamp field
   - Security headers (check with `curl -I`)
4. Logs show request/response with correlation IDs
</verification>

<success_criteria>
- Server starts on configured host:port
- Helmet security headers present on all responses
- CORS configured (permissive in dev, restrictive in prod)
- Error responses include: code, message, statusCode, requestId, timestamp
- Stack traces in error responses only in development
- Request/response logging with correlation IDs
- Full request bodies logged only in development
- Graceful shutdown on SIGINT/SIGTERM
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
