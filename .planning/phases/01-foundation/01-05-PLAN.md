---
phase: 01-foundation
plan: 05
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - src/routes/health.ts
  - src/server.ts
  - src/instrument.ts
  - .github/dependabot.yml
  - tests/integration/health.test.ts
autonomous: true
user_setup:
  - service: sentry
    why: "Error tracking and monitoring"
    env_vars:
      - name: "Sentry DSN (in config.json)"
        source: "Sentry Dashboard -> Settings -> Client Keys (DSN)"
    account_setup:
      - task: "Create Sentry account and project"
        url: "https://sentry.io/signup/"
  - service: github
    why: "Dependabot vulnerability scanning"
    dashboard_config:
      - task: "Enable Dependabot alerts"
        location: "GitHub repo -> Settings -> Code security and analysis"

must_haves:
  truths:
    - "GET /health returns 200 with status, timestamp, and dependencies"
    - "Sentry captures unhandled errors when DSN is configured"
    - "Dependabot scans dependencies for vulnerabilities"
    - "Health check reflects actual dependency status"
  artifacts:
    - path: "src/routes/health.ts"
      provides: "Health check endpoint"
      exports: ["healthRoutes"]
    - path: "src/instrument.ts"
      provides: "Sentry initialization"
      contains: "Sentry.init"
    - path: ".github/dependabot.yml"
      provides: "Dependabot configuration"
      contains: "npm"
  key_links:
    - from: "src/index.ts"
      to: "src/instrument.ts"
      via: "imports first for Sentry"
      pattern: "import.*instrument"
    - from: "src/server.ts"
      to: "src/routes/health.ts"
      via: "registers health routes"
      pattern: "register.*healthRoutes"
---

<objective>
Implement the /health endpoint and security baseline with Sentry error tracking and Dependabot scanning.

Purpose: Complete the foundation phase with production-ready observability and security. The health endpoint (OPER-02) enables monitoring, Sentry (FOUND-05) captures errors, and Dependabot (FOUND-04) scans for vulnerabilities.

Output: Working /health endpoint, Sentry integration, Dependabot configuration.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement /health endpoint with dependency checks</name>
  <files>
    src/routes/health.ts
    src/server.ts
    tests/integration/health.test.ts
  </files>
  <action>
    1. Create src/routes/health.ts:
       ```typescript
       import { FastifyInstance, FastifyPluginCallback } from 'fastify';
       import fp from 'fastify-plugin';

       interface DependencyStatus {
         status: 'up' | 'down';
         latency?: number;
         error?: string;
       }

       interface HealthResponse {
         status: 'healthy' | 'degraded' | 'unhealthy';
         timestamp: string;
         version: string;
         uptime: number;
         dependencies: Record<string, DependencyStatus>;
       }

       // Dependency check functions (will be expanded in later phases)
       async function checkRedis(): Promise<DependencyStatus> {
         // Placeholder - Redis check will be implemented in Phase 2+
         // For now, return 'up' if not configured
         return { status: 'up', latency: 0 };
       }

       async function checkIpfs(): Promise<DependencyStatus> {
         // Placeholder - IPFS check will be implemented in Phase 7
         // For now, return 'up' if not configured
         return { status: 'up', latency: 0 };
       }

       const healthRoutes: FastifyPluginCallback = (fastify, _options, done) => {
         fastify.get<{ Reply: HealthResponse }>('/health', async (request, reply) => {
           const startTime = process.hrtime.bigint();

           // Run dependency checks in parallel
           const [redisStatus, ipfsStatus] = await Promise.all([
             checkRedis().catch((err): DependencyStatus => ({
               status: 'down',
               error: err.message,
             })),
             checkIpfs().catch((err): DependencyStatus => ({
               status: 'down',
               error: err.message,
             })),
           ]);

           const dependencies: Record<string, DependencyStatus> = {
             redis: redisStatus,
             ipfs: ipfsStatus,
           };

           // Determine overall status
           const allUp = Object.values(dependencies).every((d) => d.status === 'up');
           const allDown = Object.values(dependencies).every((d) => d.status === 'down');

           let status: HealthResponse['status'];
           if (allUp) {
             status = 'healthy';
           } else if (allDown) {
             status = 'unhealthy';
           } else {
             status = 'degraded';
           }

           const response: HealthResponse = {
             status,
             timestamp: new Date().toISOString(),
             version: process.env.npm_package_version ?? '0.0.0',
             uptime: process.uptime(),
             dependencies,
           };

           // Set appropriate status code
           const statusCode = status === 'healthy' ? 200 : status === 'degraded' ? 200 : 503;

           return reply.status(statusCode).send(response);
         });

         done();
       };

       export const healthRoutesPlugin = fp(healthRoutes, {
         name: 'health-routes',
         fastify: '5.x',
       });
       ```

    2. Update src/server.ts to register health routes:
       Add import: `import { healthRoutesPlugin } from './routes/health.js';`
       Add registration after other plugins:
       ```typescript
       // Routes
       await server.register(healthRoutesPlugin);
       ```

    3. Create tests/integration/health.test.ts:
       ```typescript
       import { describe, it, expect, beforeAll, afterAll } from 'vitest';
       import { FastifyInstance } from 'fastify';
       import { createServer } from '@/server.js';
       import type { Config } from '@/config/index.js';

       describe('Health Endpoint', () => {
         let server: FastifyInstance;

         const testConfig: Config = {
           server: { host: '0.0.0.0', port: 0 },
           logging: { level: 'error', pretty: false },
           env: 'test',
         };

         beforeAll(async () => {
           server = await createServer({ config: testConfig });
           await server.listen({ port: 0 });
         });

         afterAll(async () => {
           await server.close();
         });

         it('should return 200 with health status', async () => {
           const response = await server.inject({
             method: 'GET',
             url: '/health',
           });

           expect(response.statusCode).toBe(200);

           const body = JSON.parse(response.body);
           expect(body.status).toBe('healthy');
           expect(body.timestamp).toBeDefined();
           expect(body.uptime).toBeGreaterThan(0);
           expect(body.dependencies).toBeDefined();
         });

         it('should include dependency status', async () => {
           const response = await server.inject({
             method: 'GET',
             url: '/health',
           });

           const body = JSON.parse(response.body);
           expect(body.dependencies.redis).toBeDefined();
           expect(body.dependencies.ipfs).toBeDefined();
           expect(body.dependencies.redis.status).toBe('up');
         });

         it('should return ISO timestamp', async () => {
           const response = await server.inject({
             method: 'GET',
             url: '/health',
           });

           const body = JSON.parse(response.body);
           const timestamp = new Date(body.timestamp);
           expect(timestamp.getTime()).not.toBeNaN();
         });
       });
       ```
  </action>
  <verify>
    - `pnpm test` passes including health endpoint tests
    - `curl http://localhost:3000/health` returns JSON with status, timestamp, dependencies
  </verify>
  <done>
    /health endpoint returns status with dependency checks. Response includes timestamp, uptime, and version.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Sentry error tracking integration</name>
  <files>
    src/instrument.ts
    src/index.ts
    src/config/schema.ts
  </files>
  <action>
    1. Create src/instrument.ts (must be imported FIRST per Sentry docs):
       ```typescript
       import * as Sentry from '@sentry/node';

       // Only initialize if DSN is provided
       // This allows running without Sentry in development
       export function initSentry(dsn: string | undefined, environment: string): void {
         if (!dsn) {
           console.log('Sentry DSN not configured, error tracking disabled');
           return;
         }

         Sentry.init({
           dsn,
           environment,
           tracesSampleRate: 1.0,
           // Capture unhandled promise rejections
           integrations: [
             Sentry.onUnhandledRejectionIntegration(),
           ],
         });

         console.log(`Sentry initialized for environment: ${environment}`);
       }

       // Re-export Sentry for use in error handler
       export { Sentry };
       ```

    2. Update src/index.ts to initialize Sentry first:
       ```typescript
       import { initSentry } from './instrument.js';
       import { loadConfig } from './config/index.js';
       import { createServer } from './server.js';

       async function main(): Promise<void> {
         // Load and validate config (fails fast if invalid)
         const config = loadConfig();

         // Initialize Sentry before anything else
         initSentry(config.sentry?.dsn, config.env);

         // Create server
         const server = await createServer({ config });

         // ... rest of main() unchanged
       ```

    3. Update src/plugins/error-handler.ts to capture errors in Sentry:
       Add at top:
       ```typescript
       import { Sentry } from '../instrument.js';
       ```

       In the error handler, before sending response:
       ```typescript
       // Capture server errors in Sentry
       if (statusCode >= 500) {
         Sentry.captureException(error, {
           extra: {
             requestId: request.id,
             url: request.url,
             method: request.method,
           },
         });
       }
       ```

    4. No schema changes needed - sentry config already optional in schema
  </action>
  <verify>
    - `pnpm typecheck` passes
    - Server starts without Sentry DSN (logs "Sentry DSN not configured")
    - If Sentry DSN added to config, logs "Sentry initialized for environment: ..."
  </verify>
  <done>
    Sentry captures 500 errors when DSN is configured. Gracefully disabled when DSN not provided.
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure Dependabot and verify security checklist</name>
  <files>
    .github/dependabot.yml
    .gitignore
  </files>
  <action>
    1. Create .github/dependabot.yml:
       ```yaml
       # Dependabot configuration for automated security updates
       # Satisfies requirement FOUND-04: Dependency vulnerability scanning

       version: 2
       updates:
         - package-ecosystem: "npm"
           directory: "/"
           schedule:
             interval: "weekly"
             day: "monday"
             time: "09:00"
             timezone: "UTC"
           open-pull-requests-limit: 10
           commit-message:
             prefix: "deps"
             include: "scope"
           groups:
             # Group dev dependencies for fewer PRs
             development-dependencies:
               patterns:
                 - "@types/*"
                 - "vitest"
                 - "@vitest/*"
                 - "eslint*"
                 - "prettier"
                 - "typescript"
                 - "tsdown"
               update-types:
                 - "minor"
                 - "patch"
             # Group Fastify ecosystem updates
             fastify-ecosystem:
               patterns:
                 - "fastify"
                 - "@fastify/*"
                 - "fastify-*"
               update-types:
                 - "minor"
                 - "patch"
           # Security updates are always created immediately
           # regardless of the schedule
       ```

    2. Ensure .github directory exists: `mkdir -p .github`

    3. Verify security checklist by checking:
       - [ ] config/config.json is in .gitignore (secrets gitignored)
       - [ ] No hardcoded secrets in source files
       - [ ] Helmet configured (done in Plan 04)
       - [ ] Error responses sanitized in production (done in Plan 04)
       - [ ] Sentry captures errors (done in Task 2)

    4. Update final .gitignore with all exclusions:
       ```
       # Dependencies
       node_modules/

       # Build output
       dist/

       # Test coverage
       coverage/

       # Test fixtures
       tests/fixtures/

       # Configuration with secrets
       config/config.json

       # IDE
       .idea/

       # OS files
       .DS_Store
       Thumbs.db

       # Logs
       *.log
       logs/
       ```
  </action>
  <verify>
    - .github/dependabot.yml exists with npm ecosystem config
    - `git check-ignore config/config.json` returns the path
    - `grep -r "password\|secret\|key" src/` finds no hardcoded secrets
  </verify>
  <done>
    Dependabot configured for weekly scans. Security checklist verified. No secrets in code.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

Run Phase 1 success criteria checks:

1. `pnpm install && pnpm build` - succeeds with zero errors
2. `pnpm test` - runs test suite with coverage
3. `pnpm lint` - passes with zero violations
4. Server starts: `pnpm dev`
5. `curl http://localhost:3000/health` - returns 200 with status
6. Check logs for correlation IDs on requests
7. `.github/dependabot.yml` exists
8. Pre-commit hook runs: `git add . && git commit -m "test"`
</verification>

<success_criteria>
- GET /health returns 200 with healthy/degraded/unhealthy status
- Health response includes timestamp, uptime, version, dependencies
- Sentry initializes when DSN provided, gracefully disabled otherwise
- Server errors (500) captured in Sentry with request context
- Dependabot configured for weekly npm scans
- Security checklist passed:
  - Secrets gitignored
  - No hardcoded secrets
  - Helmet security headers
  - Error responses sanitized
  - Input validation (Zod on config)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
