---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/config/index.ts
  - src/config/schema.ts
  - src/errors/index.ts
  - config/config.example.json
  - config/config.json
  - .gitignore
  - tests/unit/config.test.ts
autonomous: true

must_haves:
  truths:
    - "Server fails fast if config.json is missing or invalid"
    - "Config values are typed and validated with Zod"
    - "Error codes use domain prefixes (e.g., CONFIG_INVALID)"
    - "Secrets in config.json are gitignored"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "Zod schema for configuration"
      contains: "z.object"
    - path: "src/config/index.ts"
      provides: "Config loading function"
      exports: ["loadConfig", "Config"]
    - path: "src/errors/index.ts"
      provides: "Domain-prefixed error classes"
      contains: "createError"
    - path: "config/config.example.json"
      provides: "Example configuration template"
      min_lines: 10
  key_links:
    - from: "src/config/index.ts"
      to: "src/config/schema.ts"
      via: "imports schema"
      pattern: "import.*schema"
    - from: "src/config/index.ts"
      to: "src/errors/index.ts"
      via: "throws domain errors"
      pattern: "throw new Config"
---

<objective>
Implement the configuration loading system with Zod validation and typed error classes.

Purpose: Per CONTEXT.md decisions, configuration uses a single config.json file with Zod validation. The system must fail fast on startup if configuration is invalid, providing clear error messages for debugging.

Output: Type-safe configuration loading with validation, domain-prefixed error classes, example config file.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed error classes with domain prefixes</name>
  <files>
    src/errors/index.ts
  </files>
  <action>
    1. Create src/errors/index.ts with domain-prefixed errors:
       ```typescript
       import createError from '@fastify/error';

       // Configuration errors (CONFIG_*)
       export const ConfigInvalidError = createError<[string]>(
         'CONFIG_INVALID',
         'Invalid configuration: %s',
         500
       );

       export const ConfigMissingError = createError<[string]>(
         'CONFIG_MISSING',
         'Missing configuration file: %s',
         500
       );

       export const ConfigParseError = createError<[string]>(
         'CONFIG_PARSE_ERROR',
         'Failed to parse configuration: %s',
         500
       );

       // Server errors (SERVER_*)
       export const ServerStartError = createError<[string]>(
         'SERVER_START_ERROR',
         'Failed to start server: %s',
         500
       );

       // Generic internal error
       export const InternalError = createError<[string]>(
         'INTERNAL_ERROR',
         'Internal error: %s',
         500
       );

       // Type for all application errors
       export type AppError =
         | typeof ConfigInvalidError
         | typeof ConfigMissingError
         | typeof ConfigParseError
         | typeof ServerStartError
         | typeof InternalError;
       ```

    Note: Domain prefixes per CONTEXT.md:
    - CONFIG_* for configuration errors
    - SERVER_* for server errors
    - Future phases add: VERIFY_*, SETTLE_*, CHAIN_*
  </action>
  <verify>
    - `pnpm typecheck` passes
    - Importing errors in REPL: `import { ConfigInvalidError } from './src/errors/index.js'`
    - `new ConfigInvalidError('test').code` returns 'CONFIG_INVALID'
  </verify>
  <done>
    Error classes created with domain prefixes. All errors extend FastifyError for consistent handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement config schema and loading</name>
  <files>
    src/config/schema.ts
    src/config/index.ts
    config/config.example.json
    config/config.json
    .gitignore
  </files>
  <action>
    1. Create src/config/schema.ts with Zod schema:
       ```typescript
       import { z } from 'zod';

       export const ConfigSchema = z.object({
         server: z.object({
           host: z.string().default('0.0.0.0'),
           port: z.number().int().min(1).max(65535).default(3000),
         }).default({}),

         logging: z.object({
           level: z.enum(['trace', 'debug', 'info', 'warn', 'error', 'fatal']).default('info'),
           pretty: z.boolean().default(false),
         }).default({}),

         // Optional Sentry integration
         sentry: z.object({
           dsn: z.string().url(),
           environment: z.string().default('development'),
         }).optional(),

         // Environment mode
         env: z.enum(['development', 'production', 'test']).default('development'),
       });

       export type Config = z.infer<typeof ConfigSchema>;
       ```

    2. Create src/config/index.ts with loading logic:
       ```typescript
       import { readFileSync, existsSync } from 'node:fs';
       import { resolve } from 'node:path';
       import { ConfigSchema, type Config } from './schema.js';
       import { ConfigMissingError, ConfigParseError, ConfigInvalidError } from '../errors/index.js';

       export { Config } from './schema.js';

       const DEFAULT_CONFIG_PATH = resolve(process.cwd(), 'config', 'config.json');

       export function loadConfig(configPath: string = DEFAULT_CONFIG_PATH): Config {
         // Check file exists
         if (!existsSync(configPath)) {
           throw new ConfigMissingError(configPath);
         }

         // Read and parse JSON
         let rawConfig: unknown;
         try {
           const fileContent = readFileSync(configPath, 'utf-8');
           rawConfig = JSON.parse(fileContent);
         } catch (error) {
           const message = error instanceof Error ? error.message : 'Unknown parse error';
           throw new ConfigParseError(message);
         }

         // Validate with Zod
         const result = ConfigSchema.safeParse(rawConfig);

         if (!result.success) {
           // Format Zod errors for readability
           const errors = result.error.errors
             .map((e) => `${e.path.join('.')}: ${e.message}`)
             .join(', ');
           throw new ConfigInvalidError(errors);
         }

         return result.data;
       }
       ```

    3. Create config/config.example.json (committed to repo):
       ```json
       {
         "server": {
           "host": "0.0.0.0",
           "port": 3000
         },
         "logging": {
           "level": "info",
           "pretty": true
         },
         "sentry": {
           "dsn": "https://your-sentry-dsn@sentry.io/project-id",
           "environment": "development"
         },
         "env": "development"
       }
       ```

    4. Create config/config.json (gitignored, for local dev):
       ```json
       {
         "server": {
           "host": "0.0.0.0",
           "port": 3000
         },
         "logging": {
           "level": "debug",
           "pretty": true
         },
         "env": "development"
       }
       ```
       Note: Sentry omitted in local config (optional field)

    5. Add to .gitignore:
       ```
       # Configuration with secrets
       config/config.json
       ```

    6. Re-export from src/config/index.ts for clean imports
  </action>
  <verify>
    - `pnpm typecheck` passes
    - config/config.json is gitignored: `git check-ignore config/config.json` returns the path
    - config/config.example.json is NOT ignored: `git check-ignore config/config.example.json` returns nothing
  </verify>
  <done>
    Config schema validates input with Zod. Missing/invalid configs throw domain-prefixed errors. Secrets are gitignored.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add config loading tests</name>
  <files>
    tests/unit/config.test.ts
  </files>
  <action>
    1. Create tests/unit/config.test.ts:
       ```typescript
       import { describe, it, expect, beforeEach, afterEach } from 'vitest';
       import { writeFileSync, unlinkSync, mkdirSync, existsSync } from 'node:fs';
       import { join } from 'node:path';
       import { loadConfig } from '@/config/index.js';

       const TEST_CONFIG_DIR = join(process.cwd(), 'tests', 'fixtures');
       const TEST_CONFIG_PATH = join(TEST_CONFIG_DIR, 'test-config.json');

       describe('Config Loading', () => {
         beforeEach(() => {
           if (!existsSync(TEST_CONFIG_DIR)) {
             mkdirSync(TEST_CONFIG_DIR, { recursive: true });
           }
         });

         afterEach(() => {
           if (existsSync(TEST_CONFIG_PATH)) {
             unlinkSync(TEST_CONFIG_PATH);
           }
         });

         it('should load valid config with defaults', () => {
           writeFileSync(TEST_CONFIG_PATH, JSON.stringify({}));
           const config = loadConfig(TEST_CONFIG_PATH);

           expect(config.server.host).toBe('0.0.0.0');
           expect(config.server.port).toBe(3000);
           expect(config.logging.level).toBe('info');
           expect(config.env).toBe('development');
         });

         it('should override defaults with provided values', () => {
           const customConfig = {
             server: { port: 8080 },
             logging: { level: 'debug' },
           };
           writeFileSync(TEST_CONFIG_PATH, JSON.stringify(customConfig));
           const config = loadConfig(TEST_CONFIG_PATH);

           expect(config.server.port).toBe(8080);
           expect(config.logging.level).toBe('debug');
         });

         it('should throw ConfigMissingError for non-existent file', () => {
           expect(() => loadConfig('/nonexistent/path/config.json'))
             .toThrow('CONFIG_MISSING');
         });

         it('should throw ConfigParseError for invalid JSON', () => {
           writeFileSync(TEST_CONFIG_PATH, 'not valid json');
           expect(() => loadConfig(TEST_CONFIG_PATH))
             .toThrow('CONFIG_PARSE_ERROR');
         });

         it('should throw ConfigInvalidError for invalid schema', () => {
           const invalidConfig = {
             server: { port: 'not a number' },
           };
           writeFileSync(TEST_CONFIG_PATH, JSON.stringify(invalidConfig));
           expect(() => loadConfig(TEST_CONFIG_PATH))
             .toThrow('CONFIG_INVALID');
         });

         it('should validate port range', () => {
           const invalidPort = { server: { port: 70000 } };
           writeFileSync(TEST_CONFIG_PATH, JSON.stringify(invalidPort));
           expect(() => loadConfig(TEST_CONFIG_PATH))
             .toThrow('CONFIG_INVALID');
         });

         it('should validate logging level enum', () => {
           const invalidLevel = { logging: { level: 'verbose' } };
           writeFileSync(TEST_CONFIG_PATH, JSON.stringify(invalidLevel));
           expect(() => loadConfig(TEST_CONFIG_PATH))
             .toThrow('CONFIG_INVALID');
         });
       });
       ```

    2. Add tests/fixtures/ to .gitignore
  </action>
  <verify>
    - `pnpm test` passes all config tests
    - Tests cover: valid config, defaults, missing file, parse error, validation error
  </verify>
  <done>
    Config loading has comprehensive test coverage. All error conditions verified.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `pnpm test` - all config tests pass
2. `pnpm typecheck` - no type errors
3. Config loading fails fast with clear errors:
   - Missing file: "CONFIG_MISSING: Missing configuration file: ..."
   - Invalid JSON: "CONFIG_PARSE_ERROR: Failed to parse configuration: ..."
   - Invalid values: "CONFIG_INVALID: Invalid configuration: server.port: ..."
4. `git check-ignore config/config.json` confirms it's ignored
</verification>

<success_criteria>
- Zod schema validates all config fields
- Defaults applied for optional fields
- ConfigMissingError thrown for missing file
- ConfigParseError thrown for invalid JSON
- ConfigInvalidError thrown for schema violations
- Error codes use domain prefixes (CONFIG_*)
- config.json gitignored, config.example.json committed
- Test coverage for all error paths
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
