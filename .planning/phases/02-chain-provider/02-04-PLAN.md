---
phase: 02-chain-provider
plan: 04
type: tdd
wave: 3
depends_on: ["02-01", "02-03"]
files_modified:
  - src/chain/utxo-reservation.ts
  - tests/unit/chain/utxo-reservation.test.ts
autonomous: true

must_haves:
  truths:
    - "Reserving an available UTXO returns true and prevents re-reservation"
    - "Reserving an already-reserved UTXO returns false"
    - "Expired reservations are automatically cleaned and their UTXOs become available"
    - "Releasing a reservation makes the UTXO immediately available"
    - "Exceeding max concurrent reservations (20) rejects new reservations"
    - "Reservations persist to Redis for crash recovery"
    - "Active reservation count is queryable"
  artifacts:
    - path: "src/chain/utxo-reservation.ts"
      provides: "UTXO reservation system with TTL and Redis persistence"
      exports: ["UtxoReservation", "createUtxoReservation"]
    - path: "tests/unit/chain/utxo-reservation.test.ts"
      provides: "Tests for reserve/release/expire/cap/persistence behavior"
      min_lines: 100
  key_links:
    - from: "src/chain/utxo-reservation.ts"
      to: "ioredis"
      via: "Persists reservations with PX TTL"
      pattern: "redis.*set.*PX|redis.*del"
    - from: "src/chain/utxo-reservation.ts"
      to: "src/chain/types.ts"
      via: "Uses Reservation type"
      pattern: "Reservation"
---

<objective>
Build the UTXO reservation system using TDD to ensure correct locking semantics.

Purpose: The reservation system prevents double-spend attempts when multiple payment requests arrive concurrently. Each UTXO can only be spent in one transaction -- if two requests select the same UTXO, one transaction will fail on-chain. The reservation system locks UTXOs during transaction construction with a 120-second TTL. This is a state machine with critical correctness requirements, making it ideal for TDD.

Output: A tested UtxoReservation class that locks/unlocks UTXO references with TTL, enforces max concurrent cap, auto-expires stale reservations, and persists to Redis for restart recovery.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-chain-provider/02-RESEARCH.md
@.planning/phases/02-chain-provider/02-01-SUMMARY.md
@.planning/phases/02-chain-provider/02-03-SUMMARY.md

@src/chain/types.ts
@src/chain/errors.ts
@src/chain/config.ts
</context>

<feature>
  <name>UTXO Reservation System</name>
  <files>src/chain/utxo-reservation.ts, tests/unit/chain/utxo-reservation.test.ts</files>
  <behavior>
    The UtxoReservation manages a set of locked UTXO references with TTL-based expiry.

    **Constructor:** `{ redis: Redis; ttlMs: number; maxConcurrent: number; logger: FastifyBaseLogger }`
    - `ttlMs` defaults to 120_000 (120 seconds, ~6 Cardano blocks)
    - `maxConcurrent` defaults to 20

    **reserve(utxoRef: string, requestId: string): boolean**
    - Cleans expired reservations first
    - If utxoRef is already reserved (not expired): return false
    - If activeCount >= maxConcurrent: return false
    - Creates Reservation: { utxoRef, reservedAt: Date.now(), expiresAt: Date.now() + ttlMs, requestId }
    - Stores in internal Map
    - Persists to Redis with key `reservation:{utxoRef}` and PX ttlMs (fire-and-forget)
    - Returns true

    **release(utxoRef: string): void**
    - Removes from internal Map
    - Deletes from Redis `reservation:{utxoRef}` (fire-and-forget)
    - Logs at debug level

    **releaseAll(requestId: string): void**
    - Releases all reservations matching the given requestId
    - Used when a transaction fails and all its reserved UTXOs should be freed

    **isReserved(utxoRef: string): boolean**
    - Cleans expired first
    - Returns true if utxoRef exists in Map and not expired

    **getActiveCount(): number**
    - Cleans expired first
    - Returns Map size

    **getReservation(utxoRef: string): Reservation | undefined**
    - Returns the Reservation object if active, undefined otherwise

    **cleanExpired(): void** (private)
    - Iterates Map, removes entries where expiresAt < Date.now()
    - Fire-and-forget Redis deletes for cleaned entries

    **loadFromRedis(): Promise<void>**
    - Scans Redis for keys matching `reservation:*`
    - Parses each value as Reservation
    - Loads into Map (skipping expired ones)
    - Called on startup for crash recovery

    Cases:
    - reserve("txA#0", "req1") -> true (first reservation)
    - reserve("txA#0", "req2") -> false (already reserved)
    - release("txA#0") then reserve("txA#0", "req2") -> true
    - After TTL expiry: reserve("txA#0", "req2") -> true
    - Reserve 20 UTXOs -> 21st returns false (cap hit)
    - releaseAll("req1") -> frees all req1 reservations
    - getActiveCount() after 3 reserves and 1 release -> 2
  </behavior>
  <implementation>
    Create `src/chain/utxo-reservation.ts`:

    The `UtxoReservation` class stores reservations in `private reservations: Map<string, Reservation>`.

    The `cleanExpired()` method iterates the map and removes stale entries. Call it at the start of `reserve()`, `isReserved()`, and `getActiveCount()` to ensure consistency.

    For `loadFromRedis()`, use `redis.keys('reservation:*')` to find active reservations, then `redis.mget()` to batch-fetch values. Parse each as a Reservation using JSON.parse. Skip expired ones. This is only called once at startup, not in the hot path.

    Export `createUtxoReservation(redis: Redis, config: ChainConfig, logger: FastifyBaseLogger): UtxoReservation` factory that reads `config.reservation.ttlSeconds * 1000` for ttlMs and `config.reservation.maxConcurrent` for the cap.

    For tests: mock ioredis. Use `vi.useFakeTimers()` to test TTL expiry without waiting. Test each case listed in behavior section. Verify Redis persistence calls are made (fire-and-forget, so check `redis.set` and `redis.del` were called with correct args).
  </implementation>
</feature>

<verification>
1. `pnpm test tests/unit/chain/utxo-reservation.test.ts` -- all tests pass
2. `pnpm typecheck` -- zero errors
3. `pnpm lint` -- passes
4. Tests cover: reserve success, reserve conflict, release then re-reserve, TTL expiry, cap enforcement, releaseAll by requestId, activeCount accuracy, loadFromRedis recovery
</verification>

<success_criteria>
- reserve() returns true for available UTXOs, false for reserved or cap-exceeded
- release() immediately frees the UTXO for re-reservation
- Expired reservations auto-clean on next operation
- Max 20 concurrent reservations enforced
- Redis persistence enables crash recovery via loadFromRedis()
- All tests pass with mocked Redis and fake timers
</success_criteria>

<output>
After completion, create `.planning/phases/02-chain-provider/02-04-SUMMARY.md`
</output>
