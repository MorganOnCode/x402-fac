---
phase: 02-chain-provider
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/chain/types.ts
  - src/chain/errors.ts
  - src/chain/config.ts
  - src/config/schema.ts
  - src/errors/index.ts
autonomous: true
user_setup:
  - service: blockfrost
    why: "Blockfrost API key required for Cardano blockchain queries"
    env_vars:
      - name: BLOCKFROST_PROJECT_ID (goes in config.json, not env)
        source: "https://blockfrost.io/dashboard -> Create Project -> Select 'Cardano Preview' network -> Copy Project ID"
    dashboard_config:
      - task: "Create a Blockfrost account and project"
        location: "https://blockfrost.io -> Sign Up -> Dashboard -> New Project -> Select 'Cardano Preview' network"

must_haves:
  truths:
    - "Chain config validates Blockfrost project ID, network, and Redis settings"
    - "Mainnet requires explicit MAINNET=true env var or config is rejected"
    - "Chain domain errors follow existing @fastify/error pattern with CHAIN_* codes"
    - "UTxO and Reservation types use bigint for lovelace values"
  artifacts:
    - path: "src/chain/types.ts"
      provides: "Chain domain types (CachedUtxo, UtxoRef, Reservation, CardanoNetwork)"
      exports: ["CachedUtxo", "UtxoRef", "Reservation", "CardanoNetwork", "BlockfrostTier"]
    - path: "src/chain/errors.ts"
      provides: "Chain domain errors (CHAIN_RATE_LIMITED, CHAIN_UTXO_EXHAUSTED, etc.)"
      exports: ["ChainRateLimitedError", "ChainConnectionError", "ChainUtxoExhaustedError", "ChainTransactionError", "ChainNetworkMismatchError"]
    - path: "src/chain/config.ts"
      provides: "Chain config Zod schema with mainnet guardrail"
      exports: ["ChainConfigSchema", "ChainConfig"]
    - path: "src/config/schema.ts"
      provides: "Extended ConfigSchema with chain section"
      contains: "chain:"
  key_links:
    - from: "src/chain/config.ts"
      to: "src/config/schema.ts"
      via: "ChainConfigSchema imported and added to ConfigSchema"
      pattern: "chain.*ChainConfigSchema"
    - from: "src/chain/errors.ts"
      to: "src/errors/index.ts"
      via: "Re-exported from central error barrel"
      pattern: "export.*from.*chain/errors"
---

<objective>
Establish the foundational types, domain errors, and configuration schema for the Cardano chain layer.

Purpose: Every other plan in this phase imports types, throws errors, and reads config from these files. This is the shared foundation that enables parallel development of the Blockfrost client, UTXO cache, and reservation system.

Output: Chain types (UTxO representations, reservation structures), domain errors (CHAIN_* codes using @fastify/error pattern), and Zod config schema extension for Blockfrost/network/Redis settings with mainnet safety guardrail.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chain-provider/02-RESEARCH.md
@.planning/phases/02-chain-provider/02-CONTEXT.md

@src/config/schema.ts
@src/errors/index.ts
@src/config/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chain types and domain errors</name>
  <files>src/chain/types.ts, src/chain/errors.ts</files>
  <action>
Create `src/chain/types.ts` with these type definitions:

- `CardanoNetwork`: Union type `'Preview' | 'Preprod' | 'Mainnet'` (matches Lucid Evolution's expected strings)
- `BlockfrostTier`: Union type `'free' | 'paid'`
- `UtxoRef`: Object `{ txHash: string; outputIndex: number }` - unique UTXO identifier
- `CachedUtxo`: Object containing `{ txHash: string; outputIndex: number; address: string; lovelace: bigint; assets: Record<string, bigint>; datumHash?: string }` - simplified UTXO representation for caching (uses bigint for all value fields)
- `Reservation`: Object `{ utxoRef: string; reservedAt: number; expiresAt: number; requestId: string }` where `utxoRef` is formatted as `"txHash#outputIndex"`
- `BLOCKFROST_URLS`: Const record mapping CardanoNetwork to Blockfrost API base URLs (`https://cardano-{network}.blockfrost.io/api/v0` for Preview/Preprod, `https://cardano-mainnet.blockfrost.io/api/v0` for Mainnet)
- Helper: `utxoRefToString(ref: UtxoRef): string` -> `"${ref.txHash}#${ref.outputIndex}"`
- Helper: `stringToUtxoRef(ref: string): UtxoRef` -> parse `"txHash#index"` back to object

Create `src/chain/errors.ts` following the existing `@fastify/error` pattern in `src/errors/index.ts`:

- `ChainRateLimitedError`: code `CHAIN_RATE_LIMITED`, message `'Blockfrost rate limit exceeded for: %s'`, status 503
- `ChainConnectionError`: code `CHAIN_CONNECTION_ERROR`, message `'Failed to connect to Cardano chain: %s'`, status 503
- `ChainUtxoExhaustedError`: code `CHAIN_UTXO_EXHAUSTED`, message `'No unreserved UTXOs available for transaction'`, status 503 (no args)
- `ChainTransactionError`: code `CHAIN_TX_ERROR`, message `'Transaction failed: %s'`, status 500
- `ChainNetworkMismatchError`: code `CHAIN_NETWORK_MISMATCH`, message `'Network configuration mismatch: %s'`, status 500

Then update `src/errors/index.ts` to re-export chain errors: `export * from '../chain/errors.js';` and add the chain error types to the `AppError` union type.

IMPORTANT: Use `export type` for type-only re-exports (ESM requirement established in Phase 1 decision). The error classes themselves are values and use regular `export`.
  </action>
  <verify>Run `pnpm typecheck` -- must pass with zero errors. Verify the re-export works by checking that importing from `@/errors/index.js` includes the chain error types.</verify>
  <done>All chain types and errors are defined, exported, and type-check cleanly. ChainRateLimitedError, ChainConnectionError, ChainUtxoExhaustedError, ChainTransactionError, ChainNetworkMismatchError all follow the @fastify/error pattern with correct codes and status codes.</done>
</task>

<task type="auto">
  <name>Task 2: Create chain config schema and extend main config</name>
  <files>src/chain/config.ts, src/config/schema.ts</files>
  <action>
Create `src/chain/config.ts` with a Zod schema:

```
ChainConfigSchema = z.object({
  network: z.enum(['Preview', 'Preprod', 'Mainnet']).default('Preview'),
  blockfrost: z.object({
    projectId: z.string().min(1, 'Blockfrost project ID is required'),
    url: z.string().url().optional(),  // Derived from network if not set
    tier: z.enum(['free', 'paid']).default('free'),
  }),
  facilitator: z.object({
    seedPhrase: z.string().optional(),
    privateKey: z.string().optional(),
  }).refine(
    (d) => d.seedPhrase || d.privateKey,
    'Either seedPhrase or privateKey must be provided'
  ),
  cache: z.object({
    utxoTtlSeconds: z.number().int().min(10).max(300).default(60),
  }).default(() => ({ utxoTtlSeconds: 60 })),
  reservation: z.object({
    ttlSeconds: z.number().int().min(30).max(600).default(120),
    maxConcurrent: z.number().int().min(1).max(100).default(20),
  }).default(() => ({ ttlSeconds: 120, maxConcurrent: 20 })),
  redis: z.object({
    host: z.string().default('127.0.0.1'),
    port: z.number().int().min(1).max(65535).default(6379),
  }).default(() => ({ host: '127.0.0.1', port: 6379 })),
})
```

Export `type ChainConfig = z.infer<typeof ChainConfigSchema>`.

Add a `resolveBlockfrostUrl(config: ChainConfig): string` function that returns `config.blockfrost.url` if set, otherwise derives from `BLOCKFROST_URLS[config.network]` (import from types.ts).

Add the mainnet safety guardrail as a Zod `.superRefine()` on ChainConfigSchema (or as a separate validation function called during config loading):
- If `network === 'Mainnet'` and `process.env.MAINNET !== 'true'`, add a Zod issue: `'Mainnet connection requires explicit MAINNET=true environment variable'`

Modify `src/config/schema.ts` to add the `chain` field:
- Import `ChainConfigSchema` from `'../chain/config.js'`
- Add `chain: ChainConfigSchema` to ConfigSchema (required, not optional -- chain config is mandatory for the facilitator)
- The Config type will automatically include chain settings

IMPORTANT: Since `chain` is now required, existing tests and config files will need the chain section. But the nested defaults mean an empty `chain: { blockfrost: { projectId: "..." }, facilitator: { seedPhrase: "..." } }` is the minimum. For tests, the config test file creates configs without chain -- add a note that existing config tests may need updates (the executor will handle this).

IMPORTANT: Blockfrost project IDs and seed phrases are secrets. The config schema must NOT have defaults for these -- they must be explicitly provided. The `projectId` field has `min(1)` validation, and `facilitator` has the `refine` check. Neither should appear in logs. Add a comment in the config noting these are sensitive fields.

Export `ChainConfigSchema` and `ChainConfig` type.
  </action>
  <verify>Run `pnpm typecheck` -- must pass. Run `pnpm test` -- existing config tests may need updates to include a `chain` section. If tests fail, update them to include minimal chain config `{ chain: { blockfrost: { projectId: 'test123' }, facilitator: { seedPhrase: 'test seed phrase words...' } } }`. All tests must pass.</verify>
  <done>Chain config schema validates network, Blockfrost settings, facilitator credentials, cache TTL, reservation settings, and Redis connection. Mainnet requires MAINNET=true env var. Config schema is extended. Existing tests pass with updated fixtures.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes with zero errors
2. `pnpm test` passes (config tests updated if needed)
3. `pnpm lint` passes
4. `src/chain/types.ts` exports all type definitions with bigint for lovelace
5. `src/chain/errors.ts` exports 5 domain errors with correct codes
6. `src/chain/config.ts` exports ChainConfigSchema with mainnet guardrail
7. `src/config/schema.ts` includes chain section
8. Importing from `@/errors/index.js` includes chain errors
</verification>

<success_criteria>
- Chain types use bigint for all ADA/lovelace values
- Domain errors follow existing @fastify/error pattern with CHAIN_* prefix
- Config schema validates Blockfrost project ID (required), network, tier, Redis, cache TTL, reservation TTL/cap
- Mainnet safety guardrail rejects mainnet without MAINNET=true
- All existing tests still pass
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-chain-provider/02-01-SUMMARY.md`
</output>
