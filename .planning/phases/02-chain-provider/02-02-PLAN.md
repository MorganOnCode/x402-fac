---
phase: 02-chain-provider
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/chain/blockfrost-client.ts
  - tests/unit/chain/blockfrost-client.test.ts
autonomous: true

must_haves:
  truths:
    - "Blockfrost calls retry with exponential backoff (500ms, 1000ms, 2000ms) on retryable errors"
    - "Rate limit exhaustion after all retries throws CHAIN_RATE_LIMITED error"
    - "Connection failures throw CHAIN_CONNECTION_ERROR"
    - "Blockfrost 404 on unused addresses returns empty array instead of throwing"
    - "API key is never included in error messages or log output"
  artifacts:
    - path: "src/chain/blockfrost-client.ts"
      provides: "BlockfrostClient class with retry-wrapped Blockfrost SDK methods"
      exports: ["BlockfrostClient", "createBlockfrostClient"]
    - path: "tests/unit/chain/blockfrost-client.test.ts"
      provides: "Unit tests for retry logic, error handling, 404 behavior"
      min_lines: 80
  key_links:
    - from: "src/chain/blockfrost-client.ts"
      to: "@blockfrost/blockfrost-js"
      via: "BlockFrostAPI instantiation with rateLimiter and retrySettings"
      pattern: "new BlockFrostAPI"
    - from: "src/chain/blockfrost-client.ts"
      to: "src/chain/errors.ts"
      via: "Throws ChainRateLimitedError and ChainConnectionError"
      pattern: "ChainRateLimitedError|ChainConnectionError"
---

<objective>
Build the Blockfrost API client with exponential backoff retry logic using TDD.

Purpose: All Cardano blockchain queries go through Blockfrost. The retry logic and error handling must be bulletproof -- this is the boundary between our app and the external API. TDD ensures the retry behavior (500ms base, doubling, max 3 retries) and error mapping (rate limit -> CHAIN_RATE_LIMITED, connection -> CHAIN_CONNECTION_ERROR, 404 -> empty array) are precisely correct.

Output: A tested BlockfrostClient class that wraps @blockfrost/blockfrost-js with custom retry logic and error translation.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-chain-provider/02-RESEARCH.md
@.planning/phases/02-chain-provider/02-01-SUMMARY.md

@src/chain/types.ts
@src/chain/errors.ts
@src/chain/config.ts
</context>

<feature>
  <name>BlockfrostClient with Exponential Backoff</name>
  <files>src/chain/blockfrost-client.ts, tests/unit/chain/blockfrost-client.test.ts</files>
  <behavior>
    The BlockfrostClient wraps `@blockfrost/blockfrost-js` BlockFrostAPI with custom retry logic per CONTEXT.md locked decisions.

    **Retry behavior (withRetry helper):**
    - Input: async function, label string, logger
    - On success: returns result immediately
    - On retryable error (429, 500, 502, 503, 504, network errors): waits and retries
    - Delay pattern: 500ms -> 1000ms -> 2000ms (500 * 2^attempt)
    - Max retries: 3 (so up to 4 total attempts: initial + 3 retries)
    - On rate limit exhaustion (all retries of 429): throws ChainRateLimitedError(label)
    - On non-retryable error: throws immediately without retry
    - Logger.warn called on each retry with attempt, delay, label

    **Error mapping:**
    - BlockfrostServerError with status_code 429 -> ChainRateLimitedError (after retries)
    - BlockfrostServerError with status_code 404 -> NOT an error, handled per-method (return empty array for UTXOs)
    - Network/timeout errors -> ChainConnectionError
    - Other errors -> re-thrown as-is

    **API key safety:**
    - BlockfrostClient constructor accepts projectId but never stores it as a public property
    - Error messages never include the projectId
    - Logger calls never log the projectId

    **Methods to wrap (minimum):**
    - `getLatestBlock()`: Returns latest block info (slot, time, hash)
    - `getEpochParameters()`: Returns protocol parameters
    - `getAddressUtxos(address)`: Returns UTxO[] (empty array on 404)

    Cases:
    - `withRetry(successFn)` -> returns result, no retry
    - `withRetry(failOnce_thenSucceed)` -> retries once, returns result
    - `withRetry(fail429_3times)` -> retries 3 times, throws ChainRateLimitedError
    - `withRetry(fail404)` -> throws immediately (not retryable at withRetry level)
    - `withRetry(failNetwork)` -> retries, then throws ChainConnectionError
    - `getAddressUtxos(unusedAddr)` -> catches 404, returns []
  </behavior>
  <implementation>
    Install `@blockfrost/blockfrost-js` (pnpm add @blockfrost/blockfrost-js).

    Create `src/chain/blockfrost-client.ts`:

    1. Export a `withRetry<T>` function (also export for testing): takes `fn: () => Promise<T>`, `label: string`, `log: FastifyBaseLogger`. Implements the retry loop with exponential backoff. Uses a `sleep(ms)` helper (also exported for test override). Check if error is retryable using `isRetryableError(error)` -- checks for 429, 500, 502, 503, 504 status codes on BlockfrostServerError, or network errors (ECONNREFUSED, ETIMEDOUT, etc.).

    2. Export `BlockfrostClient` class:
       - Constructor takes `{ projectId: string; network: CardanoNetwork; logger: FastifyBaseLogger }`
       - Creates internal `BlockFrostAPI` instance with `rateLimiter: true` and `requestTimeout: 20_000`
       - Methods: `getLatestBlock()`, `getEpochParameters()`, `getAddressUtxos(address: string)` -- all wrapped with `withRetry`
       - `getAddressUtxos` catches BlockfrostServerError with status_code 404 and returns empty array

    3. Export `createBlockfrostClient(config: ChainConfig, logger: FastifyBaseLogger): BlockfrostClient` factory function.

    For tests, mock `@blockfrost/blockfrost-js` using `vi.mock()`. Create a mock BlockFrostAPI that can be configured to fail/succeed per test. Test the `withRetry` function directly and the `getAddressUtxos` 404 handling.

    IMPORTANT: Do NOT use real Blockfrost calls in tests. Mock everything.
    IMPORTANT: Use `vi.useFakeTimers()` to test retry delays without actually waiting.
  </implementation>
</feature>

<verification>
1. `pnpm test tests/unit/chain/blockfrost-client.test.ts` -- all tests pass
2. `pnpm typecheck` -- zero errors
3. `pnpm lint` -- passes
4. Tests cover: immediate success, retry-then-success, max retries exhaustion, 404 handling, non-retryable error passthrough
</verification>

<success_criteria>
- withRetry retries exactly 3 times with 500ms/1000ms/2000ms delays
- Rate limit exhaustion throws ChainRateLimitedError with the operation label
- 404 on address UTXOs returns empty array
- API key is never in error messages
- All tests pass without real Blockfrost calls
</success_criteria>

<output>
After completion, create `.planning/phases/02-chain-provider/02-02-SUMMARY.md`
</output>
