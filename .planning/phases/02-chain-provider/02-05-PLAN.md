---
phase: 02-chain-provider
plan: 05
type: execute
wave: 4
depends_on: ["02-02", "02-03", "02-04"]
files_modified:
  - src/chain/lucid-provider.ts
  - src/chain/provider.ts
  - src/chain/index.ts
  - src/server.ts
  - tests/unit/chain/provider.test.ts
autonomous: true

must_haves:
  truths:
    - "Lucid Evolution initializes with correct network and Blockfrost provider"
    - "ChainProvider queries UTXOs with cache-first strategy (cache -> Blockfrost)"
    - "ChainProvider reserves UTXOs before returning them for transaction building"
    - "ChainProvider provides current slot for validity intervals"
    - "ChainProvider provides ADA balance for an address"
    - "ChainProvider calculates min UTXO ADA for outputs using protocol parameters"
    - "Server startup initializes chain layer and decorates Fastify with Redis"
    - "Server shutdown disconnects Redis and cleans up chain resources"
  artifacts:
    - path: "src/chain/lucid-provider.ts"
      provides: "Lucid Evolution initialization with Blockfrost and wallet setup"
      exports: ["createLucidInstance", "LucidInstance"]
    - path: "src/chain/provider.ts"
      provides: "ChainProvider orchestrator combining cache, reservation, Blockfrost, and Lucid"
      exports: ["ChainProvider", "createChainProvider"]
    - path: "src/chain/index.ts"
      provides: "Barrel export for chain module"
      exports: ["ChainProvider", "createChainProvider", "UtxoCache", "UtxoReservation", "BlockfrostClient"]
    - path: "src/server.ts"
      provides: "Server with chain layer initialization"
      contains: "createChainProvider"
    - path: "tests/unit/chain/provider.test.ts"
      provides: "Unit tests for ChainProvider orchestration logic"
      min_lines: 60
  key_links:
    - from: "src/chain/provider.ts"
      to: "src/chain/utxo-cache.ts"
      via: "Checks cache before querying Blockfrost"
      pattern: "cache\\.get|cache\\.set"
    - from: "src/chain/provider.ts"
      to: "src/chain/utxo-reservation.ts"
      via: "Reserves UTXOs before returning for tx building"
      pattern: "reservation\\.reserve|reservation\\.release"
    - from: "src/chain/provider.ts"
      to: "src/chain/blockfrost-client.ts"
      via: "Queries Blockfrost on cache miss"
      pattern: "blockfrost\\.getAddressUtxos|blockfrost\\.getLatestBlock"
    - from: "src/chain/provider.ts"
      to: "src/chain/lucid-provider.ts"
      via: "Uses Lucid instance for transaction building primitives"
      pattern: "lucid"
    - from: "src/server.ts"
      to: "src/chain/provider.ts"
      via: "Creates ChainProvider at startup"
      pattern: "createChainProvider"
---

<objective>
Create the Lucid Evolution provider, the ChainProvider orchestrator that ties all chain components together, and wire the chain layer into the Fastify server lifecycle.

Purpose: This is the integration plan that connects all chain components (Blockfrost client, UTXO cache, reservation system) into a single ChainProvider interface. The ChainProvider is what downstream phases (verification, settlement) will use to interact with Cardano. It also wires Redis into the server for health checks and ensures clean shutdown.

Output: A fully integrated chain layer accessible through ChainProvider, initialized at server startup, with Lucid Evolution ready for transaction building in future phases.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-chain-provider/02-RESEARCH.md
@.planning/phases/02-chain-provider/02-02-SUMMARY.md
@.planning/phases/02-chain-provider/02-03-SUMMARY.md
@.planning/phases/02-chain-provider/02-04-SUMMARY.md

@src/chain/types.ts
@src/chain/errors.ts
@src/chain/config.ts
@src/chain/blockfrost-client.ts
@src/chain/utxo-cache.ts
@src/chain/utxo-reservation.ts
@src/chain/redis-client.ts
@src/server.ts
@src/routes/health.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Lucid provider and ChainProvider orchestrator</name>
  <files>src/chain/lucid-provider.ts, src/chain/provider.ts, src/chain/index.ts, tests/unit/chain/provider.test.ts</files>
  <action>
Install Lucid Evolution: `pnpm add @lucid-evolution/lucid`

**Lucid Provider (`src/chain/lucid-provider.ts`):**

Export `LucidInstance` as a type alias for the Lucid Evolution return type (use `Awaited<ReturnType<typeof Lucid>>` or the explicit `LucidEvolution` type from the package).

Export `createLucidInstance(config: ChainConfig, logger: FastifyBaseLogger): Promise<LucidInstance>`:
- Resolves Blockfrost URL using `resolveBlockfrostUrl(config)` from config.ts
- Creates `new Blockfrost(url, config.blockfrost.projectId)` provider
- Calls `await Lucid(blockfrostProvider, config.network)` to create the instance
- If `config.facilitator.seedPhrase` is set, calls `lucid.selectWallet.fromSeed(seedPhrase)`
- If `config.facilitator.privateKey` is set, calls `lucid.selectWallet.fromPrivateKey(privateKey)`
- Logs at info level: `'Lucid Evolution initialized'` with `{ network: config.network }` (NO API key in logs)
- Returns the Lucid instance

Import from `@lucid-evolution/lucid`: `Lucid`, `Blockfrost` (and any type imports needed).

Handle potential Effect library issues: if Lucid returns Effect types instead of Promises, use `Effect.runPromise()` to convert. Check the actual return type during implementation. The research notes this is a potential issue.

**ChainProvider (`src/chain/provider.ts`):**

Export `ChainProvider` class:

Constructor takes:
```typescript
{
  blockfrost: BlockfrostClient;
  cache: UtxoCache;
  reservation: UtxoReservation;
  lucid: LucidInstance;
  config: ChainConfig;
  logger: FastifyBaseLogger;
}
```

Methods:

`async getUtxos(address: string): Promise<CachedUtxo[]>`
- Check cache first: `cache.get(address)`
- On cache hit: return cached UTXOs
- On cache miss: query Blockfrost via `blockfrost.getAddressUtxos(address)`
- Map Blockfrost response to `CachedUtxo[]` (extract txHash, outputIndex, address, lovelace as bigint, assets as Record<string, bigint>)
- Write to cache: `cache.set(address, utxos)`
- Return UTXOs

`async getAvailableUtxos(address: string, requestId: string): Promise<CachedUtxo[]>`
- Get all UTXOs for address via `getUtxos(address)`
- Filter out reserved ones: `!reservation.isReserved(utxoRefToString({ txHash, outputIndex }))`
- Return only unreserved UTXOs

`reserveUtxo(utxoRef: string, requestId: string): boolean`
- Delegates to `reservation.reserve(utxoRef, requestId)`

`releaseUtxo(utxoRef: string): void`
- Delegates to `reservation.release(utxoRef)`

`releaseAll(requestId: string): void`
- Delegates to `reservation.releaseAll(requestId)`

`async getCurrentSlot(): Promise<number>`
- Calls `blockfrost.getLatestBlock()`
- Returns block.slot

`async getBalance(address: string): Promise<bigint>`
- Get UTXOs via `getUtxos(address)`
- Sum all `utxo.lovelace` values
- Return total as bigint

`invalidateCache(address: string): void`
- Calls `cache.invalidate(address)`

`getLucid(): LucidInstance`
- Returns the Lucid instance (for downstream transaction building)

`async getMinUtxoLovelace(): Promise<bigint>`
- Queries protocol parameters via `blockfrost.getEpochParameters()`
- Extracts `coins_per_utxo_byte` (string, parse to bigint) -- currently 4310 lovelace/byte on Cardano
- Calculates minimum UTXO ADA for a basic output (no tokens, no datum): approximately `(160 + 2) * coinsPerUtxoByte` = ~698,000 lovelace. For token outputs the size increases -- use formula: `max(lovelacePerByte * (utxoEntrySizeWithoutVal + 160 + 28 * numAssets), 1_000_000n)` where 1 ADA is the practical minimum
- Cache the protocol parameters for 5 minutes (they change once per epoch, ~5 days) -- use a simple in-memory cache with timestamp, no Redis needed
- This is the foundation that Phase 5 (Stablecoins) builds on for multi-asset min UTXO
- NOTE: Lucid's `.complete()` handles min UTXO automatically during transaction building, but this method is needed for pre-validation (checking if a payment amount is sufficient before building a tx) and for returning requirements to callers

`getReservationStatus(): { active: number; max: number }`
- Returns `{ active: reservation.getActiveCount(), max: config.reservation.maxConcurrent }`

Export `createChainProvider` factory:
```typescript
async function createChainProvider(
  config: ChainConfig,
  redis: Redis,
  logger: FastifyBaseLogger,
): Promise<ChainProvider>
```
- Creates BlockfrostClient via `createBlockfrostClient(config, logger)`
- Creates UtxoCache via `createUtxoCache(redis, config, logger)`
- Creates UtxoReservation via `createUtxoReservation(redis, config, logger)`
- Loads reservations from Redis: `reservation.loadFromRedis()`
- Creates Lucid instance via `createLucidInstance(config, logger)`
- Returns new ChainProvider with all components

**Barrel export (`src/chain/index.ts`):**

Re-export key items from all chain modules:
- From types.ts: all types
- From errors.ts: all errors
- From config.ts: ChainConfigSchema, ChainConfig, resolveBlockfrostUrl
- From provider.ts: ChainProvider, createChainProvider
- From blockfrost-client.ts: BlockfrostClient
- From utxo-cache.ts: UtxoCache
- From utxo-reservation.ts: UtxoReservation
- From redis-client.ts: createRedisClient, disconnectRedis
- From lucid-provider.ts: createLucidInstance, LucidInstance

Use `export type { ... }` for type-only exports (ESM requirement).

**Tests (`tests/unit/chain/provider.test.ts`):**

Mock all dependencies (BlockfrostClient, UtxoCache, UtxoReservation, Lucid). Test:
1. `getUtxos()` returns from cache on hit (no Blockfrost call)
2. `getUtxos()` queries Blockfrost on cache miss and caches result
3. `getAvailableUtxos()` filters out reserved UTXOs
4. `getBalance()` sums lovelace across UTXOs correctly with BigInt
5. `reserveUtxo()` delegates to reservation system
6. `invalidateCache()` delegates to cache
7. `getMinUtxoLovelace()` returns a bigint value based on protocol parameters (mock Blockfrost getEpochParameters to return coins_per_utxo_byte: "4310")

IMPORTANT: Mock `@lucid-evolution/lucid` in tests. Do NOT make real blockchain calls. The Lucid instance can be a minimal mock that satisfies the type.
  </action>
  <verify>Run `pnpm test tests/unit/chain/provider.test.ts` -- all tests pass. Run `pnpm typecheck` -- zero errors. Run `pnpm lint` -- passes.</verify>
  <done>ChainProvider orchestrates cache-first UTXO queries, reservation management, slot queries, and balance checks. Lucid Evolution is initialized with correct network. All tests pass with mocked dependencies. Barrel exports provide clean public API.</done>
</task>

<task type="auto">
  <name>Task 2: Wire chain layer into server lifecycle</name>
  <files>src/server.ts</files>
  <action>
Update `src/server.ts` to initialize the chain layer during server startup:

1. Import `createRedisClient`, `disconnectRedis`, `createChainProvider` from `'./chain/index.js'`

2. In `createServer()`, after existing plugin registration and before route registration:
   - Create Redis client: `const redis = createRedisClient(config.chain.redis, server.log)`
   - Connect Redis: `await redis.connect()`
   - Decorate Fastify with redis: `server.decorate('redis', redis)` (this enables the health check from Plan 03)
   - Create ChainProvider: `const chainProvider = await createChainProvider(config.chain, redis, server.log)`
   - Decorate Fastify with chainProvider: `server.decorate('chainProvider', chainProvider)`

3. Add a shutdown hook using `server.addHook('onClose', async () => { ... })`:
   - Disconnect Redis: `await disconnectRedis(redis)`
   - Log: `server.log.info('Chain layer shutdown complete')`

4. Update `src/types/index.ts` (Fastify type augmentation) to include:
   ```typescript
   import type { Redis } from 'ioredis';
   import type { ChainProvider } from './chain/provider.js';

   declare module 'fastify' {
     interface FastifyInstance {
       config: Config;
       redis: Redis;
       chainProvider: ChainProvider;
     }
   }
   ```

IMPORTANT: The server must handle the case where chain initialization fails gracefully. Wrap chain init in try/catch -- if it fails, log the error and re-throw (let the server fail to start rather than running without chain support, since the facilitator is useless without it).

IMPORTANT: Do NOT log the Blockfrost project ID or facilitator seed phrase during initialization. Log only: network name, Blockfrost tier, Redis host:port.

Update any existing server tests that may break due to the new required `chain` config section. Tests that create servers will need the chain config in their test fixtures. For tests that don't need chain functionality, consider mocking the chain initialization or providing a minimal valid config.
  </action>
  <verify>Run `pnpm test` -- all tests pass. Run `pnpm typecheck` -- zero errors. Run `pnpm build` -- builds successfully. Verify that `docker-compose up -d redis` then `pnpm dev` starts the server (requires valid Blockfrost config in config.json -- if no API key available, verify the error message is clear about what's missing and does NOT expose any secrets).</verify>
  <done>Server initializes Redis connection, creates ChainProvider, decorates Fastify instance. Shutdown hook disconnects Redis. Health endpoint can now report real Redis status. All tests pass. Build succeeds.</done>
</task>

</tasks>

<verification>
1. `pnpm test` -- all tests pass (unit + integration)
2. `pnpm typecheck` -- zero errors
3. `pnpm lint` -- passes
4. `pnpm build` -- succeeds
5. ChainProvider is accessible as `fastify.chainProvider` in route handlers
6. Redis is accessible as `fastify.redis` for health checks
7. Server logs show chain initialization at startup (network, tier -- no secrets)
8. Server shutdown cleanly disconnects Redis
</verification>

<success_criteria>
- Lucid Evolution initializes with Blockfrost provider for configured network
- ChainProvider provides cache-first UTXO queries, reservation, slot queries, balance checks, min UTXO calculation
- Server startup creates and decorates chain layer
- Server shutdown cleans up Redis connection
- No secrets (API keys, seed phrases) appear in logs
- All existing and new tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-chain-provider/02-05-SUMMARY.md`
</output>
