---
phase: 02-chain-provider
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/chain/redis-client.ts
  - src/chain/utxo-cache.ts
  - src/routes/health.ts
  - tests/unit/chain/utxo-cache.test.ts
autonomous: true

must_haves:
  truths:
    - "UTXO cache checks in-memory L1 first, then Redis L2, returns null on miss"
    - "Cache writes go to both L1 and L2 simultaneously"
    - "Cache invalidation removes from both layers"
    - "BigInt values survive serialization/deserialization through Redis"
    - "Health endpoint reports real Redis connectivity status"
    - "Cache TTL defaults to 60 seconds (configurable)"
  artifacts:
    - path: "src/chain/redis-client.ts"
      provides: "Redis connection factory with lazy connect and retry"
      exports: ["createRedisClient"]
    - path: "src/chain/utxo-cache.ts"
      provides: "Two-layer UTXO cache (in-memory Map + Redis)"
      exports: ["UtxoCache", "createUtxoCache"]
    - path: "src/routes/health.ts"
      provides: "Health endpoint with real Redis status check"
      contains: "redis.ping"
    - path: "tests/unit/chain/utxo-cache.test.ts"
      provides: "Unit tests for cache read/write/invalidate and BigInt serialization"
      min_lines: 60
  key_links:
    - from: "src/chain/utxo-cache.ts"
      to: "src/chain/redis-client.ts"
      via: "Redis instance passed to UtxoCache constructor"
      pattern: "Redis"
    - from: "src/chain/utxo-cache.ts"
      to: "src/chain/types.ts"
      via: "Uses CachedUtxo type for stored values"
      pattern: "CachedUtxo"
    - from: "src/routes/health.ts"
      to: "src/chain/redis-client.ts"
      via: "Pings Redis to check connectivity"
      pattern: "redis.*ping|ping.*redis"
---

<objective>
Build the Redis client, two-layer UTXO cache, and wire real Redis health checking into the existing health endpoint.

Purpose: The UTXO cache is critical for minimizing Blockfrost API calls (free tier: 50K/day). The two-layer design (in-memory Map for speed + Redis for persistence) ensures fast reads during hot path while surviving restarts. The health endpoint currently returns a placeholder for Redis -- this plan replaces it with a real ping check.

Output: A working UtxoCache class with L1/L2 read-through, BigInt-safe serialization, TTL-based expiry, and a health endpoint that reports actual Redis status.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-chain-provider/02-RESEARCH.md
@.planning/phases/02-chain-provider/02-01-SUMMARY.md

@src/chain/types.ts
@src/chain/config.ts
@src/routes/health.ts
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Redis client factory and UTXO cache</name>
  <files>src/chain/redis-client.ts, src/chain/utxo-cache.ts, tests/unit/chain/utxo-cache.test.ts</files>
  <action>
Install ioredis: `pnpm add ioredis`

**Redis client (`src/chain/redis-client.ts`):**

Create and export a `createRedisClient(config: ChainConfig['redis'], logger: FastifyBaseLogger): Redis` factory:
- Uses `ioredis` `Redis` class
- Sets `lazyConnect: true` (caller explicitly calls `.connect()`)
- Sets `maxRetriesPerRequest: 3`
- Sets `retryStrategy(times)`: returns `Math.min(times * 200, 2000)` (200ms, 400ms, 600ms... capped at 2s)
- Logs connection events: `connect`, `error`, `close` using the provided logger
- Does NOT log sensitive connection details (no password, no full URL)
- Returns the Redis instance

Also export a `disconnectRedis(redis: Redis): Promise<void>` helper for clean shutdown.

**BigInt serialization helpers (in `src/chain/utxo-cache.ts` or a shared util):**

```typescript
export function serializeWithBigInt(data: unknown): string {
  return JSON.stringify(data, (_key, value) =>
    typeof value === 'bigint' ? value.toString() + 'n' : value
  );
}

export function deserializeWithBigInt(json: string): unknown {
  return JSON.parse(json, (_key, value) =>
    typeof value === 'string' && /^\d+n$/.test(value)
      ? BigInt(value.slice(0, -1))
      : value
  );
}
```

**UTXO Cache (`src/chain/utxo-cache.ts`):**

Create and export `UtxoCache` class:

Constructor takes `{ redis: Redis; ttlMs: number; logger: FastifyBaseLogger }` where `ttlMs` defaults to `60_000` (60 seconds from config).

Properties:
- `private l1: Map<string, { utxos: CachedUtxo[]; expiresAt: number }>` - in-memory cache
- `private redis: Redis` - L2 backing store
- `private ttlMs: number`
- `private logger: FastifyBaseLogger`

Methods:
- `async get(address: string): Promise<CachedUtxo[] | null>` - Check L1 first (if entry exists and not expired). If L1 miss, check L2 (Redis key `utxo:{address}`). If L2 hit, deserialize with BigInt reviver, warm L1, return. If both miss, return null.
- `async set(address: string, utxos: CachedUtxo[]): Promise<void>` - Write to L1 (with expiresAt = Date.now() + ttlMs) AND L2 (Redis SET with EX ttl in seconds). Use BigInt-safe serializer for Redis.
- `invalidate(address: string): void` - Delete from L1. Fire-and-forget delete from L2 (`redis.del().catch(() => {})`). Log at debug level.
- `invalidateAll(): void` - Clear L1 Map. Fire-and-forget pattern scan and delete from L2 (or just clear L1 and let L2 expire naturally -- simpler).

Export `createUtxoCache(redis: Redis, config: ChainConfig, logger: FastifyBaseLogger): UtxoCache` factory.

**Tests (`tests/unit/chain/utxo-cache.test.ts`):**

Mock ioredis using `vi.mock('ioredis')`. Test:
1. `get()` returns null on empty cache (both layers miss)
2. `set()` then `get()` returns cached data from L1 (no Redis call for second get)
3. BigInt values survive `set()` -> `get()` cycle (e.g., `lovelace: 5_000_000n` comes back as bigint, not number or string)
4. `invalidate()` causes next `get()` to return null
5. Expired L1 entry falls through to L2
6. `serializeWithBigInt` / `deserializeWithBigInt` roundtrip correctly for objects containing bigint values
  </action>
  <verify>Run `pnpm test tests/unit/chain/utxo-cache.test.ts` -- all tests pass. Run `pnpm typecheck` -- zero errors.</verify>
  <done>UtxoCache provides two-layer caching with BigInt-safe serialization. L1 is in-memory Map, L2 is Redis. Cache misses return null. Invalidation clears both layers. All 6+ test cases pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire real Redis health check into health endpoint</name>
  <files>src/routes/health.ts, src/server.ts</files>
  <action>
Update `src/routes/health.ts` to use a real Redis ping instead of the placeholder.

The health route needs access to a Redis client. Two approaches:
1. Decorate the Fastify instance with the Redis client (preferred -- follows Fastify patterns)
2. Pass Redis client through plugin options

**Approach:** Add an optional `redis` property to the Fastify instance decoration. The health route checks if `fastify.redis` exists -- if yes, pings it; if no, returns the current placeholder behavior. This keeps backward compatibility and allows the health route to work even before Redis is configured.

Update the `checkRedis()` function in health.ts:
```typescript
async function checkRedis(redis?: Redis): Promise<DependencyStatus> {
  if (!redis) {
    return { status: 'up', latency: 0 }; // Not configured yet
  }
  const start = Date.now();
  try {
    await redis.ping();
    return { status: 'up', latency: Date.now() - start };
  } catch (err) {
    return {
      status: 'down',
      latency: Date.now() - start,
      error: err instanceof Error ? err.message : 'Unknown error',
    };
  }
}
```

Update the health route handler to pass `fastify.redis` to `checkRedis()`.

Update `src/types/index.ts` (or wherever Fastify type augmentation lives) to add the optional `redis` property to the Fastify instance type declaration.

Note: The actual Redis instance will be decorated onto the Fastify server in Plan 05 (ChainProvider orchestrator) when everything is wired together. For now, the health route just supports the optional Redis parameter.

Do NOT change `src/server.ts` in this task beyond what's needed. The Redis decoration will happen in Plan 05.

Update the existing health integration test if it breaks due to the function signature change.
  </action>
  <verify>Run `pnpm test` -- all tests pass (including existing health tests). Run `pnpm typecheck` -- zero errors. The health endpoint still returns 200 with `redis: { status: 'up' }` when no Redis client is decorated (backward compatible).</verify>
  <done>Health endpoint supports real Redis health checking via optional fastify.redis decoration. Existing behavior preserved when Redis is not configured. Health integration tests pass.</done>
</task>

</tasks>

<verification>
1. `pnpm test` -- all tests pass
2. `pnpm typecheck` -- zero errors
3. `pnpm lint` -- passes
4. BigInt roundtrip test confirms `5_000_000n` survives cache serialization
5. Health endpoint returns real latency when Redis is available
6. ioredis is in package.json dependencies
</verification>

<success_criteria>
- UtxoCache.get() checks L1 then L2, returns null on miss
- UtxoCache.set() writes both layers with TTL
- BigInt values survive Redis serialization roundtrip
- Health endpoint reports real Redis status when client is available
- Backward compatible when Redis not configured
</success_criteria>

<output>
After completion, create `.planning/phases/02-chain-provider/02-03-SUMMARY.md`
</output>
