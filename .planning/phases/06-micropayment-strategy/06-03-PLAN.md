---
phase: 06-micropayment-strategy
plan: 03
type: execute
wave: 3
depends_on: [06-01, 06-02]
files_modified:
  - src/credits/strategy.ts
  - src/settle/types.ts
  - src/settle/settle-payment.ts
  - src/routes/settle.ts
  - tests/unit/credits/strategy.test.ts
  - tests/integration/settle-route.test.ts
autonomous: true

must_haves:
  truths:
    - "selectStrategy() routes payments: above min UTXO threshold = direct_l1, below with sufficient credits = credit_deduction"
    - "SettleRequestSchema accepts optional paymentStrategy and payerAddress fields for credit deduction"
    - "SettleResult includes strategy field indicating which path was used"
    - "/settle route supports credit deduction: no CBOR required, deducts from credit balance"
    - "Credit deductions bypass L1 entirely: no verify, no submit, no poll"
    - "Credit deductions require credits enabled, valid payer address, and sufficient balance"
    - "Direct L1 path is completely unchanged when no paymentStrategy is specified (backward compatible)"
    - "selectStrategy returns 'insufficient_credits' error when below threshold and no/insufficient credits"
  artifacts:
    - path: "src/credits/strategy.ts"
      provides: "selectStrategy(), buildPaymentStrategies(), PaymentStrategy type, PaymentStrategiesInfo"
      exports: ["selectStrategy", "buildPaymentStrategies", "PaymentStrategy", "StrategyDecision", "PaymentStrategiesInfo"]
    - path: "src/settle/types.ts"
      provides: "Extended SettleRequestSchema and SettleResult with strategy fields"
      contains: "paymentStrategy"
    - path: "src/settle/settle-payment.ts"
      provides: "settleWithCredits() function for credit deduction path"
      exports: ["settleWithCredits"]
    - path: "src/routes/settle.ts"
      provides: "Updated /settle route with dual-path: L1 or credit deduction"
    - path: "tests/unit/credits/strategy.test.ts"
      provides: "Unit tests for strategy selection logic"
  key_links:
    - from: "src/credits/strategy.ts"
      to: "src/routes/settle.ts"
      via: "Route handler calls selectStrategy to determine settlement path"
      pattern: "selectStrategy"
    - from: "src/settle/settle-payment.ts"
      to: "src/credits/credit-ledger.ts"
      via: "settleWithCredits calls ledger.debit for credit deduction"
      pattern: "CreditLedger.debit"
---

<objective>
Add payment strategy routing to /settle so that micropayments below the min UTXO threshold can be settled via credit deduction instead of L1 transactions.

Purpose: This is the core micropayment innovation. Payments above ~1 ADA use the existing L1 settlement flow. Payments below the threshold use the credit deduction path (off-chain, instant, zero L1 cost). The strategy router makes this decision transparent to clients.

Output: `src/credits/strategy.ts` router, extended settle types, `settleWithCredits()` function, updated /settle route with dual-path support, tests for both paths.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-micropayment-strategy/06-RESEARCH.md
@.planning/phases/06-micropayment-strategy/06-01-PLAN.md
@.planning/phases/06-micropayment-strategy/06-02-PLAN.md
@src/settle/settle-payment.ts
@src/settle/types.ts
@src/routes/settle.ts
@src/credits/credit-ledger.ts
@src/credits/types.ts
@src/credits/strategy.ts
@src/chain/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment strategy router</name>
  <files>src/credits/strategy.ts, tests/unit/credits/strategy.test.ts</files>
  <action>
Create `src/credits/strategy.ts` with the strategy selection logic AND payment strategies info builder. Both are pure functions that belong together.

```typescript
/** Available payment settlement strategies. */
export type PaymentStrategy = 'direct_l1' | 'credit_deduction';

/** Result of strategy selection. */
export interface StrategyDecision {
  /** Which strategy to use */
  strategy: PaymentStrategy;
  /** Why this strategy was selected */
  reason: string;
}

/**
 * Select the payment strategy based on amount, credit balance, and threshold.
 *
 * Decision matrix:
 * - Client explicitly requests 'direct_l1' -> direct_l1 (regardless of amount)
 * - Client explicitly requests 'credit_deduction' -> credit_deduction (if balance sufficient)
 * - Amount >= threshold -> direct_l1 (standard L1 settlement)
 * - Amount < threshold AND credits enabled AND sufficient balance -> credit_deduction
 * - Amount < threshold AND (credits disabled OR insufficient) -> returns null (caller handles error)
 *
 * @param amountLovelace - Payment amount in lovelace
 * @param thresholdLovelace - Min UTXO threshold (from protocol params, ~1 ADA)
 * @param creditBalance - Current credit balance (null = no account or credits disabled)
 * @param requestedStrategy - Client's explicitly requested strategy (optional)
 */
export function selectStrategy(
  amountLovelace: bigint,
  thresholdLovelace: bigint,
  creditBalance: bigint | null,
  requestedStrategy?: PaymentStrategy,
): StrategyDecision | null {
  // Client explicitly requests a strategy
  if (requestedStrategy === 'direct_l1') {
    return { strategy: 'direct_l1', reason: 'client_requested' };
  }

  if (requestedStrategy === 'credit_deduction') {
    if (creditBalance !== null && creditBalance >= amountLovelace) {
      return { strategy: 'credit_deduction', reason: 'client_requested' };
    }
    return null; // Insufficient credits for requested strategy
  }

  // Auto-select based on amount vs threshold
  if (amountLovelace >= thresholdLovelace) {
    return { strategy: 'direct_l1', reason: 'above_threshold' };
  }

  // Below threshold -- try credit deduction
  if (creditBalance !== null && creditBalance >= amountLovelace) {
    return { strategy: 'credit_deduction', reason: 'below_threshold_sufficient_credits' };
  }

  // Below threshold, no/insufficient credits
  return null;
}

/**
 * Payment strategy availability info for 402 response enrichment.
 */
export interface PaymentStrategiesInfo {
  direct_l1: {
    available: boolean;
    reason?: string;
    minAmount: string;
  };
  credit_deduction: {
    available: boolean;
    balance: string | null;
    sufficient: boolean;
    reason?: string;
  };
  credit_topup: {
    available: boolean;
    endpoint: string;
    minTopup: string;
  };
}

/**
 * Build payment strategy info for a given payment context.
 * Used to enrich settlement failure responses and balance queries.
 */
export function buildPaymentStrategies(
  amountLovelace: bigint,
  minUtxoLovelace: bigint,
  creditBalance: bigint | null,
  creditsEnabled: boolean,
  minTopupLovelace: bigint,
): PaymentStrategiesInfo {
  const l1Available = amountLovelace >= minUtxoLovelace;

  return {
    direct_l1: {
      available: l1Available,
      ...(l1Available ? {} : { reason: 'amount_below_min_utxo' }),
      minAmount: minUtxoLovelace.toString(),
    },
    credit_deduction: {
      available: creditsEnabled && creditBalance !== null && creditBalance >= amountLovelace,
      balance: creditBalance !== null ? creditBalance.toString() : null,
      sufficient: creditBalance !== null && creditBalance >= amountLovelace,
      ...(!creditsEnabled
        ? { reason: 'credits_disabled' }
        : creditBalance === null
          ? { reason: 'no_account' }
          : creditBalance < amountLovelace
            ? { reason: 'insufficient_balance' }
            : {}),
    },
    credit_topup: {
      available: creditsEnabled,
      endpoint: '/credits/topup',
      minTopup: minTopupLovelace.toString(),
    },
  };
}
```

**Tests** (`tests/unit/credits/strategy.test.ts`):

Test cases:
1. Amount above threshold -> direct_l1, reason: 'above_threshold'
2. Amount at threshold -> direct_l1, reason: 'above_threshold'
3. Amount below threshold, sufficient credits -> credit_deduction, reason: 'below_threshold_sufficient_credits'
4. Amount below threshold, exact credit match -> credit_deduction
5. Amount below threshold, insufficient credits -> returns null
6. Amount below threshold, no credit account (null) -> returns null
7. Client requests 'direct_l1' explicitly -> direct_l1 even if below threshold
8. Client requests 'credit_deduction' with sufficient credits -> credit_deduction
9. Client requests 'credit_deduction' with insufficient credits -> returns null
10. Amount = 0n -> credit_deduction (edge case, below any threshold)
11. Threshold = 0n -> all amounts are above threshold (direct_l1)

**buildPaymentStrategies tests:**
12. Amount above min UTXO, no credits: direct_l1 available, credit_deduction unavailable (no_account)
13. Amount above min UTXO, sufficient credits: both direct_l1 and credit_deduction available
14. Amount below min UTXO, sufficient credits: direct_l1 unavailable, credit_deduction available
15. Amount below min UTXO, insufficient credits: both unavailable
16. Credits disabled: credit_deduction reason is 'credits_disabled', credit_topup.available is false
17. credit_topup.endpoint is always '/credits/topup'
18. Balance exactly matching amount: credit_deduction.sufficient = true
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test -- tests/unit/credits/strategy.test.ts` -- all tests pass. Verify selectStrategy is a pure function (no side effects, no async).
  </verify>
  <done>Payment strategy router implemented as a pure function. 11 unit tests cover threshold-based routing, explicit client requests, edge cases, and null returns for insufficient credits.</done>
</task>

<task type="auto">
  <name>Task 2: Extend settle types for strategy support</name>
  <files>src/settle/types.ts</files>
  <action>
Extend the settle types to support the dual-path settlement.

**1. Extend SettleRequestSchema:**

Add two optional fields to `SettleRequestSchema`:

```typescript
export const SettleRequestSchema = z.object({
  /** Base64-encoded signed CBOR transaction (required for L1, omitted for credit deduction) */
  transaction: z.string().min(1).optional(),
  /** Payment requirements */
  paymentRequirements: PaymentRequirementsSchema,
  /** Explicitly requested payment strategy (optional -- auto-selects if omitted) */
  paymentStrategy: z.enum(['direct_l1', 'credit_deduction']).optional(),
  /** Payer address for credit deduction (required when strategy is credit_deduction) */
  payerAddress: z.string().min(1).optional(),
});
```

IMPORTANT: `transaction` changes from `z.string().min(1)` to `z.string().min(1).optional()`. For credit deductions, no CBOR is needed. The route handler validates that `transaction` is present when using direct_l1.

**2. Extend SettleResult:**

Add a `strategy` field:

```typescript
export interface SettleResult {
  /** Whether settlement succeeded */
  success: boolean;
  /** Transaction hash (present on L1 success and timeout) */
  transaction?: string;
  /** CAIP-2 chain ID (present on L1 success) */
  network?: string;
  /** Snake_case failure reason */
  reason?: string;
  /** Which payment strategy was used */
  strategy?: 'direct_l1' | 'credit_deduction';
  /** Remaining credit balance after deduction (lovelace as string) */
  remainingBalance?: string;
  /** Payment strategy availability info (present on insufficient_credits failures) */
  paymentStrategies?: Record<string, unknown>;
}
```

**3. Extend SettleResponseSchema** to document the new fields:

```typescript
export const SettleResponseSchema = z.object({
  success: z.boolean(),
  transaction: z.string().optional(),
  network: z.string().optional(),
  reason: z.string().optional(),
  strategy: z.enum(['direct_l1', 'credit_deduction']).optional(),
  remainingBalance: z.string().optional(),
});
```

NOTE: These are all additive changes. Existing clients that send `{ transaction, paymentRequirements }` continue to work exactly as before. The new fields are all optional.
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test` -- all existing tests pass (settle route tests use transaction field which is still accepted). Verify SettleResult now includes optional strategy and remainingBalance fields.
  </verify>
  <done>Settle types extended: SettleRequestSchema accepts optional paymentStrategy and payerAddress. SettleResult includes strategy and remainingBalance. All changes are additive and backward compatible.</done>
</task>

<task type="auto">
  <name>Task 3: Create settleWithCredits function</name>
  <files>src/settle/settle-payment.ts</files>
  <action>
Add a `settleWithCredits()` function to `src/settle/settle-payment.ts` for the credit deduction path.

This function is separate from `settlePayment()` to keep the L1 flow untouched. The route handler decides which function to call based on the strategy.

```typescript
import type { CreditLedger } from '../credits/credit-ledger.js';

/**
 * Settle a payment by deducting from a credit account.
 *
 * This is the off-chain path -- no L1 transaction is involved.
 * The facilitator deducts from the payer's credit balance and
 * returns success. The resource provider trusts the facilitator's
 * confirmation.
 *
 * @param payerAddress - Cardano bech32 address of the credit account
 * @param amountLovelace - Amount to deduct in lovelace
 * @param network - CAIP-2 chain ID
 * @param ledger - CreditLedger for balance deduction
 * @param logger - Fastify logger
 * @returns SettleResult with strategy='credit_deduction'
 */
export async function settleWithCredits(
  payerAddress: string,
  amountLovelace: bigint,
  network: string,
  ledger: CreditLedger,
  logger: FastifyBaseLogger,
): Promise<SettleResult> {
  try {
    const account = await ledger.debit(
      payerAddress,
      amountLovelace,
      `credit-settle:${Date.now()}`, // reference for audit trail
    );

    logger.info(
      {
        address: payerAddress,
        amount: amountLovelace.toString(),
        remainingBalance: account.balanceLovelace.toString(),
      },
      'Payment settled via credit deduction'
    );

    return {
      success: true,
      network,
      strategy: 'credit_deduction',
      remainingBalance: account.balanceLovelace.toString(),
    };
  } catch (error) {
    // CreditInsufficientError or CreditAccountNotFoundError from ledger.debit
    const reason = error instanceof Error && 'code' in error
      ? (error as { code: string }).code === 'CREDIT_INSUFFICIENT'
        ? 'insufficient_credits'
        : (error as { code: string }).code === 'CREDIT_ACCOUNT_NOT_FOUND'
          ? 'account_not_found'
          : (error as { code: string }).code === 'CREDIT_ACCOUNT_EXPIRED'
            ? 'account_expired'
            : 'credit_deduction_failed'
      : 'credit_deduction_failed';

    logger.info(
      { address: payerAddress, reason, err: error instanceof Error ? error.message : 'Unknown' },
      'Credit deduction failed'
    );

    return {
      success: false,
      reason,
      strategy: 'credit_deduction',
    };
  }
}
```

Also add the import for CreditLedger type at the top of the file. Use a type-only import to avoid circular dependencies:

```typescript
import type { CreditLedger } from '../credits/credit-ledger.js';
```

IMPORTANT: The existing `settlePayment()` function is NOT modified at all. `settleWithCredits` is a new, separate export.
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test` -- all existing settle tests pass (settlePayment unchanged). Verify settleWithCredits returns strategy: 'credit_deduction' in all cases.
  </verify>
  <done>settleWithCredits function added to settle-payment.ts. Deducts from credit ledger, handles insufficient/not-found/expired errors with distinct reason codes. Existing settlePayment completely unchanged.</done>
</task>

<task type="auto">
  <name>Task 4: Update /settle route with dual-path support</name>
  <files>src/routes/settle.ts, tests/integration/settle-route.test.ts</files>
  <action>
Update the /settle route handler to support both L1 settlement and credit deduction.

**Updated route flow:**

```
1. Parse request body (transaction is now optional)
2. Determine strategy:
   a. If credits enabled -> call selectStrategy()
   b. If credits disabled -> strategy = 'direct_l1' (implicit)
3. Execute based on strategy:
   a. direct_l1: validate transaction present, call settlePayment() (existing flow)
   b. credit_deduction: validate payerAddress present, call settleWithCredits()
4. Attach strategy to result
5. Return HTTP 200
```

**Route handler updates:**

Add imports:
```typescript
import { selectStrategy, buildPaymentStrategies } from '../credits/strategy.js';
import { settleWithCredits } from '../settle/settle-payment.js';
```

After parsing with SettleRequestSchema:

```typescript
const { paymentRequirements, paymentStrategy: requestedStrategy, payerAddress } = parsed.data;

// Determine strategy
let strategy: 'direct_l1' | 'credit_deduction' = 'direct_l1';

if (fastify.config.chain.credits?.enabled) {
  // Get credit balance for strategy decision (null if no account)
  let creditBalance: bigint | null = null;
  if (payerAddress && fastify.creditLedger) {
    const account = await fastify.creditLedger.getAccount(payerAddress);
    creditBalance = account?.balanceLovelace ?? null;
  }

  // Get min UTXO as threshold
  const threshold = await fastify.chainProvider.getMinUtxoLovelace(0);

  const decision = selectStrategy(
    BigInt(paymentRequirements.maxAmountRequired),
    threshold,
    creditBalance,
    requestedStrategy,
  );

  if (decision === null) {
    // Include payment strategies info so client knows what options exist
    const creditsConfig = fastify.config.chain.credits;
    const strategies = buildPaymentStrategies(
      BigInt(paymentRequirements.maxAmountRequired),
      threshold,
      creditBalance,
      true, // credits enabled (we're inside the enabled block)
      BigInt(creditsConfig?.minTopupLovelace ?? 2000000),
    );
    return reply.status(200).send({
      success: false,
      reason: 'insufficient_credits',
      strategy: requestedStrategy ?? 'credit_deduction',
      paymentStrategies: strategies,
    });
  }

  strategy = decision.strategy;
}

// Execute based on strategy
if (strategy === 'credit_deduction') {
  // Credit deduction path
  if (!payerAddress) {
    return reply.status(200).send({
      success: false,
      reason: 'payer_address_required',
      strategy: 'credit_deduction',
    });
  }

  const network = CAIP2_CHAIN_IDS[chainConfig.network as CardanoNetwork];
  const result = await settleWithCredits(
    payerAddress,
    BigInt(paymentRequirements.maxAmountRequired),
    network,
    fastify.creditLedger,
    fastify.log,
  );
  return reply.status(200).send(result);
}

// Direct L1 path (existing flow -- unchanged except strategy tag)
if (!parsed.data.transaction) {
  return reply.status(200).send({
    success: false,
    reason: 'transaction_required',
    strategy: 'direct_l1',
  });
}

// Existing VerifyContext assembly (same as before, uses parsed.data.transaction which is now validated as non-undefined)
const ctx: VerifyContext = {
  scheme: paymentRequirements.scheme,
  network: paymentRequirements.network,
  payTo: paymentRequirements.payTo,
  requiredAmount: BigInt(paymentRequirements.maxAmountRequired),
  maxTimeoutSeconds: paymentRequirements.maxTimeoutSeconds,
  asset: paymentRequirements.asset,
  transactionCbor: parsed.data.transaction, // guaranteed non-undefined by guard above
  payerAddress: undefined,
  requestedAt: Date.now(),
  getCurrentSlot: () => fastify.chainProvider.getCurrentSlot(),
  getMinUtxoLovelace: (numAssets: number) =>
    fastify.chainProvider.getMinUtxoLovelace(numAssets),
  configuredNetwork: CAIP2_CHAIN_IDS[chainConfig.network as CardanoNetwork],
  feeMin: BigInt(verificationConfig.feeMinLovelace),
  feeMax: BigInt(verificationConfig.feeMaxLovelace),
};

const cborBytes = Buffer.from(parsed.data.transaction, 'base64');
const l1Network = CAIP2_CHAIN_IDS[chainConfig.network as CardanoNetwork];

try {
  const result = await settlePayment(
    ctx, cborBytes, fastify.chainProvider.blockfrostClient,
    fastify.redis, l1Network, fastify.log
  );
  return reply.status(200).send({ ...result, strategy: 'direct_l1' });
} catch (error) {
  fastify.log.error(
    { err: error instanceof Error ? error.message : 'Unknown error' },
    'Unexpected error during settlement'
  );
  return reply.status(500).send({
    error: 'Internal Server Error',
    message: 'An unexpected error occurred during settlement',
  });
}
```

**Test updates** (`tests/integration/settle-route.test.ts`):

Add new test cases (keep all existing tests, they should still pass since transaction is still accepted):

10. Credit deduction: valid payerAddress + sufficient credits -> 200 success with strategy: 'credit_deduction' and remainingBalance
11. Credit deduction: no payerAddress -> 200 { success: false, reason: 'payer_address_required' }
12. Credit deduction: insufficient credits -> 200 { success: false, reason: 'insufficient_credits' }
13. Direct L1 without transaction (no CBOR): -> 200 { success: false, reason: 'transaction_required' }
14. Explicit paymentStrategy: 'direct_l1' with valid transaction -> uses L1 path
15. Credits disabled: all requests use L1 path (backward compatible)
16. Existing tests (L1 settlement) still pass with strategy: 'direct_l1' in response

NOTE: Existing settle route tests may need small updates to expect the `strategy: 'direct_l1'` field in responses. If so, update the assertions to match (add optional `strategy` check or use `toMatchObject` for partial matching).
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test -- tests/integration/settle-route.test.ts` -- all tests pass (existing + new). Run `pnpm test` -- full suite passes. Verify /settle backward compatible: requests without paymentStrategy still work via L1. Verify credit deduction requires no CBOR transaction.
  </verify>
  <done>/settle route updated with dual-path support: L1 settlement (existing, unchanged) and credit deduction (new, off-chain). Strategy router decides based on amount vs threshold and credit balance. 7 new integration tests + existing tests pass. Fully backward compatible.</done>
</task>

<task type="auto">
  <name>Task 5: Update barrel exports</name>
  <files>src/credits/index.ts</files>
  <action>
Add strategy exports to `src/credits/index.ts`:

```typescript
// Strategy router
export { selectStrategy } from './strategy.js';
export type { PaymentStrategy, StrategyDecision } from './strategy.js';
```

Add settleWithCredits export note -- it's exported from `src/settle/settle-payment.ts`, not from credits module. No barrel change needed for it.
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm lint` -- passes.
  </verify>
  <done>Credits barrel updated with strategy router exports. All module boundaries clean.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (existing tests + new strategy + settle integration tests)
- `npx tsc --noEmit` passes
- selectStrategy is a pure function with no async or side effects
- /settle with no paymentStrategy and valid transaction still uses L1 (backward compatible)
- /settle with paymentStrategy: 'credit_deduction' and valid payerAddress deducts credits
- /settle credit deduction requires no CBOR transaction
- /settle result includes strategy field ('direct_l1' or 'credit_deduction')
- /settle credit deduction includes remainingBalance on success
- Insufficient credits returns clear error reason with paymentStrategies info showing available options
- settleWithCredits handles CREDIT_INSUFFICIENT, CREDIT_ACCOUNT_NOT_FOUND, CREDIT_ACCOUNT_EXPIRED
- Existing settle route integration tests still pass (may need minor assertion updates for strategy field)
</verification>

<success_criteria>
Payment strategy routing is operational. Payments above min UTXO threshold settle on L1 (existing flow, zero changes). Payments below threshold settle via credit deduction (off-chain, instant). Clients can explicitly request a strategy or let the router auto-select. The /settle endpoint is backward compatible -- existing clients see no breaking changes. Ready for Plan 04 (402 enrichment and L2 research document).
</success_criteria>

<output>
After completion, create `.planning/phases/06-micropayment-strategy/06-03-SUMMARY.md`
</output>
