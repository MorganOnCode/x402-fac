---
phase: 06-micropayment-strategy
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/credits/topup.ts
  - src/routes/credits.ts
  - src/server.ts
  - src/types/index.ts
  - tests/unit/credits/topup.test.ts
  - tests/integration/credits-route.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /credits/topup accepts a signed CBOR transaction + paymentRequirements, verifies it, settles it, then credits the sender's account"
    - "Top-up reuses the existing verifyPayment() + settlePayment() pipeline with payTo set to the facilitator's configured address"
    - "GET /credits/balance?address=addr1... returns the credit account state for a given address"
    - "Top-up dedup uses the same CBOR SHA-256 key as settlement (prevents double-crediting)"
    - "Top-up amount must be >= config.chain.credits.minTopupLovelace"
    - "CreditLedger is created during server startup and decorated on the Fastify instance"
    - "Credit routes are only registered when config.chain.credits.enabled is true"
  artifacts:
    - path: "src/credits/topup.ts"
      provides: "processTopup() orchestrator: verify -> settle -> credit account"
      exports: ["processTopup"]
    - path: "src/routes/credits.ts"
      provides: "POST /credits/topup and GET /credits/balance route plugins"
      exports: ["creditRoutesPlugin"]
    - path: "src/server.ts"
      provides: "Updated server with CreditLedger initialization and credit routes registration"
      contains: "creditLedger"
    - path: "tests/unit/credits/topup.test.ts"
      provides: "Unit tests for processTopup orchestrator"
    - path: "tests/integration/credits-route.test.ts"
      provides: "Integration tests for credit HTTP endpoints"
  key_links:
    - from: "src/credits/topup.ts"
      to: "src/settle/settle-payment.ts"
      via: "processTopup calls settlePayment for L1 settlement before crediting"
      pattern: "settlePayment"
    - from: "src/credits/topup.ts"
      to: "src/credits/credit-ledger.ts"
      via: "processTopup calls ledger.credit after successful settlement"
      pattern: "CreditLedger.credit"
    - from: "src/routes/credits.ts"
      to: "src/credits/topup.ts"
      via: "Route handler calls processTopup"
      pattern: "processTopup"
---

<objective>
Build the top-up flow and balance query endpoints that allow users to fund their prepaid credit accounts via L1 payments.

Purpose: The top-up flow is how credits enter the system. It reuses the existing verify+settle pipeline (defense-in-depth) and adds account crediting on top. The balance endpoint lets clients check their credit state before making micropayments. These endpoints are prerequisites for the payment strategy router (Plan 03).

Output: `src/credits/topup.ts` orchestrator, `src/routes/credits.ts` route plugin, updated `src/server.ts` with ledger initialization, integration tests.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-micropayment-strategy/06-RESEARCH.md
@.planning/phases/06-micropayment-strategy/06-01-PLAN.md
@src/settle/settle-payment.ts
@src/settle/types.ts
@src/verify/types.ts
@src/verify/verify-payment.ts
@src/routes/settle.ts
@src/routes/verify.ts
@src/server.ts
@src/types/index.ts
@src/chain/config.ts
@src/credits/types.ts
@src/credits/credit-ledger.ts
@src/credits/errors.ts
@src/credits/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create processTopup orchestrator</name>
  <files>src/credits/topup.ts, tests/unit/credits/topup.test.ts</files>
  <action>
Create `src/credits/topup.ts` -- the orchestrator for the top-up flow.

**Top-up flow:**
1. Validate top-up amount >= minTopupLovelace
2. Verify the transaction via verifyPayment() (payTo = facilitator address)
3. Settle the transaction via settlePayment() (submit to L1)
4. On successful settlement, credit the sender's account via CreditLedger.credit()
5. Return the result with updated balance

**Interface:**

```typescript
import type { FastifyBaseLogger } from 'fastify';

import type { BlockfrostClient } from '../chain/blockfrost-client.js';
import type { SettleResult } from '../settle/types.js';
import type { VerifyContext } from '../verify/types.js';
import { settlePayment } from '../settle/settle-payment.js';
import type { RedisLike } from '../settle/settle-payment.js';
import type { CreditLedger } from './credit-ledger.js';
import type { CreditAccount } from './types.js';

export interface TopupResult {
  /** Whether the top-up succeeded */
  success: boolean;
  /** Settlement transaction hash (if submitted) */
  transaction?: string;
  /** CAIP-2 network */
  network?: string;
  /** Updated credit balance after top-up (lovelace as string) */
  balance?: string;
  /** Failure reason */
  reason?: string;
}

/**
 * Process a credit account top-up.
 *
 * Flow: verify -> settle -> credit account
 *
 * The payer sends a standard L1 transaction with payTo = facilitator address.
 * After the payment settles on-chain, the sender's credit account is credited.
 *
 * @param ctx - VerifyContext with payTo set to the facilitator's address
 * @param cborBytes - Raw CBOR bytes of the signed transaction
 * @param topupAmountLovelace - The amount being topped up (from paymentRequirements)
 * @param senderAddress - The payer's Cardano address (credit account identity)
 * @param blockfrost - BlockfrostClient for settlement
 * @param redis - Redis for settlement dedup
 * @param network - CAIP-2 network string
 * @param ledger - CreditLedger for account crediting
 * @param maxBalanceLovelace - Maximum balance cap from config
 * @param logger - Fastify logger
 */
export async function processTopup(
  ctx: VerifyContext,
  cborBytes: Uint8Array,
  topupAmountLovelace: bigint,
  senderAddress: string,
  blockfrost: BlockfrostClient,
  redis: RedisLike,
  network: string,
  ledger: CreditLedger,
  maxBalanceLovelace: bigint,
  logger: FastifyBaseLogger,
): Promise<TopupResult> {
  // 1. Settle on L1 (includes re-verify + dedup + submit + poll)
  const settleResult: SettleResult = await settlePayment(
    ctx, cborBytes, blockfrost, redis, network, logger
  );

  if (!settleResult.success) {
    return {
      success: false,
      reason: settleResult.reason,
      transaction: settleResult.transaction,
    };
  }

  // 2. Credit the sender's account
  try {
    const account: CreditAccount = await ledger.credit(
      senderAddress,
      topupAmountLovelace,
      settleResult.transaction!, // txHash from successful settlement
      maxBalanceLovelace,
    );

    logger.info(
      {
        address: senderAddress,
        amount: topupAmountLovelace.toString(),
        newBalance: account.balanceLovelace.toString(),
        txHash: settleResult.transaction,
      },
      'Credit account topped up'
    );

    return {
      success: true,
      transaction: settleResult.transaction,
      network: settleResult.network,
      balance: account.balanceLovelace.toString(),
    };
  } catch (error) {
    // Settlement succeeded but crediting failed -- log critically
    // The L1 payment went through, so we need to handle this carefully
    logger.error(
      {
        address: senderAddress,
        amount: topupAmountLovelace.toString(),
        txHash: settleResult.transaction,
        err: error instanceof Error ? error.message : 'Unknown error',
      },
      'CRITICAL: Settlement succeeded but crediting failed -- manual recovery needed'
    );

    return {
      success: false,
      reason: 'credit_failed',
      transaction: settleResult.transaction,
    };
  }
}
```

**Key design decisions:**
- processTopup delegates settlement to settlePayment() (reuse, not duplicate)
- If settlement succeeds but crediting fails, log CRITICAL and return failure with txHash for manual recovery
- The senderAddress is extracted from the transaction by the route handler (Plan 02 Task 2), NOT from the request body (prevents impersonation)

**Tests** (`tests/unit/credits/topup.test.ts`):

Mock settlePayment at the module level (same pattern as settle route integration tests):

```typescript
vi.mock('../settle/settle-payment.js', () => ({
  settlePayment: vi.fn(),
}));
```

Mock CreditLedger as a plain object with vi.fn() methods.

Test cases:
1. Successful top-up: settlement succeeds, credit succeeds, returns { success: true, balance, transaction }
2. Settlement fails (verification_failed): returns { success: false, reason: 'verification_failed' }
3. Settlement fails (confirmation_timeout): returns { success: false, reason: 'confirmation_timeout', transaction }
4. Settlement succeeds but credit fails (max balance exceeded): returns { success: false, reason: 'credit_failed', transaction }
5. Settlement succeeds but credit throws unexpected error: returns { success: false, reason: 'credit_failed', transaction }, logs CRITICAL
6. Verify settlePayment is called with correct args (ctx, cborBytes, blockfrost, redis, network, logger)
7. Verify ledger.credit is called with correct args (senderAddress, amount, txHash, maxBalance)
8. Verify ledger.credit is NOT called when settlement fails
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test -- tests/unit/credits/topup.test.ts` -- all tests pass. Verify processTopup calls settlePayment before ledger.credit. Verify CRITICAL log on credit failure after settlement.
  </verify>
  <done>processTopup orchestrator implements verify->settle->credit flow with defensive error handling. 8 unit tests cover success path, settlement failures, and the critical credit-after-settlement failure edge case.</done>
</task>

<task type="auto">
  <name>Task 2: Create credit routes (topup + balance)</name>
  <files>src/routes/credits.ts, tests/integration/credits-route.test.ts</files>
  <action>
Create `src/routes/credits.ts` with POST /credits/topup and GET /credits/balance endpoints.

**Route plugin pattern:** Follow the same pattern as `src/routes/settle.ts` and `src/routes/verify.ts` (FastifyPluginCallback + fp).

**POST /credits/topup:**

Request body schema (Zod):
```typescript
const TopupRequestSchema = z.object({
  /** Base64-encoded signed CBOR transaction (same as /settle) */
  transaction: z.string().min(1),
  /** Payment requirements (payTo should be facilitator address) */
  paymentRequirements: PaymentRequirementsSchema,
});
```

Route handler:
1. Parse request body with TopupRequestSchema.safeParse()
2. Validate credits are enabled (config.chain.credits.enabled) -- return 200 { success: false, reason: 'credits_disabled' } if not
3. Validate payTo matches facilitator address -- return 200 { success: false, reason: 'invalid_recipient' } if not
4. Validate amount >= minTopupLovelace -- return 200 { success: false, reason: 'amount_below_minimum' } if not
5. Assemble VerifyContext (same as /settle, but payTo = facilitator address)
6. Convert base64 to cborBytes
7. Extract sender address: use paymentRequirements.extra?.payer (string) as the sender address. This is declared by the client. For the top-up use case this is acceptable because the credit goes to the declared address, and the L1 payment is verified independently.
8. Call processTopup() with assembled context
9. Return result as HTTP 200

**GET /credits/balance:**

Query parameter: `address` (required, bech32 Cardano address)

Route handler:
1. Validate `address` query parameter exists and is a non-empty string
2. Validate credits are enabled -- return 200 { success: false, reason: 'credits_disabled' }
3. Call ledger.getAccount(address)
4. If null: return 200 { success: true, account: null }
5. If found: return 200 { success: true, account: accountToResponse(account) }

**Server access pattern:**
The route needs access to `fastify.creditLedger` (CreditLedger) which will be decorated in Task 3. Use the Fastify type augmentation.

**Integration tests** (`tests/integration/credits-route.test.ts`):

Mock processTopup at the module level:
```typescript
vi.mock('../../src/credits/topup.js', () => ({
  processTopup: vi.fn(),
}));
```

Mock the credit ledger on the Fastify instance via decorator.

Test cases for POST /credits/topup:
1. Valid request: returns 200 with processTopup result
2. Invalid request body (missing transaction): returns 200 { success: false, reason: 'invalid_request' }
3. Credits disabled: returns 200 { success: false, reason: 'credits_disabled' }
4. payTo doesn't match facilitator address: returns 200 { success: false, reason: 'invalid_recipient' }
5. Amount below minTopupLovelace: returns 200 { success: false, reason: 'amount_below_minimum' }

Test cases for GET /credits/balance:
6. Existing account: returns 200 { success: true, account: { ... } }
7. Non-existent account: returns 200 { success: true, account: null }
8. Missing address parameter: returns 200 { success: false, reason: 'invalid_request' }
9. Credits disabled: returns 200 { success: false, reason: 'credits_disabled' }

NOTE: Integration tests need a test config with credits.enabled = true and credits.facilitatorAddress set. Extend the existing test config helper to include credit config.
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test -- tests/integration/credits-route.test.ts` -- all tests pass. Verify all responses are HTTP 200 (consistent with existing routes). Verify payTo validation prevents crediting to wrong address.
  </verify>
  <done>Credit routes implemented: POST /credits/topup (verify+settle+credit flow) and GET /credits/balance (account query). 9 integration tests cover happy paths, validation failures, and disabled-credits guard. All responses HTTP 200.</done>
</task>

<task type="auto">
  <name>Task 3: Wire credit ledger into server lifecycle</name>
  <files>src/server.ts, src/types/index.ts, src/credits/index.ts</files>
  <action>
**1. Update `src/types/index.ts`** -- add CreditLedger to Fastify augmentation:

Add import:
```typescript
import type { CreditLedger } from '../credits/credit-ledger.js';
```

Add to FastifyInstance augmentation:
```typescript
creditLedger: CreditLedger;
```

This field will be `undefined` when credits are disabled. Routes check `config.chain.credits.enabled` before accessing it.

**2. Update `src/server.ts`** -- initialize CreditLedger and register credit routes:

Add imports:
```typescript
import { createCreditLedger } from './credits/index.js';
import { creditRoutesPlugin } from './routes/credits.js';
```

After the chain layer initialization (after `server.decorate('chainProvider', chainProvider)`), add credit ledger initialization:

```typescript
// ---- Credit ledger initialization (optional) ----
if (config.chain.credits?.enabled) {
  const creditLedger = createCreditLedger(
    redis,
    config.chain.credits.expirationDays,
    server.log,
  );
  server.decorate('creditLedger', creditLedger);
  server.log.info(
    { facilitatorAddress: config.chain.credits.facilitatorAddress },
    'Credit ledger initialized'
  );
} else {
  // Decorate with a null-like sentinel so type augmentation doesn't break
  server.decorate('creditLedger', null as unknown as CreditLedger);
}
```

Register credit routes alongside existing routes (after statusRoutesPlugin):
```typescript
await server.register(creditRoutesPlugin);
```

The credit routes internally check `config.chain.credits.enabled` and return `credits_disabled` when not enabled. They are always registered but gate their behavior.

**3. Update `src/credits/index.ts`** -- add topup exports:

```typescript
// Topup orchestrator
export { processTopup } from './topup.js';
export type { TopupResult } from './topup.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm build` -- succeeds. Run `pnpm test` -- all tests pass (existing + new). Verify that existing tests still pass since credits default to disabled. Verify server starts correctly with credits disabled (no errors). Verify Fastify instance has creditLedger decoration.
  </verify>
  <done>Server wired with CreditLedger: created during startup when credits enabled, null sentinel when disabled. Credit routes registered and gate on config.chain.credits.enabled. Type augmentation updated. All existing tests pass with no regressions.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (existing 246 tests + new credit tests)
- `npx tsc --noEmit` passes
- POST /credits/topup validates payTo matches facilitator address (prevents crediting wrong recipient)
- POST /credits/topup validates amount >= minTopupLovelace
- POST /credits/topup returns credits_disabled when credits not enabled in config
- GET /credits/balance returns null account for non-existent address
- GET /credits/balance returns account with BigInt-safe string balances
- processTopup reuses settlePayment (no duplicated settlement logic)
- processTopup logs CRITICAL when settlement succeeds but crediting fails
- CreditLedger decorated on Fastify instance
- Existing /verify, /settle, /status, /health routes unaffected
- Server starts correctly with credits disabled (default config)
</verification>

<success_criteria>
Top-up and balance endpoints are operational. Users can send L1 payments to the facilitator address and receive credit. Balance is queryable. The top-up flow reuses the battle-tested verify+settle pipeline and adds crediting on top. Ready for Plan 03 (payment strategy router) which will let these credits be spent on micropayments.
</success_criteria>

<output>
After completion, create `.planning/phases/06-micropayment-strategy/06-02-SUMMARY.md`
</output>
