---
phase: 06-micropayment-strategy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/credits/types.ts
  - src/credits/credit-ledger.ts
  - src/credits/errors.ts
  - src/credits/index.ts
  - src/config/schema.ts
  - src/chain/config.ts
  - tests/unit/credits/credit-ledger.test.ts
  - tests/unit/credits/types.test.ts
autonomous: true

must_haves:
  truths:
    - "CreditAccount tracks per-address balance, lifetime deposits, lifetime spend, and activity timestamps"
    - "CreditTransaction records each topup, deduction, or withdrawal with amount, reference, and timestamp"
    - "CreditLedger interface abstracts storage with getAccount, credit, debit, getTransactions methods"
    - "RedisCreditLedger uses Redis Hash per account (credit:{address}) with HINCRBY for atomic balance updates"
    - "Debit operation uses Lua script for atomic check-and-deduct (prevents negative balances)"
    - "Credit accounts expire after 90 days of inactivity via lazy check on read"
    - "ChainConfig extended with credits section (enabled, minTopupLovelace, maxBalanceLovelace, expirationDays)"
    - "Credit-specific domain errors exist: CREDIT_INSUFFICIENT, CREDIT_ACCOUNT_NOT_FOUND, CREDIT_ACCOUNT_EXPIRED, CREDIT_MAX_BALANCE"
  artifacts:
    - path: "src/credits/types.ts"
      provides: "CreditAccount, CreditTransaction interfaces, Zod schemas for API validation"
      exports: ["CreditAccount", "CreditTransaction", "CreditAccountSchema", "CreditTransactionSchema"]
    - path: "src/credits/credit-ledger.ts"
      provides: "CreditLedger interface and RedisCreditLedger implementation"
      exports: ["CreditLedger", "RedisCreditLedger", "createCreditLedger"]
    - path: "src/credits/errors.ts"
      provides: "Credit-specific domain errors"
      exports: ["CreditInsufficientError", "CreditAccountNotFoundError", "CreditAccountExpiredError", "CreditMaxBalanceError"]
    - path: "src/credits/index.ts"
      provides: "Barrel exports for credits module"
    - path: "tests/unit/credits/credit-ledger.test.ts"
      provides: "Unit tests for ledger operations with mock Redis"
  key_links:
    - from: "src/credits/credit-ledger.ts"
      to: "src/routes/credits.ts"
      via: "Ledger consumed by credit routes (Plan 06-02)"
      pattern: "CreditLedger|createCreditLedger"
    - from: "src/credits/types.ts"
      to: "src/settle/settle-payment.ts"
      via: "Types consumed by credit deduction path (Plan 06-03)"
      pattern: "CreditAccount|CreditTransaction"
    - from: "src/chain/config.ts"
      to: "src/server.ts"
      via: "Credit config accessed during ledger initialization"
      pattern: "credits"
---

<objective>
Create the credit account data model, Redis-backed ledger implementation, domain errors, and config extension for the prepaid credit system.

Purpose: Establish the foundational types and storage layer that top-up routes (Plan 02), payment strategy routing (Plan 03), and 402 enrichment (Plan 04) all depend on. The credit ledger is the core primitive -- all credit operations flow through it.

Output: `src/credits/` module with types, ledger, errors, and barrel exports. Extended ChainConfig with credits section. Unit tests for all ledger operations.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-micropayment-strategy/06-RESEARCH.md
@src/chain/config.ts
@src/chain/types.ts
@src/errors/index.ts
@src/settle/types.ts
@src/settle/settle-payment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create credit domain types and Zod schemas</name>
  <files>src/credits/types.ts</files>
  <action>
Create `src/credits/types.ts` with the data model for prepaid credit accounts.

**Interfaces:**

```typescript
/**
 * A prepaid credit account for a Cardano address.
 * Stored as a Redis Hash at key `credit:{address}`.
 */
export interface CreditAccount {
  /** Cardano bech32 address (account identity) */
  address: string;
  /** Current credit balance in lovelace */
  balanceLovelace: bigint;
  /** Lifetime total deposited in lovelace (audit trail) */
  totalDeposited: bigint;
  /** Lifetime total spent in lovelace (audit trail) */
  totalSpent: bigint;
  /** Epoch ms when account was created */
  createdAt: number;
  /** Epoch ms of last activity (topup, deduction, or balance query) */
  lastActivityAt: number;
}

/**
 * A single credit transaction (topup, deduction, or withdrawal).
 * Stored in a Redis List at key `credit:txlog:{address}`.
 */
export interface CreditTransaction {
  /** Unique transaction ID */
  id: string;
  /** Account address this transaction belongs to */
  accountAddress: string;
  /** Transaction type */
  type: 'topup' | 'deduction' | 'withdrawal';
  /** Amount in lovelace */
  amountLovelace: bigint;
  /** Reference: txHash for topup/withdrawal, settlement ID for deduction */
  reference?: string;
  /** Epoch ms timestamp */
  timestamp: number;
}
```

**Zod Schemas** (for API response validation and tests):

```typescript
export const CreditAccountResponseSchema = z.object({
  address: z.string(),
  balanceLovelace: z.string(),    // BigInt as string for JSON
  totalDeposited: z.string(),
  totalSpent: z.string(),
  createdAt: z.number(),
  lastActivityAt: z.number(),
});

export type CreditAccountResponse = z.infer<typeof CreditAccountResponseSchema>;
```

**Constants:**

```typescript
/** Redis key prefix for credit accounts */
export const CREDIT_KEY_PREFIX = 'credit:';

/** Redis key prefix for credit transaction logs */
export const CREDIT_TXLOG_PREFIX = 'credit:txlog:';

/** Maximum transaction log entries per account */
export const CREDIT_TXLOG_MAX_ENTRIES = 1000;
```

**Helper to serialize CreditAccount to/from Redis Hash fields:**

```typescript
/** Serialize a CreditAccount to Redis Hash field values (all strings). */
export function serializeAccount(account: CreditAccount): Record<string, string> {
  return {
    address: account.address,
    balanceLovelace: account.balanceLovelace.toString(),
    totalDeposited: account.totalDeposited.toString(),
    totalSpent: account.totalSpent.toString(),
    createdAt: account.createdAt.toString(),
    lastActivityAt: account.lastActivityAt.toString(),
  };
}

/** Deserialize Redis Hash fields to a CreditAccount. Returns null if fields are missing. */
export function deserializeAccount(fields: Record<string, string>): CreditAccount | null {
  if (!fields.address || !fields.balanceLovelace) return null;
  return {
    address: fields.address,
    balanceLovelace: BigInt(fields.balanceLovelace),
    totalDeposited: BigInt(fields.totalDeposited || '0'),
    totalSpent: BigInt(fields.totalSpent || '0'),
    createdAt: Number(fields.createdAt || '0'),
    lastActivityAt: Number(fields.lastActivityAt || '0'),
  };
}

/** Convert a CreditAccount to a JSON-safe API response (bigints as strings). */
export function accountToResponse(account: CreditAccount): CreditAccountResponse {
  return {
    address: account.address,
    balanceLovelace: account.balanceLovelace.toString(),
    totalDeposited: account.totalDeposited.toString(),
    totalSpent: account.totalSpent.toString(),
    createdAt: account.createdAt,
    lastActivityAt: account.lastActivityAt,
  };
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors.
  </verify>
  <done>Credit domain types created: CreditAccount, CreditTransaction interfaces, CreditAccountResponseSchema, serialization helpers, and Redis key constants.</done>
</task>

<task type="auto">
  <name>Task 2: Create credit-specific domain errors</name>
  <files>src/credits/errors.ts, src/errors/index.ts</files>
  <action>
Create `src/credits/errors.ts` following the existing error pattern from `src/chain/errors.ts` (using `@fastify/error`):

```typescript
import createError from '@fastify/error';

/** Insufficient credit balance for the requested deduction. */
export const CreditInsufficientError = createError<[string, string]>(
  'CREDIT_INSUFFICIENT',
  'Insufficient credits: requested %s lovelace, available %s lovelace',
  402
);

/** Credit account not found for the given address. */
export const CreditAccountNotFoundError = createError<[string]>(
  'CREDIT_ACCOUNT_NOT_FOUND',
  'No credit account found for address: %s',
  404
);

/** Credit account expired due to inactivity. */
export const CreditAccountExpiredError = createError<[string]>(
  'CREDIT_ACCOUNT_EXPIRED',
  'Credit account expired for address: %s',
  410
);

/** Credit would exceed maximum allowed balance. */
export const CreditMaxBalanceError = createError<[string, string]>(
  'CREDIT_MAX_BALANCE',
  'Credit would exceed maximum balance: current %s + deposit would exceed %s lovelace',
  400
);
```

Update `src/errors/index.ts` to re-export credit errors:

```typescript
// Credit errors (CREDIT_*) - re-exported from credits domain
export {
  CreditInsufficientError,
  CreditAccountNotFoundError,
  CreditAccountExpiredError,
  CreditMaxBalanceError,
} from '../credits/errors.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Verify each error has a unique code starting with `CREDIT_`.
  </verify>
  <done>Four credit domain errors created with HTTP status codes: CREDIT_INSUFFICIENT (402), CREDIT_ACCOUNT_NOT_FOUND (404), CREDIT_ACCOUNT_EXPIRED (410), CREDIT_MAX_BALANCE (400). Re-exported via errors barrel.</done>
</task>

<task type="auto">
  <name>Task 3: Extend ChainConfig with credits configuration</name>
  <files>src/chain/config.ts</files>
  <action>
Add a `credits` section to the `ChainConfigSchema` inside the `.object({})`, after the `verification` section:

```typescript
credits: z
  .object({
    /** Whether prepaid credit accounts are enabled */
    enabled: z.boolean().default(false),
    /** Minimum top-up amount in lovelace (must be above min UTXO to be settleable on L1) */
    minTopupLovelace: z.number().int().min(1000000).max(100000000).default(2000000),
    /** Maximum credit balance per account in lovelace (limit exposure) */
    maxBalanceLovelace: z.number().int().min(1000000).max(1000000000).default(100000000),
    /** Days of inactivity before account expires (0 = never) */
    expirationDays: z.number().int().min(0).max(365).default(90),
    /** Facilitator's receiving address for top-up payments (bech32) */
    facilitatorAddress: z.string().min(1).optional(),
  })
  .default(() => ({
    enabled: false,
    minTopupLovelace: 2000000,
    maxBalanceLovelace: 100000000,
    expirationDays: 90,
  })),
```

The `credits` section is **optional with defaults** so existing configs continue to work without changes. `facilitatorAddress` is optional -- it's only required when credits are enabled.

Add a refinement to validate that `facilitatorAddress` is provided when credits are enabled. Add this inside the existing `.superRefine()` callback, after the mainnet guardrail check:

```typescript
// Credit system requires facilitator address
if (data.credits?.enabled && !data.credits.facilitatorAddress) {
  ctx.addIssue({
    code: z.ZodIssueCode.custom,
    message: 'Credits enabled but facilitatorAddress is not configured',
    path: ['credits', 'facilitatorAddress'],
  });
}
```

NOTE: The `data` object in `.superRefine()` has an inferred type. Since `credits` now has a default, `data.credits` will always be defined. Use optional chaining as a safety measure.
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test` -- all existing 246 tests pass (credits.enabled defaults to false, so no behavioral changes). Verify that omitting `credits` from config still works (Zod defaults kick in).
  </verify>
  <done>ChainConfig extended with credits section: enabled (bool), minTopupLovelace, maxBalanceLovelace, expirationDays, facilitatorAddress. Defaults to disabled. Validation ensures facilitatorAddress is provided when enabled.</done>
</task>

<task type="auto">
  <name>Task 4: Implement RedisCreditLedger with atomic operations</name>
  <files>src/credits/credit-ledger.ts, tests/unit/credits/credit-ledger.test.ts</files>
  <action>
Create `src/credits/credit-ledger.ts` implementing the credit ledger with Redis Hash storage.

**Interface:**

```typescript
import { randomUUID } from 'node:crypto';
import type { FastifyBaseLogger } from 'fastify';
import type Redis from 'ioredis';

import type { CreditAccount, CreditTransaction } from './types.js';
import {
  CREDIT_KEY_PREFIX,
  CREDIT_TXLOG_PREFIX,
  CREDIT_TXLOG_MAX_ENTRIES,
  deserializeAccount,
} from './types.js';

/**
 * CreditLedger abstracts credit account operations.
 * All balance mutations are atomic to prevent race conditions.
 */
export interface CreditLedger {
  /** Get a credit account by address. Returns null if not found or expired. */
  getAccount(address: string): Promise<CreditAccount | null>;

  /**
   * Credit (top-up) an account. Creates the account if it doesn't exist.
   * Returns the updated account.
   * @param address - Cardano bech32 address
   * @param amountLovelace - Amount to credit
   * @param reference - L1 txHash for audit trail
   * @param maxBalanceLovelace - Maximum allowed balance (rejects if exceeded)
   */
  credit(
    address: string,
    amountLovelace: bigint,
    reference: string,
    maxBalanceLovelace: bigint,
  ): Promise<CreditAccount>;

  /**
   * Debit (deduct) from an account. Fails if insufficient balance.
   * Returns the updated account.
   * @param address - Cardano bech32 address
   * @param amountLovelace - Amount to deduct
   * @param reference - Settlement/invoice ID for audit trail
   */
  debit(
    address: string,
    amountLovelace: bigint,
    reference: string,
  ): Promise<CreditAccount>;

  /** Get recent transactions for an account (newest first, up to limit). */
  getTransactions(address: string, limit?: number): Promise<CreditTransaction[]>;
}
```

**RedisCreditLedger implementation:**

Redis key structure:
- `credit:{address}` -> Hash with account fields (balanceLovelace, totalDeposited, totalSpent, createdAt, lastActivityAt)
- `credit:txlog:{address}` -> List of JSON-serialized CreditTransaction objects (LPUSH, newest first)

**Critical: Atomic debit with Lua script.**

The debit operation MUST be atomic. Use a Redis Lua script to:
1. Read current balance
2. Check >= requested amount
3. Decrement balance and increment totalSpent
4. Update lastActivityAt
5. Return new balance (or -1 if insufficient)

```typescript
const DEBIT_LUA_SCRIPT = `
  local key = KEYS[1]
  local amount = tonumber(ARGV[1])
  local now = ARGV[2]
  local balance = tonumber(redis.call('HGET', key, 'balanceLovelace') or '0')
  if balance < amount then
    return -1
  end
  redis.call('HINCRBY', key, 'balanceLovelace', -amount)
  redis.call('HINCRBY', key, 'totalSpent', amount)
  redis.call('HSET', key, 'lastActivityAt', now)
  return balance - amount
`;
```

**Credit operation:**
Use `HINCRBY` for balance and totalDeposited, `HSET` for lastActivityAt. For new accounts, also set address and createdAt via `HSETNX`.

**Expiration check:**
In `getAccount()`, after reading the hash, check if `lastActivityAt` is older than `expirationDays` days. If expired, return null (lazy expiration -- don't delete, just report as expired). The caller can clean up later.

Pass `expirationDays` to the constructor:

```typescript
export class RedisCreditLedger implements CreditLedger {
  private readonly redis: Redis;
  private readonly expirationDays: number;
  private readonly logger: FastifyBaseLogger;

  constructor(redis: Redis, expirationDays: number, logger: FastifyBaseLogger) {
    this.redis = redis;
    this.expirationDays = expirationDays;
    this.logger = logger;
  }
  // ... methods
}
```

**Factory function:**

```typescript
export function createCreditLedger(
  redis: Redis,
  expirationDays: number,
  logger: FastifyBaseLogger,
): CreditLedger {
  return new RedisCreditLedger(redis, expirationDays, logger);
}
```

**Transaction logging:**
After each credit/debit, LPUSH a JSON CreditTransaction to `credit:txlog:{address}` and LTRIM to `CREDIT_TXLOG_MAX_ENTRIES` to cap history size.

The `credit()` method must check if adding the amount would exceed `maxBalanceLovelace`. Read current balance first (HGET), check `currentBalance + amount <= maxBalance`, then HINCRBY. This is a small TOCTOU window but acceptable for credits (not security-critical like debit).

**Tests** (`tests/unit/credits/credit-ledger.test.ts`):

Create a mock Redis using a class that implements the subset of Redis commands used:
- `hgetall`, `hget`, `hsetnx`, `hset`, `hincrby`, `eval` (Lua), `lpush`, `ltrim`, `lrange`

Use an in-memory Map<string, Map<string, string>> for hashes and Map<string, string[]> for lists.

Test cases:
1. `getAccount` returns null for non-existent address
2. `credit` creates new account with correct initial state
3. `credit` adds to existing account balance atomically
4. `credit` rejects when balance would exceed maxBalanceLovelace
5. `credit` records topup transaction in txlog
6. `debit` deducts from balance atomically
7. `debit` rejects when insufficient balance (balance unchanged)
8. `debit` records deduction transaction in txlog
9. `getTransactions` returns newest-first, respects limit
10. `getAccount` returns null for expired account (lastActivityAt > expirationDays ago)
11. `getAccount` returns account for non-expired account
12. `credit` updates lastActivityAt
13. `debit` updates lastActivityAt and totalSpent
14. `credit` updates totalDeposited
15. Concurrent debit attempts: second debit fails if first depleted balance (Lua atomicity)
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test -- tests/unit/credits/credit-ledger.test.ts` -- all tests pass. Verify Lua script prevents negative balances. Verify transaction log is capped at CREDIT_TXLOG_MAX_ENTRIES.
  </verify>
  <done>RedisCreditLedger implemented with atomic Lua-based debit, HINCRBY-based credit, lazy expiration, and capped transaction log. 15 unit tests cover all operations including concurrent debit safety.</done>
</task>

<task type="auto">
  <name>Task 5: Create barrel exports and types tests</name>
  <files>src/credits/index.ts, tests/unit/credits/types.test.ts</files>
  <action>
**1. Create `src/credits/index.ts`:**

```typescript
// Barrel exports for the credits module

// Types
export type { CreditAccount, CreditTransaction, CreditAccountResponse } from './types.js';
export {
  CreditAccountResponseSchema,
  CREDIT_KEY_PREFIX,
  CREDIT_TXLOG_PREFIX,
  CREDIT_TXLOG_MAX_ENTRIES,
  serializeAccount,
  deserializeAccount,
  accountToResponse,
} from './types.js';

// Ledger
export type { CreditLedger } from './credit-ledger.js';
export { RedisCreditLedger, createCreditLedger } from './credit-ledger.js';

// Errors
export {
  CreditInsufficientError,
  CreditAccountNotFoundError,
  CreditAccountExpiredError,
  CreditMaxBalanceError,
} from './errors.js';
```

**2. Create `tests/unit/credits/types.test.ts`:**

Test the serialization/deserialization helpers:
1. `serializeAccount` converts bigints to strings
2. `deserializeAccount` converts strings back to bigints
3. `deserializeAccount` returns null when address field is missing
4. `deserializeAccount` returns null when balanceLovelace field is missing
5. `deserializeAccount` defaults totalDeposited/totalSpent to 0n when missing
6. `accountToResponse` converts bigints to strings for JSON safety
7. Round-trip: serializeAccount -> deserializeAccount produces equivalent CreditAccount
8. `CREDIT_KEY_PREFIX` is 'credit:'
9. `CREDIT_TXLOG_PREFIX` is 'credit:txlog:'
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test -- tests/unit/credits/` -- all tests pass. Run `pnpm lint` -- no violations. Run `pnpm test` -- all tests pass including existing 246 + new credit tests (no regressions).
  </verify>
  <done>Credits module barrel exports created. Type serialization tests verify round-trip correctness and null safety. All tests pass with no regressions.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (existing 246 tests + new credit tests)
- `npx tsc --noEmit` passes
- CreditAccount interface has address, balanceLovelace, totalDeposited, totalSpent, createdAt, lastActivityAt fields
- RedisCreditLedger.debit uses Lua script for atomic check-and-deduct
- RedisCreditLedger.credit uses HINCRBY for atomic balance increment
- Expired accounts (>90 days inactivity) return null from getAccount
- ChainConfig.credits section defaults to { enabled: false } for backward compatibility
- Credit errors use @fastify/error pattern with unique CREDIT_* codes
- Transaction log capped at 1000 entries per account
- Existing routes and tests are completely unaffected (credits disabled by default)
</verification>

<success_criteria>
Credit ledger foundation is in place: types, atomic Redis operations, domain errors, and config extension. RedisCreditLedger provides thread-safe credit/debit with Lua atomicity for debits. Transaction log maintains audit trail. ChainConfig extended but backward-compatible. Ready for Plan 02 (top-up routes), Plan 03 (payment strategy router), and Plan 04 (402 enrichment).
</success_criteria>

<output>
After completion, create `.planning/phases/06-micropayment-strategy/06-01-SUMMARY.md`
</output>
