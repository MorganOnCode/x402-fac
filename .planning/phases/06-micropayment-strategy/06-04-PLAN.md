---
phase: 06-micropayment-strategy
plan: 04
type: execute
wave: 4
depends_on: [06-01, 06-02, 06-03]
files_modified:
  - src/routes/credits.ts
  - src/credits/index.ts
  - tests/integration/credits-lifecycle.test.ts
  - .planning/phases/06-micropayment-strategy/06-L2-FEASIBILITY.md
autonomous: true

must_haves:
  truths:
    - "GET /credits/balance with amount query param includes paymentStrategies showing available settlement options"
    - "Payment strategies info is available in /settle failure responses (from Plan 03) AND /credits/balance (this plan)"
    - "L2 feasibility document covers Hydra, Midnight, and dual-rail patterns with concrete recommendations"
    - "End-to-end integration test validates full credit lifecycle: topup -> balance check -> micropayment settle -> balance decrease"
  artifacts:
    - path: "src/routes/credits.ts"
      provides: "Updated GET /credits/balance with paymentStrategies when amount param provided"
    - path: "tests/integration/credits-lifecycle.test.ts"
      provides: "End-to-end integration tests for full credit lifecycle"
    - path: ".planning/phases/06-micropayment-strategy/06-L2-FEASIBILITY.md"
      provides: "L2 feasibility research document for Hydra, Midnight, dual-rail"
  key_links:
    - from: "src/credits/strategy.ts"
      to: "src/routes/credits.ts"
      via: "Balance route calls buildPaymentStrategies from strategy.ts (created in Plan 03)"
      pattern: "buildPaymentStrategies"
---

<objective>
Wire payment strategy info into the balance endpoint, write the L2 feasibility research document, and create end-to-end integration tests for the full credit lifecycle.

Purpose: Plan 03 created `buildPaymentStrategies()` in `src/credits/strategy.ts` and wired it into /settle failure responses. This plan completes the enrichment by adding it to GET /credits/balance. The L2 research document fulfills the phase requirement of documenting future alternatives. The lifecycle tests prove the entire credit system works end-to-end.

Output: Updated balance route, lifecycle integration tests, L2 feasibility document.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-micropayment-strategy/06-RESEARCH.md
@.planning/phases/06-micropayment-strategy/06-01-PLAN.md
@.planning/phases/06-micropayment-strategy/06-02-PLAN.md
@.planning/phases/06-micropayment-strategy/06-03-PLAN.md
@src/credits/types.ts
@src/credits/credit-ledger.ts
@src/credits/strategy.ts
@src/credits/topup.ts
@src/credits/index.ts
@src/settle/types.ts
@src/settle/settle-payment.ts
@src/routes/settle.ts
@src/routes/credits.ts
@src/chain/config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire payment strategies into GET /credits/balance</name>
  <files>src/routes/credits.ts, src/credits/index.ts</files>
  <action>
**1. Update GET /credits/balance in `src/routes/credits.ts`:**

The GET /credits/balance handler currently returns the account state. Update it to accept an optional `amount` query parameter. When provided, include `paymentStrategies` in the response.

After fetching the account, add:

```typescript
import { buildPaymentStrategies } from '../credits/strategy.js';
import { accountToResponse } from '../credits/types.js';

// Inside GET /credits/balance handler, after getting account:

const amountStr = (request.query as Record<string, string>).amount;

if (amountStr) {
  const amount = BigInt(amountStr);
  const minUtxo = await fastify.chainProvider.getMinUtxoLovelace(0);
  const creditBalance = account?.balanceLovelace ?? null;
  const creditsConfig = fastify.config.chain.credits;

  const strategies = buildPaymentStrategies(
    amount,
    minUtxo,
    creditBalance,
    creditsConfig?.enabled ?? false,
    BigInt(creditsConfig?.minTopupLovelace ?? 2000000),
  );

  return reply.status(200).send({
    success: true,
    account: account ? accountToResponse(account) : null,
    paymentStrategies: strategies,
  });
}

// Without amount param: return original response (backward compatible)
return reply.status(200).send({
  success: true,
  account: account ? accountToResponse(account) : null,
});
```

This is purely additive. When `amount` is not provided, the response is identical to before.

**2. Update `src/credits/index.ts` barrel exports:**

Add strategy exports if not already present:
```typescript
// Strategy router and payment info
export { selectStrategy, buildPaymentStrategies } from './strategy.js';
export type { PaymentStrategy, StrategyDecision, PaymentStrategiesInfo } from './strategy.js';
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- compiles with no errors. Run `pnpm test` -- all tests pass. Verify GET /credits/balance with amount param returns paymentStrategies. Verify without amount param returns same response as before.
  </verify>
  <done>GET /credits/balance enriched with paymentStrategies when amount query param provided. Combined with Plan 03's /settle wiring, payment strategy info is now available in both failure responses and balance queries. Credits barrel updated.</done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end credit lifecycle integration tests</name>
  <files>tests/integration/credits-lifecycle.test.ts</files>
  <action>
Create `tests/integration/credits-lifecycle.test.ts` -- integration tests that validate the full credit lifecycle from top-up through micropayment settlement.

These tests mock the L1 settlement layer (settlePayment) but exercise the real credit ledger, strategy router, and route handlers together.

**Test setup:**
- Create a Fastify server with credits enabled and facilitator address set
- Mock `settlePayment` to return `{ success: true, transaction: 'tx_mock', network: 'cardano:preprod' }`
- Use the mock Redis pattern from Plan 06-01 tests (in-memory Map-based mock) for the credit ledger
- Alternatively, mock the CreditLedger directly on the Fastify instance

**Test cases:**

1. **Full lifecycle: topup -> balance -> micropayment -> balance**
   - POST /credits/topup with 5 ADA -> success, balance = "5000000"
   - GET /credits/balance?address=addr1... -> account.balanceLovelace = "5000000"
   - POST /settle with paymentStrategy: 'credit_deduction', payerAddress, amount 50000 -> success, remainingBalance = "4950000"
   - GET /credits/balance?address=addr1... -> account.balanceLovelace = "4950000"

2. **Multiple micropayments drain account**
   - Top up 2 ADA
   - Settle 500000 via credit -> success, remaining 1500000
   - Settle 500000 via credit -> success, remaining 1000000
   - Settle 1500000 via credit -> failure (insufficient_credits)
   - Balance unchanged at 1000000

3. **Strategy auto-selection**
   - Top up 3 ADA
   - POST /settle with amount 2000000 (above threshold), no explicit strategy -> uses direct_l1
   - POST /settle with amount 50000 (below threshold), no explicit strategy -> uses credit_deduction

4. **GET /credits/balance with amount param returns payment strategies**
   - Top up 2 ADA
   - GET /credits/balance?address=addr1&amount=50000 -> paymentStrategies.credit_deduction.available = true
   - GET /credits/balance?address=addr1&amount=5000000 -> paymentStrategies.credit_deduction.available = false, paymentStrategies.direct_l1.available = true

5. **Payment strategies in /settle failure response**
   - No credit account, amount below threshold
   - POST /settle with amount 50000 -> { success: false, reason: 'insufficient_credits', paymentStrategies: { credit_topup: { available: true, endpoint: '/credits/topup' } } }

6. **Credits disabled: all credit endpoints return credits_disabled**
   - POST /credits/topup -> { success: false, reason: 'credits_disabled' }
   - GET /credits/balance -> { success: false, reason: 'credits_disabled' }
   - POST /settle with credit_deduction -> falls through to L1 path

NOTE: These tests require careful mocking. Use vi.mock for settlePayment (L1 path) and either a mock Redis or mock CreditLedger. The key challenge is getting the Fastify server to initialize with the credit system wired in. Follow the existing integration test patterns from status-route.test.ts and settle-route.test.ts.
  </action>
  <verify>
Run `pnpm test -- tests/integration/credits-lifecycle.test.ts` -- all tests pass. Verify the full lifecycle test shows balance decreasing correctly after each micropayment. Verify strategy auto-selection routes below-threshold payments to credit_deduction.
  </verify>
  <done>End-to-end credit lifecycle integration tests validate: topup->balance->micropayment->balance, multiple micropayments, auto-strategy selection, payment strategies in balance and settle responses, and credits-disabled guard. Full credit system proven working.</done>
</task>

<task type="auto">
  <name>Task 3: Write L2 feasibility research document</name>
  <files>.planning/phases/06-micropayment-strategy/06-L2-FEASIBILITY.md</files>
  <action>
Write the L2 feasibility research document. This is a deliverable of Phase 6 per the roadmap: "L2 feasibility documented with recommendations for future phases."

Structure the document with these sections:

1. **Executive Summary** -- 3-sentence summary and recommendation
2. **Hydra (L2 State Channels)** -- Production v1.2.0, zero in-head fees, poor for one-shot payments, good for recurring pairs. Include Hydra Pay WebSocket API and SDK references. Recommend Phase 8+ for high-volume pairs.
3. **Midnight (Partner Chain)** -- Kukolu phase, NIGHT/DUST tokenomics, privacy features. Too early, fee economics unproven. Recommend monitor only, revisit late 2026.
4. **Dual-Rail (FluxPoint Model)** -- Base L2 for cheap payments + Cardano L1 for audit. Proven pattern. High effort (EVM integration). Recommend as future milestone if scope expands.
5. **Governance Watch: utxoCostPerByte Reduction** -- PCP proposal to reduce from 4,310 to 400. Would cut min UTXO to ~0.10 ADA. Under review, not ratified.
6. **Comparison Matrix** -- Table comparing all solutions on readiness, effort, min payment, recurring/one-shot fit
7. **Recommendations Timeline** -- Phase 6 (credits, done), Phase 8+ (Hydra), Future milestone (dual-rail), Late 2026+ (Midnight)

Source all details from the 06-RESEARCH.md and 06-pre-planning-assumptions.md documents. Keep it concise and actionable -- this is a decision-support document, not an academic paper.
  </action>
  <verify>
Verify the document exists and covers all four L2 alternatives (Hydra, Midnight, dual-rail, governance proposal). Verify recommendations are concrete with timelines. Verify sources are cited.
  </verify>
  <done>L2 feasibility document written: covers Hydra (Phase 8+ for recurring pairs), Midnight (monitor, revisit late 2026), dual-rail (future milestone), and governance proposal (watch). Comparison matrix and timeline included.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (all existing + all new tests)
- `npx tsc --noEmit` passes
- GET /credits/balance?address=X&amount=Y returns paymentStrategies object
- GET /credits/balance?address=X (no amount) returns original response (backward compatible)
- Full lifecycle test proves: topup -> balance -> micropayment -> reduced balance
- Multiple micropayments correctly drain credit balance
- Strategy auto-selection works: above threshold = L1, below = credit
- /settle insufficient_credits response includes paymentStrategies (from Plan 03)
- Credits disabled = all credit endpoints return credits_disabled
- L2 feasibility document covers Hydra, Midnight, dual-rail, and governance proposal
- L2 document has concrete recommendations with timelines
</verification>

<success_criteria>
Phase 6 is complete. Payment strategy info is available via GET /credits/balance (this plan) and in /settle failure responses (Plan 03). End-to-end lifecycle tests prove the credit system works from topup through micropayment settlement. L2 feasibility document provides clear recommendations for future phases. All 7 Phase 6 success criteria are met:
1. Payments below min UTXO via prepaid credits (Plans 01-03)
2. Payments above min UTXO via L1 unchanged (Plan 03 backward compat)
3. Credit accounts persistent via Redis (Plan 01)
4. Balance queryable via API (Plan 02)
5. Credit transaction history for audit trail (Plan 01 txlog)
6. Payment strategy info in API and settlement failures (Plans 03+04)
7. L2 feasibility documented (Plan 04)
</success_criteria>

<output>
After completion, create `.planning/phases/06-micropayment-strategy/06-04-SUMMARY.md`
</output>
