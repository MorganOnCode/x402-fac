---
phase: 08-resource-server-sdk
plan: 08-01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/sdk/types.ts
  - src/sdk/facilitator-client.ts
  - src/sdk/payment-required.ts
  - src/sdk/index.ts
autonomous: true

must_haves:
  truths:
    - "FacilitatorClient class makes HTTP calls to /verify, /settle, /status, /supported via native fetch"
    - "FacilitatorClient validates responses with Zod before returning"
    - "FacilitatorClient supports configurable timeout via AbortController"
    - "buildPaymentRequired() returns base64-encoded JSON matching x402 V2 format"
    - "reply402() sends HTTP 402 with Payment-Required header and empty body"
  artifacts:
    - path: "src/sdk/types.ts"
      provides: "SDK-specific Zod schemas: SupportedResponse, PaymentRequiredResponse, PaymentSignaturePayload"
      exports: ["SupportedResponseSchema", "SupportedPaymentKindSchema", "PaymentRequiredResponseSchema", "PaymentSignaturePayloadSchema", "SupportedResponse", "PaymentRequiredResponse", "PaymentSignaturePayload"]
    - path: "src/sdk/facilitator-client.ts"
      provides: "FacilitatorClient HTTP wrapper for facilitator API"
      exports: ["FacilitatorClient", "FacilitatorClientOptions"]
    - path: "src/sdk/payment-required.ts"
      provides: "402 response builder: buildPaymentRequired(), reply402()"
      exports: ["buildPaymentRequired", "reply402", "PaymentRequiredOptions"]
    - path: "src/sdk/index.ts"
      provides: "Barrel export for SDK module"
      exports: ["FacilitatorClient", "buildPaymentRequired", "reply402"]
  key_links:
    - from: "src/sdk/facilitator-client.ts"
      to: "src/verify/types.ts"
      via: "Imports VerifyRequestSchema, VerifyResponseSchema for type safety"
      pattern: "verify(), settle(), status(), supported()"
    - from: "src/sdk/facilitator-client.ts"
      to: "src/settle/types.ts"
      via: "Imports SettleRequestSchema, SettleResponseSchema"
      pattern: "settle(), status()"
    - from: "src/sdk/payment-required.ts"
      to: "src/sdk/types.ts"
      via: "Uses PaymentRequiredResponseSchema for building 402 responses"
      pattern: "buildPaymentRequired()"
---

<objective>
Build the SDK core: types, FacilitatorClient (HTTP wrapper), 402 response builder, and barrel export.

Purpose: Everything in Phase 8 depends on these foundations. The FacilitatorClient is how resource servers talk to the facilitator. The 402 builder is how resource servers tell clients what to pay.

Output: `src/sdk/` directory with types, client, builder, barrel; no tests yet (those are in 08-02).
</objective>

<context>
@src/verify/types.ts
@src/settle/types.ts
@src/chain/provider.ts
@src/routes/health.ts
@src/server.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SDK types and 402 response builder</name>
  <files>src/sdk/types.ts, src/sdk/payment-required.ts</files>
  <action>
Create `src/sdk/types.ts` with Zod schemas and TypeScript types for the SDK layer:

```typescript
// SDK-specific types and Zod schemas for x402 V2 wire format.
//
// These types define the structures that flow between client, resource server,
// and facilitator -- specifically the Payment-Required header (402 response),
// the Payment-Signature header (client payment), and the /supported response.

import { z } from 'zod';

// ---------------------------------------------------------------------------
// /supported response (PROT-03)
// ---------------------------------------------------------------------------

export const SupportedPaymentKindSchema = z.object({
  x402Version: z.number(),
  scheme: z.string(),
  network: z.string(),
  extra: z.record(z.string(), z.unknown()).optional(),
});

export const SupportedResponseSchema = z.object({
  kinds: z.array(SupportedPaymentKindSchema),
  extensions: z.array(z.unknown()),
  signers: z.record(z.string(), z.array(z.string())),
});

export type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;
export type SupportedResponse = z.infer<typeof SupportedResponseSchema>;

// ---------------------------------------------------------------------------
// Payment-Required header (402 response, resource server -> client)
// ---------------------------------------------------------------------------

/** A single accepted payment option in the 402 response */
export const PaymentAcceptSchema = z.object({
  scheme: z.string().default('exact'),
  network: z.string(),
  amount: z.string(),
  payTo: z.string(),
  maxTimeoutSeconds: z.number().int().positive().default(300),
  asset: z.string().default('lovelace'),
  extra: z.record(z.string(), z.unknown()).nullable().default(null),
});

export const ResourceInfoSchema = z.object({
  description: z.string(),
  mimeType: z.string().default('application/json'),
  url: z.string(),
});

export const PaymentRequiredResponseSchema = z.object({
  x402Version: z.literal(2),
  error: z.string().nullable().default(null),
  resource: ResourceInfoSchema,
  accepts: z.array(PaymentAcceptSchema),
});

export type PaymentAccept = z.infer<typeof PaymentAcceptSchema>;
export type ResourceInfo = z.infer<typeof ResourceInfoSchema>;
export type PaymentRequiredResponse = z.infer<typeof PaymentRequiredResponseSchema>;

// ---------------------------------------------------------------------------
// Payment-Signature header (client -> resource server)
// ---------------------------------------------------------------------------

export const CardanoPaymentPayloadSchema = z.object({
  transaction: z.string().min(1),
  payer: z.string().optional(),
});

export const PaymentSignaturePayloadSchema = z.object({
  x402Version: z.literal(2),
  accepted: PaymentAcceptSchema,
  payload: CardanoPaymentPayloadSchema,
  resource: ResourceInfoSchema,
});

export type PaymentSignaturePayload = z.infer<typeof PaymentSignaturePayloadSchema>;

// ---------------------------------------------------------------------------
// X-Payment-Response header (resource server -> client, after settlement)
// ---------------------------------------------------------------------------

export const PaymentResponseHeaderSchema = z.object({
  success: z.boolean(),
  transaction: z.string().optional(),
  network: z.string().optional(),
  reason: z.string().optional(),
});

export type PaymentResponseHeader = z.infer<typeof PaymentResponseHeaderSchema>;
```

Then create `src/sdk/payment-required.ts` -- helpers for building HTTP 402 Payment Required responses per the x402 V2 spec:

```typescript
// 402 Payment Required response builder for x402 V2.
//
// The resource server sends a 402 response with the Payment-Required header
// containing base64-encoded JSON that tells the client what payment is needed.

import type { FastifyReply } from 'fastify';

import type { PaymentRequiredResponse, PaymentAccept, ResourceInfo } from './types.js';

export interface PaymentRequiredOptions {
  /** CAIP-2 chain ID (e.g. "cardano:preview") */
  network: string;
  /** Amount in smallest unit as string (e.g. "2000000" for 2 ADA) */
  amount: string;
  /** Bech32 recipient address */
  payTo: string;
  /** Payment scheme (default: "exact") */
  scheme?: string;
  /** Asset identifier (default: "lovelace") */
  asset?: string;
  /** Max timeout in seconds (default: 300) */
  maxTimeoutSeconds?: number;
  /** Resource description for the client */
  description?: string;
  /** Resource MIME type (default: "application/json") */
  mimeType?: string;
  /** Resource URL */
  url?: string;
  /** Error message to include in the 402 response */
  error?: string | null;
}

/**
 * Build the base64-encoded Payment-Required header value.
 * This is the core function that constructs the x402 V2 402 response payload.
 */
export function buildPaymentRequired(options: PaymentRequiredOptions): string {
  const accept: PaymentAccept = {
    scheme: options.scheme ?? 'exact',
    network: options.network,
    amount: options.amount,
    payTo: options.payTo,
    maxTimeoutSeconds: options.maxTimeoutSeconds ?? 300,
    asset: options.asset ?? 'lovelace',
    extra: null,
  };

  const resource: ResourceInfo = {
    description: options.description ?? 'Payment required',
    mimeType: options.mimeType ?? 'application/json',
    url: options.url ?? '',
  };

  const response: PaymentRequiredResponse = {
    x402Version: 2,
    error: options.error ?? null,
    resource,
    accepts: [accept],
  };

  return Buffer.from(JSON.stringify(response)).toString('base64');
}

/**
 * Send an HTTP 402 Payment Required response with the Payment-Required header.
 *
 * Per x402 V2 spec: the payment requirements go in the header (base64),
 * and the body is empty.
 */
export function reply402(
  reply: FastifyReply,
  options: PaymentRequiredOptions
): void {
  const headerValue = buildPaymentRequired(options);
  void reply
    .status(402)
    .header('Payment-Required', headerValue)
    .send();
}
```

Key decisions:
- `PaymentAcceptSchema` uses `amount` (not `maxAmountRequired`) for the 402 response, matching x402 V2 spec wire format. The SDK maps `amount` to `maxAmountRequired` when calling the facilitator internally.
- `ResourceInfo` captures description, mimeType, URL per V2 spec.
- `PaymentSignaturePayloadSchema` models the base64-decoded value from the Payment-Signature header.
- `buildPaymentRequired()` is a pure function (testable without Fastify).
- `reply402()` wraps it for Fastify convenience.
  </action>
  <verify>
- `src/sdk/types.ts` exists and exports all listed schemas and types
- `src/sdk/payment-required.ts` exports `buildPaymentRequired()` and `reply402()`
- `pnpm typecheck` passes
  </verify>
  <done>SDK types and 402 response builder created.</done>
</task>

<task type="auto">
  <name>Task 2: Create FacilitatorClient</name>
  <files>src/sdk/facilitator-client.ts</files>
  <action>
Create `src/sdk/facilitator-client.ts` -- an HTTP client that resource servers use to communicate with the facilitator.

```typescript
// FacilitatorClient -- HTTP wrapper for the x402 facilitator API.
//
// Resource servers use this to call /verify, /settle, /status, and /supported.
// Uses native fetch (Node 20+) with AbortController timeout and Zod validation.

import { z } from 'zod';

import { SettleRequestSchema, SettleResponseSchema } from '../settle/types.js';
import type { SettleRequest, SettleResponse, StatusRequest, StatusResponse } from '../settle/types.js';
import { StatusRequestSchema, StatusResponseSchema } from '../settle/types.js';
import { VerifyRequestSchema, VerifyResponseSchema } from '../verify/types.js';
import type { VerifyRequest, VerifyResponse } from '../verify/types.js';
import { SupportedResponseSchema } from './types.js';
import type { SupportedResponse } from './types.js';

export interface FacilitatorClientOptions {
  /** Base URL of the facilitator (e.g. "http://localhost:3000") */
  baseUrl: string;
  /** Request timeout in milliseconds (default: 30000) */
  timeout?: number;
  /** Additional headers to send with every request */
  headers?: Record<string, string>;
}

export class FacilitatorClient {
  private readonly baseUrl: string;
  private readonly timeout: number;
  private readonly headers: Record<string, string>;

  constructor(options: FacilitatorClientOptions) {
    // Strip trailing slash for consistent URL building
    this.baseUrl = options.baseUrl.replace(/\/+$/, '');
    this.timeout = options.timeout ?? 30_000;
    this.headers = options.headers ?? {};
  }

  /**
   * Verify a payment against the facilitator.
   * POST /verify
   */
  async verify(request: VerifyRequest): Promise<VerifyResponse> {
    return this.post('/verify', request, VerifyResponseSchema);
  }

  /**
   * Settle a payment via the facilitator (submit tx on-chain).
   * POST /settle
   */
  async settle(request: SettleRequest): Promise<SettleResponse> {
    return this.post('/settle', request, SettleResponseSchema);
  }

  /**
   * Check transaction confirmation status.
   * POST /status
   */
  async status(request: StatusRequest): Promise<StatusResponse> {
    return this.post('/status', request, StatusResponseSchema);
  }

  /**
   * Get the facilitator's supported chains, schemes, and signer addresses.
   * GET /supported
   */
  async supported(): Promise<SupportedResponse> {
    return this.get('/supported', SupportedResponseSchema);
  }

  // ---- Private helpers ----

  private async post<T>(path: string, body: unknown, schema: z.ZodType<T>): Promise<T> {
    const url = `${this.baseUrl}${path}`;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...this.headers,
        },
        body: JSON.stringify(body),
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Facilitator returned ${response.status} ${response.statusText}`);
      }

      const json = await response.json();
      const parsed = schema.safeParse(json);
      if (!parsed.success) {
        throw new Error(`Invalid facilitator response: ${parsed.error.message}`);
      }

      return parsed.data;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error(`Facilitator request to ${path} timed out after ${this.timeout}ms`);
      }
      throw error;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  private async get<T>(path: string, schema: z.ZodType<T>): Promise<T> {
    const url = `${this.baseUrl}${path}`;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: { ...this.headers },
        signal: controller.signal,
      });

      if (!response.ok) {
        throw new Error(`Facilitator returned ${response.status} ${response.statusText}`);
      }

      const json = await response.json();
      const parsed = schema.safeParse(json);
      if (!parsed.success) {
        throw new Error(`Invalid facilitator response: ${parsed.error.message}`);
      }

      return parsed.data;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error(`Facilitator request to ${path} timed out after ${this.timeout}ms`);
      }
      throw error;
    } finally {
      clearTimeout(timeoutId);
    }
  }
}
```

Design decisions:
- Uses native `fetch()` (Node 20+) -- zero new dependencies.
- Zod validates every response before returning (defense against facilitator bugs or man-in-the-middle).
- AbortController for timeout (cleaner than socket timeout).
- Trailing slash stripped from baseUrl for consistent URL building.
- No retry logic in v1 -- keep it simple, add later if needed.
- Imports existing schemas from verify/types.ts and settle/types.ts for type reuse.
  </action>
  <verify>
- `src/sdk/facilitator-client.ts` exists and exports `FacilitatorClient` class
- Class has verify(), settle(), status(), supported() methods
- Each method validates response with Zod
- `pnpm typecheck` passes
  </verify>
  <done>FacilitatorClient created with verify/settle/status/supported methods, Zod validation, and AbortController timeout.</done>
</task>

<task type="auto">
  <name>Task 3: Create SDK barrel export</name>
  <files>src/sdk/index.ts</files>
  <action>
Create `src/sdk/index.ts` as a barrel export for the SDK module:

```typescript
// SDK barrel export -- public API for resource servers

export { FacilitatorClient } from './facilitator-client.js';
export type { FacilitatorClientOptions } from './facilitator-client.js';
export { buildPaymentRequired, reply402 } from './payment-required.js';
export type { PaymentRequiredOptions } from './payment-required.js';
export type {
  SupportedResponse,
  SupportedPaymentKind,
  PaymentRequiredResponse,
  PaymentAccept,
  ResourceInfo,
  PaymentSignaturePayload,
  PaymentResponseHeader,
} from './types.js';
export {
  SupportedResponseSchema,
  SupportedPaymentKindSchema,
  PaymentRequiredResponseSchema,
  PaymentAcceptSchema,
  ResourceInfoSchema,
  PaymentSignaturePayloadSchema,
  PaymentResponseHeaderSchema,
} from './types.js';
```

Then verify all files compile:
- `pnpm typecheck` passes
- `pnpm lint` passes
  </action>
  <verify>
- `src/sdk/index.ts` exists
- All public APIs from the SDK are exported
- `pnpm typecheck` passes
- `pnpm lint` passes
  </verify>
  <done>SDK barrel export created. Plan 08-01 complete.</done>
</task>

</tasks>

<verification>
- `src/sdk/` directory exists with 4 files: types.ts, facilitator-client.ts, payment-required.ts, index.ts
- `pnpm typecheck` passes
- `pnpm lint` passes
- FacilitatorClient validates responses with Zod
- buildPaymentRequired() returns valid base64-encoded x402 V2 JSON
</verification>

<success_criteria>
The SDK core is functional: FacilitatorClient can call /verify, /settle, /status, /supported with type-safe responses. The 402 builder produces correct V2 format headers. All code compiles. Ready for Plan 08-02 (tests + /supported route).
</success_criteria>

<output>
After completion, create `.planning/phases/08-resource-server-sdk/08-01-SUMMARY.md`
</output>
