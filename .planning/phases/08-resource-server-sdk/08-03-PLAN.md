---
phase: 08-resource-server-sdk
plan: 08-03
type: execute
wave: 2
depends_on:
  - 08-01
files_modified:
  - src/storage/types.ts
  - src/storage/fs-backend.ts
  - src/storage/ipfs-backend.ts
  - src/storage/index.ts
  - src/config/schema.ts
  - config/config.example.json
  - tests/unit/storage/fs-backend.test.ts
  - tests/unit/storage/ipfs-backend.test.ts
autonomous: true

must_haves:
  truths:
    - "StorageBackend interface defines put(), get(), has(), healthy() methods"
    - "FsBackend implements StorageBackend using filesystem with SHA-256 content addressing"
    - "FsBackend sanitizes CID input to prevent path traversal attacks"
    - "IpfsBackend implements StorageBackend using IPFS Kubo HTTP API"
    - "Config schema extended with storage section (backend, fs, ipfs options)"
    - "Storage factory creates correct backend based on config"
  artifacts:
    - path: "src/storage/types.ts"
      provides: "StorageBackend abstract interface"
      exports: ["StorageBackend"]
    - path: "src/storage/fs-backend.ts"
      provides: "Filesystem-based StorageBackend implementation"
      exports: ["FsBackend"]
    - path: "src/storage/ipfs-backend.ts"
      provides: "IPFS Kubo-based StorageBackend implementation"
      exports: ["IpfsBackend"]
    - path: "src/storage/index.ts"
      provides: "Storage barrel export with factory function"
      exports: ["createStorageBackend", "StorageBackend", "FsBackend", "IpfsBackend"]
  key_links:
    - from: "src/storage/fs-backend.ts"
      to: "src/storage/types.ts"
      via: "Implements StorageBackend interface"
      pattern: "class FsBackend implements StorageBackend"
    - from: "src/storage/ipfs-backend.ts"
      to: "src/storage/types.ts"
      via: "Implements StorageBackend interface"
      pattern: "class IpfsBackend implements StorageBackend"
    - from: "src/config/schema.ts"
      to: "src/storage/index.ts"
      via: "Storage config section drives backend selection"
      pattern: "storage.backend === 'fs' | 'ipfs'"
---

<objective>
Build the storage layer: StorageBackend interface, FsBackend, IpfsBackend, factory function, config extension, and tests.

Purpose: The storage layer provides an abstract backend for file persistence. The pay-to-upload, free-download model requires content-addressed storage. Both backends are built now so the reference implementation (08-05) can use either.

Output: `src/storage/` directory with types + 2 backends + factory; config schema extension; ~13 tests.
</objective>

<context>
@src/config/schema.ts
@config/config.example.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StorageBackend interface, FsBackend, and IpfsBackend</name>
  <files>src/storage/types.ts, src/storage/fs-backend.ts, src/storage/ipfs-backend.ts</files>
  <action>
Create `src/storage/types.ts` with the abstract storage interface:

```typescript
// Abstract storage backend interface.
//
// Implementations provide content-addressed storage (put returns a CID/hash,
// get retrieves by CID/hash). The interface is intentionally minimal to
// support filesystem, IPFS, S3, or any other backend.

/**
 * Abstract storage backend for file persistence.
 * Implementations must be content-addressed: put() returns a unique identifier,
 * get() retrieves by that identifier.
 */
export interface StorageBackend {
  /** Store data and return a content identifier (hash or CID) */
  put(data: Buffer, metadata?: Record<string, string>): Promise<string>;

  /** Retrieve data by content identifier, or null if not found */
  get(cid: string): Promise<Buffer | null>;

  /** Check if content exists by identifier */
  has(cid: string): Promise<boolean>;

  /** Health check -- returns true if the backend is operational */
  healthy(): Promise<boolean>;
}
```

Create `src/storage/fs-backend.ts` -- a filesystem-based StorageBackend using SHA-256 content addressing:

```typescript
// Filesystem storage backend.
//
// Stores files on the local filesystem using SHA-256 hash as filename.
// Content-addressed: the same file data always produces the same hash.
// Simple, zero-dependency, works without Docker.

import { createHash } from 'node:crypto';
import { access, mkdir, readFile, writeFile } from 'node:fs/promises';
import { join } from 'node:path';

import type { StorageBackend } from './types.js';

export class FsBackend implements StorageBackend {
  private readonly dataDir: string;
  private initialized = false;

  constructor(dataDir: string) {
    this.dataDir = dataDir;
  }

  async put(data: Buffer): Promise<string> {
    await this.ensureDir();
    const hash = createHash('sha256').update(data).digest('hex');
    const filePath = join(this.dataDir, hash);
    await writeFile(filePath, data);
    return hash;
  }

  async get(cid: string): Promise<Buffer | null> {
    // Sanitize: only allow hex characters (SHA-256 hash)
    if (!/^[a-f0-9]{64}$/.test(cid)) {
      return null;
    }

    const filePath = join(this.dataDir, cid);
    try {
      return await readFile(filePath);
    } catch {
      return null;
    }
  }

  async has(cid: string): Promise<boolean> {
    if (!/^[a-f0-9]{64}$/.test(cid)) {
      return false;
    }

    const filePath = join(this.dataDir, cid);
    try {
      await access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  async healthy(): Promise<boolean> {
    try {
      await this.ensureDir();
      return true;
    } catch {
      return false;
    }
  }

  private async ensureDir(): Promise<void> {
    if (this.initialized) return;
    await mkdir(this.dataDir, { recursive: true });
    this.initialized = true;
  }
}
```

Create `src/storage/ipfs-backend.ts` -- an IPFS-based StorageBackend using the Kubo HTTP API:

```typescript
// IPFS storage backend using Kubo HTTP API.
//
// Connects to a local IPFS node (Kubo) via its HTTP API (default port 5001).
// Uses native fetch -- no IPFS client library needed.

import type { StorageBackend } from './types.js';

export class IpfsBackend implements StorageBackend {
  private readonly apiUrl: string;

  constructor(apiUrl = 'http://localhost:5001') {
    // Strip trailing slash
    this.apiUrl = apiUrl.replace(/\/+$/, '');
  }

  async put(data: Buffer): Promise<string> {
    // Kubo API: POST /api/v0/add
    // Expects multipart/form-data with the file data
    const formData = new FormData();
    formData.append('file', new Blob([data]));

    const response = await fetch(`${this.apiUrl}/api/v0/add`, {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error(`IPFS add failed: ${response.status} ${response.statusText}`);
    }

    const result = (await response.json()) as { Hash: string; Size: string };
    return result.Hash;
  }

  async get(cid: string): Promise<Buffer | null> {
    // Kubo API: POST /api/v0/cat?arg={cid}
    try {
      const response = await fetch(
        `${this.apiUrl}/api/v0/cat?arg=${encodeURIComponent(cid)}`,
        { method: 'POST' }
      );

      if (!response.ok) {
        return null;
      }

      const arrayBuffer = await response.arrayBuffer();
      return Buffer.from(arrayBuffer);
    } catch {
      return null;
    }
  }

  async has(cid: string): Promise<boolean> {
    // Kubo API: POST /api/v0/object/stat?arg={cid}
    try {
      const response = await fetch(
        `${this.apiUrl}/api/v0/object/stat?arg=${encodeURIComponent(cid)}`,
        { method: 'POST' }
      );
      return response.ok;
    } catch {
      return false;
    }
  }

  async healthy(): Promise<boolean> {
    // Kubo API: POST /api/v0/id
    try {
      const response = await fetch(`${this.apiUrl}/api/v0/id`, {
        method: 'POST',
      });
      return response.ok;
    } catch {
      return false;
    }
  }
}
```

Security considerations:
- FsBackend `get()` and `has()` sanitize the CID to only allow 64 hex characters. This prevents path traversal attacks.
- IpfsBackend uses `encodeURIComponent()` on CID for query parameter safety.
  </action>
  <verify>
- `src/storage/types.ts` exists and exports `StorageBackend` interface
- `src/storage/fs-backend.ts` exists and exports `FsBackend`
- `src/storage/ipfs-backend.ts` exists and exports `IpfsBackend`
- FsBackend `get()` sanitizes CID input (path traversal protection)
- `pnpm typecheck` passes
  </verify>
  <done>StorageBackend interface, FsBackend, and IpfsBackend created.</done>
</task>

<task type="auto">
  <name>Task 2: Create storage barrel + factory and extend config schema</name>
  <files>src/storage/index.ts, src/config/schema.ts, config/config.example.json</files>
  <action>
Create `src/storage/index.ts` with a factory function and barrel exports:

```typescript
// Storage module barrel export and factory function.

import { FsBackend } from './fs-backend.js';
import { IpfsBackend } from './ipfs-backend.js';
import type { StorageBackend } from './types.js';

export type { StorageBackend } from './types.js';
export { FsBackend } from './fs-backend.js';
export { IpfsBackend } from './ipfs-backend.js';

export interface StorageConfig {
  backend: 'fs' | 'ipfs';
  fs?: { dataDir: string };
  ipfs?: { apiUrl: string };
}

/**
 * Create a storage backend based on configuration.
 * Defaults to FsBackend with './data/files' if no config is provided.
 */
export function createStorageBackend(config: StorageConfig): StorageBackend {
  switch (config.backend) {
    case 'ipfs':
      return new IpfsBackend(config.ipfs?.apiUrl);
    case 'fs':
    default:
      return new FsBackend(config.fs?.dataDir ?? './data/files');
  }
}
```

Then extend the config schema in `src/config/schema.ts` to include a storage section. Add a `storage` field to the ConfigSchema:

```typescript
// Add inside ConfigSchema z.object({...}), after the `chain` field:

// Storage backend configuration (optional -- defaults to filesystem)
storage: z
  .object({
    /** Storage backend type */
    backend: z.enum(['fs', 'ipfs']).default('fs'),
    /** Filesystem backend options */
    fs: z
      .object({
        /** Directory for stored files (default: ./data/files) */
        dataDir: z.string().default('./data/files'),
      })
      .default(() => ({ dataDir: './data/files' })),
    /** IPFS backend options */
    ipfs: z
      .object({
        /** IPFS Kubo HTTP API URL (default: http://localhost:5001) */
        apiUrl: z.string().url().default('http://localhost:5001'),
      })
      .default(() => ({ apiUrl: 'http://localhost:5001' })),
  })
  .default(() => ({
    backend: 'fs' as const,
    fs: { dataDir: './data/files' },
    ipfs: { apiUrl: 'http://localhost:5001' },
  })),
```

The entire storage section is optional with defaults -- existing configs continue to work unchanged.

Update `config/config.example.json` to include the storage section after the `chain` section:

```json
"storage": {
  "backend": "fs",
  "fs": {
    "dataDir": "./data/files"
  },
  "ipfs": {
    "apiUrl": "http://localhost:5001"
  }
}
```
  </action>
  <verify>
- `src/storage/index.ts` exports createStorageBackend, StorageBackend, FsBackend, IpfsBackend
- Config schema has `storage` field with defaults (backward compatible)
- `config/config.example.json` includes storage section
- `pnpm typecheck` passes
- Existing config tests still pass
  </verify>
  <done>Storage barrel, factory, and config extension created.</done>
</task>

<task type="auto">
  <name>Task 3: Write storage backend unit tests and verify all</name>
  <files>tests/unit/storage/fs-backend.test.ts, tests/unit/storage/ipfs-backend.test.ts</files>
  <action>
Create `tests/unit/storage/fs-backend.test.ts` with unit tests for the filesystem backend.

**Strategy:** Use a temporary directory (Node's `os.tmpdir()` + random suffix) for each test, cleaned up in afterEach.

**Test categories** (~8 tests):

1. **put()** (~2 tests):
   - Returns a 64-character hex string (SHA-256 hash)
   - Same data returns same hash (content-addressed)

2. **get()** (~3 tests):
   - Returns stored data correctly (put then get)
   - Returns null for non-existent CID
   - Returns null for invalid CID format (path traversal protection: `../../../etc/passwd`)

3. **has()** (~2 tests):
   - Returns true for stored content
   - Returns false for non-existent CID

4. **healthy()** (~1 test):
   - Returns true when data directory is accessible

Pattern:
```typescript
import { mkdtemp, rm } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import { join } from 'node:path';

let testDir: string;

beforeEach(async () => {
  testDir = await mkdtemp(join(tmpdir(), 'x402-fs-test-'));
});

afterEach(async () => {
  await rm(testDir, { recursive: true, force: true });
});
```

Create `tests/unit/storage/ipfs-backend.test.ts` with unit tests for the IPFS backend.

**Mock strategy:** Use `vi.spyOn(globalThis, 'fetch')` to mock the Kubo HTTP API calls.

**Test categories** (~5 tests):

1. **put()** (~2 tests):
   - Calls POST /api/v0/add and returns the Hash from the response
   - Throws when IPFS returns non-200

2. **get()** (~1 test):
   - Calls POST /api/v0/cat and returns Buffer from response
   - Returns null when IPFS returns non-200

3. **has()** (~1 test):
   - Returns true when /api/v0/object/stat returns 200
   - Returns false when it returns non-200

4. **healthy()** (~1 test):
   - Returns true when /api/v0/id returns 200
   - Returns false when fetch throws

Then run verification:
- `pnpm typecheck` passes
- `pnpm lint` passes
- `pnpm vitest run tests/unit/storage/` passes
  </action>
  <verify>
- Test files exist at `tests/unit/storage/fs-backend.test.ts` and `tests/unit/storage/ipfs-backend.test.ts`
- All tests pass: `pnpm vitest run tests/unit/storage/`
- FsBackend path traversal test passes
- `pnpm typecheck` exits 0
- `pnpm lint` exits 0
  </verify>
  <done>Storage backend tests complete. Plan 08-03 complete.</done>
</task>

</tasks>

<verification>
- `src/storage/` directory has types.ts, fs-backend.ts, ipfs-backend.ts, index.ts
- `src/config/schema.ts` has storage section with defaults
- FsBackend sanitizes CID input (path traversal protection)
- All ~13 new tests pass
- `pnpm typecheck` and `pnpm lint` pass
</verification>

<success_criteria>
The storage layer is functional: FsBackend stores files with SHA-256 hashing, IpfsBackend wraps Kubo API. Config schema supports storage backend selection. All building blocks ready for Plan 08-05 (upload/download routes).
</success_criteria>

<output>
After completion, create `.planning/phases/08-resource-server-sdk/08-03-SUMMARY.md`
</output>
