---
phase: 08-resource-server-sdk
plan: 08-05
type: execute
wave: 3
depends_on:
  - 08-02
  - 08-03
  - 08-04
files_modified:
  - src/routes/upload.ts
  - src/routes/download.ts
  - src/server.ts
  - src/routes/health.ts
  - package.json
  - pnpm-lock.yaml
  - tests/integration/upload-route.test.ts
  - tests/integration/download-route.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /upload is protected by payment gate middleware -- returns 402 without payment (STOR-01)"
    - "POST /upload stores file AFTER settlement confirmation (SECU-04 settle-then-work)"
    - "POST /upload returns content identifier (hash/CID) on success (STOR-02)"
    - "GET /files/:cid serves files freely without payment required (STOR-03)"
    - "GET /files/:cid returns 404 for non-existent content"
    - "POST /upload accepts multipart/form-data via @fastify/multipart"
    - "Upload route has a configurable body size limit (10MB default, not the global 50KB)"
    - "Health check includes storage backend status"
    - "X-Payment-Response header is set on successful upload response"
    - "Storage backend is initialized at server startup and decorated on Fastify instance"
  artifacts:
    - path: "src/routes/upload.ts"
      provides: "POST /upload route with payment gate and file storage"
      exports: ["uploadRoutesPlugin"]
    - path: "src/routes/download.ts"
      provides: "GET /files/:cid route for free file downloads"
      exports: ["downloadRoutesPlugin"]
  key_links:
    - from: "src/routes/upload.ts"
      to: "src/sdk/payment-gate.ts"
      via: "Uses createPaymentGate() as preHandler"
      pattern: "preHandler: [paymentGate]"
    - from: "src/routes/upload.ts"
      to: "src/storage/types.ts"
      via: "Calls fastify.storage.put() to store file data"
      pattern: "fastify.storage.put(data)"
    - from: "src/routes/download.ts"
      to: "src/storage/types.ts"
      via: "Calls fastify.storage.get() and fastify.storage.has() to retrieve files"
      pattern: "fastify.storage.get(cid)"
    - from: "src/server.ts"
      to: "src/storage/index.ts"
      via: "Creates storage backend at startup and decorates server"
      pattern: "createStorageBackend(config.storage)"
    - from: "src/server.ts"
      to: "src/routes/upload.ts"
      via: "Registers upload routes plugin"
      pattern: "server.register(uploadRoutesPlugin)"
    - from: "src/server.ts"
      to: "src/routes/download.ts"
      via: "Registers download routes plugin"
      pattern: "server.register(downloadRoutesPlugin)"
---

<objective>
Build the reference implementation routes: POST /upload (payment-gated file storage) and GET /files/:cid (free file downloads). Wire storage and new routes into the server. Update health check.

Purpose: This brings the full x402 payment flow to life. A client hits /upload, gets a 402, pays, and the file is stored after on-chain settlement. Anyone can then download the file for free by CID. This satisfies STOR-01, STOR-02, STOR-03, and SECU-04.

Output: `src/routes/upload.ts`, `src/routes/download.ts`, server integration, @fastify/multipart dependency; ~20 tests.
</objective>

<context>
@src/sdk/payment-gate.ts
@src/sdk/facilitator-client.ts
@src/sdk/payment-required.ts
@src/sdk/types.ts
@src/storage/index.ts
@src/storage/types.ts
@src/server.ts
@src/routes/health.ts
@src/config/schema.ts
@src/types/index.ts
@tests/integration/verify-route.test.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @fastify/multipart and create upload + download routes</name>
  <files>package.json, pnpm-lock.yaml, src/routes/upload.ts, src/routes/download.ts</files>
  <action>
Install `@fastify/multipart` as a production dependency:

```bash
pnpm add @fastify/multipart
```

Create `src/routes/upload.ts` -- the payment-gated file upload route:

```typescript
// POST /upload route -- payment-gated file storage (reference implementation).
//
// Flow: client sends multipart file -> payment gate verifies/settles ->
// file stored to backend -> CID returned.
//
// Requirements: STOR-01 (gated upload), STOR-02 (returns CID), SECU-04 (settle-then-work)

import type { FastifyPluginCallback } from 'fastify';
import fp from 'fastify-plugin';

import type { CardanoNetwork } from '../chain/types.js';
import { FacilitatorClient } from '../sdk/facilitator-client.js';
import { createPaymentGate } from '../sdk/payment-gate.js';
import { CAIP2_CHAIN_IDS } from '../verify/types.js';

const UPLOAD_BODY_LIMIT = 10 * 1024 * 1024; // 10MB

const uploadRoutes: FastifyPluginCallback = (fastify, _options, done) => {
  // Create FacilitatorClient pointing to ourselves (same-process facilitator)
  const facilitatorBaseUrl = `http://${fastify.config.server.host === '0.0.0.0' ? '127.0.0.1' : fastify.config.server.host}:${fastify.config.server.port}`;
  const facilitator = new FacilitatorClient({ baseUrl: facilitatorBaseUrl });

  const chainConfig = fastify.config.chain;
  const network = CAIP2_CHAIN_IDS[chainConfig.network as CardanoNetwork];

  // TODO: Make upload price configurable in config.json. Fixed at 2 ADA for v1.
  const uploadPrice = '2000000'; // 2 ADA in lovelace

  // Create payment gate for the upload route
  // The facilitator address will be resolved asynchronously on first request
  let paymentGateHandler: ReturnType<typeof createPaymentGate> | null = null;
  let facilitatorAddress: string | null = null;

  const ensurePaymentGate = async (): Promise<ReturnType<typeof createPaymentGate>> => {
    if (paymentGateHandler) return paymentGateHandler;

    facilitatorAddress = await fastify.chainProvider.getAddress();
    paymentGateHandler = createPaymentGate({
      facilitator,
      payTo: facilitatorAddress,
      amount: uploadPrice,
      network,
      description: 'File upload to x402 storage',
      mimeType: 'application/octet-stream',
    });

    return paymentGateHandler;
  };

  fastify.post(
    '/upload',
    {
      config: {
        rateLimit: {
          max: fastify.config.rateLimit.sensitive,
          timeWindow: fastify.config.rateLimit.windowMs,
        },
      },
      bodyLimit: UPLOAD_BODY_LIMIT,
    },
    async (request, reply) => {
      // 1. Run payment gate (settle-before-execution per SECU-04)
      const gate = await ensurePaymentGate();
      await gate(request, reply);

      // If the payment gate sent a reply (402 or error), stop here
      if (reply.sent) {
        return;
      }

      // 2. Parse multipart file upload
      let fileData: Buffer;
      try {
        const data = await request.file();
        if (!data) {
          return reply.status(400).send({
            error: 'Bad Request',
            message: 'No file provided. Send a multipart/form-data request with a "file" field.',
          });
        }
        fileData = await data.toBuffer();
      } catch (error) {
        fastify.log.error(
          { err: error instanceof Error ? error.message : 'Unknown error' },
          'File upload parsing failed'
        );
        return reply.status(400).send({
          error: 'Bad Request',
          message: 'Failed to parse file upload',
        });
      }

      // 3. Store file (after settlement is confirmed -- SECU-04)
      try {
        const cid = await fastify.storage.put(fileData);

        fastify.log.info(
          { cid, size: fileData.length },
          'File stored successfully'
        );

        return reply.status(200).send({
          success: true,
          cid,
          size: fileData.length,
        });
      } catch (error) {
        fastify.log.error(
          { err: error instanceof Error ? error.message : 'Unknown error' },
          'File storage failed'
        );
        return reply.status(500).send({
          error: 'Internal Server Error',
          message: 'Failed to store file',
        });
      }
    }
  );

  done();
};

export const uploadRoutesPlugin = fp(uploadRoutes, {
  name: 'upload-routes',
  fastify: '5.x',
});
```

Create `src/routes/download.ts` -- the free file download route:

```typescript
// GET /files/:cid route -- free file downloads (no payment required).
//
// Serves files by content identifier (hash or CID). No payment gate.
// Requirement: STOR-03 (serves files freely by content ID)

import type { FastifyPluginCallback } from 'fastify';
import fp from 'fastify-plugin';

interface DownloadParams {
  cid: string;
}

const downloadRoutes: FastifyPluginCallback = (fastify, _options, done) => {
  fastify.get<{ Params: DownloadParams }>(
    '/files/:cid',
    async (request, reply) => {
      const { cid } = request.params;

      // 1. Validate CID format (basic check -- backends do their own validation too)
      if (!cid || cid.length === 0) {
        return reply.status(400).send({
          error: 'Bad Request',
          message: 'Content identifier is required',
        });
      }

      // 2. Check if content exists
      const exists = await fastify.storage.has(cid);
      if (!exists) {
        return reply.status(404).send({
          error: 'Not Found',
          message: 'Content not found',
        });
      }

      // 3. Retrieve content
      try {
        const data = await fastify.storage.get(cid);
        if (!data) {
          return reply.status(404).send({
            error: 'Not Found',
            message: 'Content not found',
          });
        }

        return reply
          .status(200)
          .header('Content-Type', 'application/octet-stream')
          .header('Content-Length', data.length.toString())
          .send(data);
      } catch (error) {
        fastify.log.error(
          { err: error instanceof Error ? error.message : 'Unknown error', cid },
          'File retrieval failed'
        );
        return reply.status(500).send({
          error: 'Internal Server Error',
          message: 'Failed to retrieve file',
        });
      }
    }
  );

  done();
};

export const downloadRoutesPlugin = fp(downloadRoutes, {
  name: 'download-routes',
  fastify: '5.x',
});
```

Key design decisions:
- **Body limit**: 10MB per upload (overrides the global 50KB limit).
- **Settle-before-execution (SECU-04)**: Payment gate runs BEFORE file parsing.
- **FacilitatorClient to localhost**: Even though facilitator is same process, HTTP calls validate full network path.
- **Lazy payment gate initialization**: Facilitator address resolved on first request (async).
- **No payment gate on downloads**: Free downloads per STOR-03.
  </action>
  <verify>
- `@fastify/multipart` in package.json dependencies
- `src/routes/upload.ts` exists with payment gate + multipart + storage
- `src/routes/download.ts` exists with free downloads
- `pnpm typecheck` passes
  </verify>
  <done>Upload and download routes created with @fastify/multipart.</done>
</task>

<task type="auto">
  <name>Task 2: Wire storage + routes into server and update health check</name>
  <files>src/server.ts, src/routes/health.ts</files>
  <action>
Update `src/server.ts` to:

1. Import new dependencies:
```typescript
import multipart from '@fastify/multipart';
import { createStorageBackend } from './storage/index.js';
import { downloadRoutesPlugin } from './routes/download.js';
import { uploadRoutesPlugin } from './routes/upload.js';
```

2. Register @fastify/multipart plugin (after CORS, before routes):
```typescript
await server.register(multipart);
```

3. Initialize storage backend (after chain layer initialization, before routes):
```typescript
const storage = createStorageBackend(config.storage);
server.decorate('storage', storage);
server.log.info({ backend: config.storage.backend }, 'Storage layer initialized');
```

4. Register new routes (after existing route registrations):
```typescript
await server.register(uploadRoutesPlugin);
await server.register(downloadRoutesPlugin);
```

5. Add x402 headers to CORS:
```typescript
allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID', 'Payment-Signature', 'Payment-Required'],
exposedHeaders: ['Payment-Required', 'X-Payment-Response'],
```

Update `src/routes/health.ts` to include storage health:

Replace the `checkIpfs()` function with a `checkStorage()` function that uses `fastify.storage.healthy()`. Update the health route to call `checkStorage(fastify.storage)` and report `storage` in the dependencies object (not `ipfs`).

Add import:
```typescript
import type { StorageBackend } from '../storage/types.js';
```
  </action>
  <verify>
- `src/server.ts` registers multipart, upload, download plugins
- Storage backend created from config and decorated on server
- CORS headers include Payment-Signature and x402 response headers
- Health endpoint checks storage backend health
- `pnpm typecheck` passes
  </verify>
  <done>Server wired with storage, multipart, upload/download routes, and health check updated.</done>
</task>

<task type="auto">
  <name>Task 3: Write integration tests and verify all</name>
  <files>tests/integration/upload-route.test.ts, tests/integration/download-route.test.ts</files>
  <action>
Create `tests/integration/upload-route.test.ts` following the established integration test pattern.

**Test categories** (~10 tests):

1. **No payment (402 flow)** (~3 tests):
   - POST /upload without Payment-Signature header returns 402
   - Response has Payment-Required header
   - Payment-Required header decodes to valid x402 V2 JSON

2. **Successful upload** (~3 tests):
   - Valid payment + file -> returns 200 with cid and size
   - X-Payment-Response header present on success
   - File data is stored (mock storage.put called with correct data)

3. **Error handling** (~2 tests):
   - Missing file in multipart request returns 400
   - Storage backend failure returns 500

4. **Invalid payment** (~2 tests):
   - Invalid base64 in Payment-Signature returns 402
   - Payment that fails verification returns 402

**Mock strategy:** Mock the payment gate middleware (tested in 08-04 already).

Create `tests/integration/download-route.test.ts`:

**Test categories** (~6 tests):

1. **Successful download** (~2 tests):
   - GET /files/:cid returns 200 with file data
   - Response Content-Type is application/octet-stream

2. **Not found** (~2 tests):
   - GET /files/:cid for non-existent content returns 404
   - Response body has error: "Not Found"

3. **Edge cases** (~2 tests):
   - Storage backend error returns 500
   - No payment required for downloads (no 402 even without headers)

Also update existing health tests if needed (ipfs -> storage rename).

Then run full verification:
1. `pnpm typecheck` -- ensure no type errors
2. `pnpm lint` -- ensure no lint violations
3. `pnpm vitest run` -- ensure all tests pass
  </action>
  <verify>
- Test files exist at `tests/integration/upload-route.test.ts` and `tests/integration/download-route.test.ts`
- All tests pass: `pnpm vitest run tests/integration/`
- `pnpm typecheck` exits 0
- `pnpm lint` exits 0
- `pnpm vitest run` exits 0 with all tests passing
  </verify>
  <done>All tests pass, typecheck clean, lint clean. Plan 08-05 complete.</done>
</task>

</tasks>

<verification>
- POST /upload returns 402 when no payment provided (STOR-01)
- POST /upload stores file and returns CID after settlement (STOR-02, SECU-04)
- GET /files/:cid serves files without payment (STOR-03)
- GET /files/:cid returns 404 for non-existent content
- @fastify/multipart is installed and registered
- Storage backend initialized at server startup
- Health check includes storage status
- CORS headers include x402 payment headers
- All ~20 new tests pass
- `pnpm typecheck` and `pnpm lint` pass
</verification>

<success_criteria>
The reference implementation is functional: POST /upload is payment-gated with settle-before-execution, stores files, and returns CIDs. GET /files/:cid serves files freely. The complete x402 flow works through the server. All requirements (STOR-01, STOR-02, STOR-03, SECU-04) are satisfied. Ready for Plan 08-06 (example client).
</success_criteria>

<output>
After completion, create `.planning/phases/08-resource-server-sdk/08-05-SUMMARY.md`
</output>
