---
phase: 04-settlement
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - src/routes/settle.ts
  - src/routes/status.ts
  - src/server.ts
  - tests/integration/routes/settle.test.ts
  - tests/integration/routes/status.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /settle accepts a signed CBOR transaction and returns settlement result"
    - "POST /settle always returns HTTP 200 with application-level success/failure"
    - "POST /settle success response includes transaction hash and network (CAIP-2)"
    - "POST /status accepts a tx hash and returns confirmation status"
    - "POST /status always returns HTTP 200"
    - "Both routes handle invalid request bodies gracefully (Zod validation)"
    - "Routes are registered in the Fastify server alongside /health and /verify"
  artifacts:
    - path: "src/routes/settle.ts"
      provides: "POST /settle route plugin"
      exports: ["settleRoutesPlugin"]
    - path: "src/routes/status.ts"
      provides: "POST /status route plugin"
      exports: ["statusRoutesPlugin"]
    - path: "src/server.ts"
      provides: "Server with settle and status routes registered"
      contains: "settleRoutesPlugin"
    - path: "tests/integration/routes/settle.test.ts"
      provides: "Integration tests for POST /settle"
      min_lines: 50
    - path: "tests/integration/routes/status.test.ts"
      provides: "Integration tests for POST /status"
      min_lines: 30
  key_links:
    - from: "src/routes/settle.ts"
      to: "src/settle/settle-payment.ts"
      via: "settlePayment() call in route handler"
      pattern: "settlePayment"
    - from: "src/routes/settle.ts"
      to: "src/settle/types.ts"
      via: "SettleRequestSchema for Zod validation"
      pattern: "SettleRequestSchema\\.safeParse"
    - from: "src/routes/status.ts"
      to: "src/chain/blockfrost-client.ts"
      via: "getTransaction() for lightweight status check"
      pattern: "getTransaction"
    - from: "src/server.ts"
      to: "src/routes/settle.ts"
      via: "Plugin registration"
      pattern: "settleRoutesPlugin"
---

<objective>
Create POST /settle and POST /status route plugins, wire them into the Fastify server, and add integration tests.

Purpose: Expose the settlement orchestrator (Plan 02) and status check via HTTP endpoints, completing the Phase 4 feature set. These routes follow the exact same pattern as the existing POST /verify route: fastify-plugin wrapper, Zod safeParse, HTTP 200 always.

Output: `src/routes/settle.ts`, `src/routes/status.ts`, updated `src/server.ts`, integration tests
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-settlement/04-CONTEXT.md
@.planning/phases/04-settlement/04-01-SUMMARY.md
@.planning/phases/04-settlement/04-02-SUMMARY.md
@src/routes/verify.ts
@src/server.ts
@src/settle/types.ts
@src/settle/settle-payment.ts
@src/types/index.ts
@tests/integration/routes/verify.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /settle and POST /status route plugins</name>
  <files>src/routes/settle.ts, src/routes/status.ts</files>
  <action>
**1. Create `src/routes/settle.ts`:**

Follow the exact pattern from `src/routes/verify.ts`: fastify-plugin wrapper, Zod safeParse validation, HTTP 200 always.

```typescript
import type { FastifyPluginCallback } from 'fastify';
import fp from 'fastify-plugin';

import type { CardanoNetwork } from '../chain/types.js';
import { SettleRequestSchema } from '../settle/types.js';
import { CAIP2_CHAIN_IDS } from '../verify/types.js';
import type { VerifyContext } from '../verify/types.js';
import { settlePayment } from '../settle/settle-payment.js';
```

Route handler logic:
1. Parse request body with `SettleRequestSchema.safeParse(request.body)`.
2. If parse fails: return `reply.status(200).send({ success: false, reason: 'invalid_request' })`.
3. Convert base64 transaction to Uint8Array: `const cborBytes = Buffer.from(parsed.data.transaction, 'base64');`
4. Assemble a `VerifyContext` from the parsed request + server state -- same assembly as `/verify` route (copy the pattern from `src/routes/verify.ts`). The `transactionCbor` field is `parsed.data.transaction` (the base64 string). The `payerAddress` is undefined (not in settle request schema). Other fields assembled identically to /verify.
5. Determine network string: `const network = CAIP2_CHAIN_IDS[chainConfig.network as CardanoNetwork];`
6. Get blockfrost client from server: the `blockfrost` client is available as `fastify.chainProvider.blockfrost` -- check if this is exposed. If not, access it via the chain provider's public API. ALTERNATIVE: Create a `getBlockfrostClient()` accessor on ChainProvider if needed.

   IMPORTANT: Check how the existing ChainProvider exposes the BlockfrostClient. Read `src/chain/provider.ts` to see if `blockfrost` is a public property or if there's a getter. If it's private, you need to either:
   - Add a public getter `get blockfrostClient(): BlockfrostClient` to ChainProvider
   - Or pass the BlockfrostClient separately during server setup

   The cleanest approach: add a `get blockfrostClient()` accessor to ChainProvider that returns the internal BlockfrostClient instance. This is a minimal change (2 lines) to `src/chain/provider.ts`.

7. Call `settlePayment(ctx, cborBytes, fastify.chainProvider.blockfrostClient, fastify.redis, network, fastify.log)`.
8. Return `reply.status(200).send(result)`.
9. Wrap the settlePayment call in try/catch for unexpected errors (same pattern as /verify -- HTTP 500 for truly unexpected failures).

Export as `settleRoutesPlugin` via `fp(settleRoutes, { name: 'settle-routes', fastify: '5.x' })`.

**2. Create `src/routes/status.ts`:**

Simpler route -- no orchestrator needed, just a direct Blockfrost query.

Route handler logic:
1. Parse with `StatusRequestSchema.safeParse(request.body)`.
2. If parse fails: return `reply.status(200).send({ status: 'not_found', transaction: '' })`.
3. Query Blockfrost: `const txInfo = await fastify.chainProvider.blockfrostClient.getTransaction(parsed.data.transaction)`.
4. If `txInfo !== null`: return `{ status: 'confirmed', transaction: parsed.data.transaction }`.
5. Otherwise: Check Redis for a dedup record (key: `settle:` prefix + ... but we only have the tx hash, not the CBOR hash). Since /status receives a tx hash (not CBOR), we can't compute the dedup key. Instead, just check Blockfrost directly.
   - If `txInfo === null`: return `{ status: 'pending', transaction: parsed.data.transaction }`.
   - NOTE: We can't distinguish "pending" (submitted but not confirmed) from "not_found" (never submitted) using only Blockfrost -- both return 404. However, the x402 protocol expects the client to only call /status after receiving a tx hash from /settle, so "pending" is the correct default for a 404.
   - REFINEMENT: To distinguish pending from not_found, also check the Redis dedup records. Scan for any record where `txHash === parsed.data.transaction`. But this requires a reverse lookup (we index by CBOR hash, not tx hash). For simplicity in Phase 4, use this logic:
     - Blockfrost returns tx -> "confirmed"
     - Blockfrost returns 404 -> "pending" (client got this hash from /settle, so it was submitted)
   - This matches the CONTEXT.md design exactly.

Export as `statusRoutesPlugin` via `fp(statusRoutes, { name: 'status-routes', fastify: '5.x' })`.

**3. If needed, add blockfrostClient accessor to ChainProvider:**

If `src/chain/provider.ts` does not expose the BlockfrostClient publicly, add a getter:
```typescript
/** Access the underlying Blockfrost API client (for settlement submission). */
get blockfrostClient(): BlockfrostClient {
  return this._blockfrost;
}
```
(Adjust the private field name to match the actual implementation.)

Also add `blockfrostClient: BlockfrostClient` to the Fastify type augmentation in `src/types/index.ts` if accessing via `fastify.chainProvider.blockfrostClient`.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile. Verify both route plugins export correctly. Check that /settle assembles VerifyContext correctly and calls settlePayment. Check that /status queries Blockfrost directly.
  </verify>
  <done>POST /settle route validates input, assembles VerifyContext, converts base64 to Uint8Array, calls settlePayment(), returns HTTP 200 result. POST /status route validates input, queries Blockfrost for tx status, returns HTTP 200. Both follow the exact fastify-plugin pattern from /verify.</done>
</task>

<task type="auto">
  <name>Task 2: Wire routes into server and add integration tests</name>
  <files>src/server.ts, tests/integration/routes/settle.test.ts, tests/integration/routes/status.test.ts</files>
  <action>
**1. Update `src/server.ts`:**

Import and register the new route plugins:
```typescript
import { settleRoutesPlugin } from './routes/settle.js';
import { statusRoutesPlugin } from './routes/status.js';

// In createServer, after existing route registrations:
await server.register(settleRoutesPlugin);
await server.register(statusRoutesPlugin);
```

Add them after `verifyRoutesPlugin` registration.

**2. Create `tests/integration/routes/settle.test.ts`:**

Follow the exact pattern from `tests/integration/routes/verify.test.ts`. Key points:
- Mock `@blockfrost/blockfrost-js`, `ioredis`, and `@lucid-evolution/lucid` at package level (same as verify tests)
- Use `vi.mock` with source-relative paths for internal modules where needed
- Mock `settlePayment` to control return values without invoking the full orchestrator
- Use `vi.resetModules()` pattern for mock isolation per decision from Phase 3

Test cases:
1. **Valid settle request - success**: Returns `{ success: true, transaction: "txhash...", network: "cardano:preprod" }` with HTTP 200
2. **Valid settle request - failure**: Returns `{ success: false, reason: "verification_failed" }` with HTTP 200
3. **Valid settle request - timeout**: Returns `{ success: false, reason: "confirmation_timeout", transaction: "txhash..." }` with HTTP 200
4. **Invalid request body**: Missing `transaction` field -> `{ success: false, reason: "invalid_request" }` with HTTP 200
5. **Invalid request body**: Missing `paymentRequirements` -> `{ success: false, reason: "invalid_request" }` with HTTP 200
6. **Unexpected error**: settlePayment throws -> HTTP 500

**3. Create `tests/integration/routes/status.test.ts`:**

Same mocking pattern.

Test cases:
1. **Confirmed transaction**: getTransaction returns TxInfo -> `{ status: "confirmed", transaction: "txhash..." }` with HTTP 200
2. **Pending transaction**: getTransaction returns null -> `{ status: "pending", transaction: "txhash..." }` with HTTP 200
3. **Invalid request body**: bad tx hash format -> appropriate error response with HTTP 200
4. **Unexpected error**: getTransaction throws -> HTTP 500

**Mocking strategy for integration tests:**

The settle route calls `settlePayment()` which in turn calls `verifyPayment()`, `blockfrost.submitTransaction()`, etc. For integration tests, mock at the `settlePayment` function level (not the individual dependencies) to test the route handler logic in isolation.

Use `vi.mock('../src/settle/settle-payment.js', ...)` with source-relative path from the test file.

For status tests, mock the BlockfrostClient's `getTransaction` method on the chain provider.
  </action>
  <verify>
Run `pnpm build && pnpm lint && pnpm test`. All must pass. Verify:
- `src/server.ts` registers settleRoutesPlugin and statusRoutesPlugin
- POST /settle returns HTTP 200 for all application outcomes
- POST /status returns HTTP 200 for all application outcomes
- At least 6 settle integration tests and 4 status integration tests
- No existing tests broken
  </verify>
  <done>POST /settle and POST /status are registered in the Fastify server. Integration tests verify both endpoints return HTTP 200 for all scenarios (success, failure, timeout, invalid request). All existing tests pass. The full Phase 4 feature set is accessible via HTTP.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (all existing + new integration tests)
- POST /settle accepts `{transaction, paymentRequirements}` and returns `{success, transaction?, network?, reason?}`
- POST /status accepts `{transaction, paymentRequirements}` and returns `{status, transaction}`
- Both endpoints return HTTP 200 for all application-level outcomes
- Invalid requests return HTTP 200 with appropriate failure reasons
- Unexpected errors return HTTP 500 (consistent with /verify pattern)
- Server registers all 4 route plugins: health, verify, settle, status
</verification>

<success_criteria>
Phase 4 is feature-complete: POST /settle submits verified payments to Cardano blockchain and waits for on-chain confirmation. POST /status provides lightweight confirmation polling. Both endpoints are accessible, tested, and follow established patterns. All tests pass (existing + new).
</success_criteria>

<output>
After completion, create `.planning/phases/04-settlement/04-03-SUMMARY.md`
</output>
