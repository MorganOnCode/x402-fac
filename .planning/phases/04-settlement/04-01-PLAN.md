---
phase: 04-settlement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/settle/types.ts
  - src/settle/index.ts
  - src/chain/blockfrost-client.ts
autonomous: true

must_haves:
  truths:
    - "Settlement Zod schemas validate /settle and /status request/response shapes"
    - "SettlementRecord interface captures dedup state for Redis persistence"
    - "BlockfrostClient can submit a signed transaction and receive a tx hash"
    - "BlockfrostClient can query transaction status (confirmed or not-found)"
    - "425 (mempool full) is retried with exponential backoff"
  artifacts:
    - path: "src/settle/types.ts"
      provides: "SettleRequest, SettleResponse, StatusRequest, StatusResponse Zod schemas, SettlementRecord, SettleResult, TxInfo types"
      exports: ["SettleRequestSchema", "SettleResponseSchema", "StatusRequestSchema", "StatusResponseSchema", "SettlementRecord", "SettleResult", "TxInfo"]
    - path: "src/settle/index.ts"
      provides: "Barrel exports for settle module"
    - path: "src/chain/blockfrost-client.ts"
      provides: "submitTransaction() and getTransaction() methods on BlockfrostClient"
      contains: "submitTransaction"
  key_links:
    - from: "src/settle/types.ts"
      to: "src/verify/types.ts"
      via: "PaymentRequirementsSchema reuse for request validation"
      pattern: "PaymentRequirementsSchema"
    - from: "src/chain/blockfrost-client.ts"
      to: "@blockfrost/blockfrost-js"
      via: "txSubmit() and txs() delegation"
      pattern: "this\\.api\\.txSubmit|this\\.api\\.txs"
---

<objective>
Define settlement domain types (Zod schemas, TypeScript interfaces) and extend BlockfrostClient with transaction submission and query methods.

Purpose: Establish the type and API foundation that the settlement orchestrator (Plan 02) and route plugins (Plan 03) depend on. No new dependencies needed -- all libraries are already installed.

Output: `src/settle/types.ts`, `src/settle/index.ts`, updated `src/chain/blockfrost-client.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-settlement/04-CONTEXT.md
@.planning/phases/04-settlement/04-RESEARCH.md
@src/verify/types.ts
@src/chain/blockfrost-client.ts
@src/chain/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create settlement types and Zod schemas</name>
  <files>src/settle/types.ts, src/settle/index.ts</files>
  <action>
Create `src/settle/types.ts` with all settlement domain types and Zod schemas. Follow the same conventions established in `src/verify/types.ts`.

**Zod Schemas:**

1. `SettleRequestSchema` -- POST /settle request body:
   - `transaction: z.string().min(1)` (base64-encoded signed CBOR -- same field as /verify)
   - `paymentRequirements: PaymentRequirementsSchema` (reuse from `../verify/types.js`)
   Import `PaymentRequirementsSchema` from `../verify/types.js`.

2. `SettleResponseSchema` -- POST /settle response (for documentation/testing):
   - `success: z.boolean()`
   - `transaction: z.string().optional()` (tx hash, present on success and timeout)
   - `network: z.string().optional()` (CAIP-2 chain ID, present on success)
   - `reason: z.string().optional()` (snake_case reason code, present on failure)

3. `StatusRequestSchema` -- POST /status request body:
   - `transaction: z.string().length(64)` (tx hash, hex string, always 64 chars)
   - `paymentRequirements: PaymentRequirementsSchema`

4. `StatusResponseSchema` -- POST /status response:
   - `status: z.enum(['confirmed', 'pending', 'not_found'])`
   - `transaction: z.string()` (tx hash echo)

**Inferred TypeScript types** from all 4 schemas:
```typescript
export type SettleRequest = z.infer<typeof SettleRequestSchema>;
export type SettleResponse = z.infer<typeof SettleResponseSchema>;
export type StatusRequest = z.infer<typeof StatusRequestSchema>;
export type StatusResponse = z.infer<typeof StatusResponseSchema>;
```

**Plain TypeScript interfaces (no Zod):**

5. `SettlementRecord` -- persisted in Redis for idempotency:
   - `txHash: string`
   - `status: 'submitted' | 'confirmed' | 'timeout' | 'failed'`
   - `submittedAt: number` (Unix ms timestamp)
   - `confirmedAt?: number` (Unix ms timestamp, set on confirmation)
   - `reason?: string` (failure reason if status is 'failed')

6. `SettleResult` -- return type of the settlePayment() orchestrator:
   - `success: boolean`
   - `transaction?: string` (tx hash)
   - `network?: string` (CAIP-2 chain ID)
   - `reason?: string` (snake_case failure reason)

7. `TxInfo` -- subset of Blockfrost tx_content response:
   - `hash: string`
   - `block: string` (block hash)
   - `block_height: number`
   - `block_time: number` (Unix timestamp)
   - `slot: number`
   - `index: number` (tx index within block)
   - `fees: string` (lovelace as string)
   - `valid_contract: boolean`

Export all schemas, inferred types, and interfaces.

**Create `src/settle/index.ts`:**

Barrel exports for the settle module:
- All types and schemas from `./types.js`
- Use `export type { ... }` for type-only exports per ESM convention
- Comment placeholders for future exports: settle-payment (Plan 02)
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no errors. Verify `src/settle/types.ts` exports 4 Zod schemas, 4 inferred types, and 3 plain interfaces (SettlementRecord, SettleResult, TxInfo). Verify `src/settle/index.ts` re-exports everything.
  </verify>
  <done>Settlement domain types defined with Zod schemas matching the locked endpoint designs. SettleRequestSchema reuses PaymentRequirementsSchema from verify module. SettlementRecord captures Redis dedup state. TxInfo models the Blockfrost transaction response subset. All schemas and types exported via barrel.</done>
</task>

<task type="auto">
  <name>Task 2: Extend BlockfrostClient with submitTransaction and getTransaction</name>
  <files>src/chain/blockfrost-client.ts</files>
  <action>
Add two new methods to the `BlockfrostClient` class and one constant change.

**1. Add 425 to RETRYABLE_STATUS_CODES:**

Change the existing set to include 425 (Blockfrost mempool full):
```typescript
const RETRYABLE_STATUS_CODES = new Set([425, 429, 500, 502, 503, 504]);
```
This is a one-line change. 425 is a Blockfrost-specific status code for Cardano mempool congestion -- a transient condition that benefits from retry with backoff.

**2. Add `submitTransaction` method:**

```typescript
/**
 * Submit a signed transaction to the Cardano network via Blockfrost.
 *
 * Accepts raw CBOR bytes (Uint8Array). The underlying library handles
 * Content-Type: application/cbor and byte conversion.
 *
 * Returns the transaction hash string on success.
 * Non-retryable errors (400 = invalid transaction) throw immediately.
 * Retryable errors (425, 429, 500+) are retried via withRetry.
 */
async submitTransaction(cborBytes: Uint8Array): Promise<string> {
  return withRetry(
    () => this.api.txSubmit(cborBytes),
    'submitTransaction',
    this.log,
  );
}
```

NOTE: `this.api.txSubmit()` accepts `Uint8Array | string`. We standardize on `Uint8Array`. The library returns the tx hash as a `string` on success. A 400 (invalid transaction) is NOT in RETRYABLE_STATUS_CODES, so `withRetry` throws it immediately -- the caller (settle orchestrator) must catch and map to a user-friendly reason.

**3. Add `getTransaction` method:**

```typescript
/**
 * Fetch transaction details from Blockfrost.
 *
 * Returns transaction info if the tx is confirmed (found in a block),
 * or null if the tx is not yet confirmed (404 from Blockfrost).
 * Follows the same 404-as-null pattern as getAddressUtxos.
 */
async getTransaction(txHash: string): Promise<TxInfo | null> {
  try {
    return await withRetry(
      () => this.api.txs(txHash) as Promise<TxInfo>,
      'getTransaction',
      this.log,
    );
  } catch (error) {
    if (error instanceof BlockfrostServerError && error.status_code === 404) {
      return null;
    }
    throw error;
  }
}
```

Import `TxInfo` from `../settle/types.js`. This creates a dependency from `chain/` to `settle/` -- acceptable since TxInfo is a pure data interface with no logic.

**4. Add tests for the new methods:**

Create tests in the existing test file pattern. Test:
- `submitTransaction` -- success returns tx hash
- `submitTransaction` -- 400 throws immediately (no retry)
- `submitTransaction` -- 425 retries and succeeds on second attempt
- `getTransaction` -- success returns TxInfo object
- `getTransaction` -- 404 returns null (not an error)
- `getTransaction` -- 500 retries then throws ChainConnectionError

Follow the existing mock pattern in `tests/unit/chain/blockfrost-client.test.ts`. The BlockFrostAPI is mocked, and `txSubmit`/`txs` methods need to be added to the mock.
  </action>
  <verify>
Run `pnpm build && pnpm lint && pnpm test`. All must pass. Verify that:
- `RETRYABLE_STATUS_CODES` now includes 425
- `submitTransaction` exists on BlockfrostClient
- `getTransaction` exists on BlockfrostClient and returns `TxInfo | null`
- New tests cover success, 400 no-retry, 404-as-null, and retry scenarios
  </verify>
  <done>BlockfrostClient has submitTransaction(cborBytes: Uint8Array) and getTransaction(txHash: string) methods. 425 is retryable. 400 errors throw immediately. 404 on getTransaction returns null. All existing tests still pass. New tests cover the submission and query paths.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (existing + new tests)
- `npx tsc --noEmit` passes
- SettleRequestSchema reuses PaymentRequirementsSchema from verify/types.ts
- TxInfo models the Blockfrost tx_content response subset needed for confirmation
- BlockfrostClient.submitTransaction delegates to this.api.txSubmit
- BlockfrostClient.getTransaction uses 404-as-null pattern (matching getAddressUtxos)
- 425 is in RETRYABLE_STATUS_CODES
</verification>

<success_criteria>
Settlement types and BlockfrostClient extensions are in place. Zod schemas match the locked endpoint designs from CONTEXT.md. BlockfrostClient can submit transactions and query their status. Foundation ready for Plan 02 (orchestrator) and Plan 03 (routes).
</success_criteria>

<output>
After completion, create `.planning/phases/04-settlement/04-01-SUMMARY.md`
</output>
