---
phase: 04-settlement
plan: 02
type: tdd
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/settle/settle-payment.ts
  - tests/unit/settle/settle-payment.test.ts
autonomous: true

must_haves:
  truths:
    - "settlePayment() re-verifies the transaction before submitting"
    - "Duplicate CBOR submissions are detected via SHA-256 dedup key in Redis (SET NX)"
    - "After submission, Blockfrost is polled every 5 seconds for confirmation"
    - "Polling times out at 120 seconds with reason confirmation_timeout"
    - "Already-confirmed duplicates return success without resubmission"
    - "400 errors from Blockfrost map to reason invalid_transaction"
    - "Confirmed transactions update the Redis dedup record with confirmedAt timestamp"
  artifacts:
    - path: "src/settle/settle-payment.ts"
      provides: "settlePayment() orchestrator, pollConfirmation() helper, computeDedupKey() helper"
      exports: ["settlePayment"]
      min_lines: 80
    - path: "tests/unit/settle/settle-payment.test.ts"
      provides: "Unit tests for settlement orchestrator"
      min_lines: 100
  key_links:
    - from: "src/settle/settle-payment.ts"
      to: "src/verify/verify-payment.ts"
      via: "verifyPayment() call for defense-in-depth re-verification"
      pattern: "verifyPayment"
    - from: "src/settle/settle-payment.ts"
      to: "src/chain/blockfrost-client.ts"
      via: "submitTransaction() and getTransaction() calls"
      pattern: "blockfrost\\.submitTransaction|blockfrost\\.getTransaction"
    - from: "src/settle/settle-payment.ts"
      to: "ioredis"
      via: "Redis SET NX for dedup, GET for existing record lookup"
      pattern: "redis\\.set.*NX|redis\\.get"
---

<objective>
Implement the settlement orchestrator using TDD: settlePayment() that re-verifies, deduplicates, submits to Blockfrost, polls for confirmation, and returns a typed result.

Purpose: This is the core business logic of Phase 4. The orchestrator wires together verification (Phase 3), BlockfrostClient submission (Plan 01), Redis dedup, and confirmation polling into a single cohesive flow. TDD ensures the complex state machine (verify -> dedup -> submit -> poll -> result) is correct.

Output: `src/settle/settle-payment.ts`, `tests/unit/settle/settle-payment.test.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/04-settlement/04-CONTEXT.md
@.planning/phases/04-settlement/04-RESEARCH.md
@.planning/phases/04-settlement/04-01-SUMMARY.md
@src/verify/verify-payment.ts
@src/chain/blockfrost-client.ts
@src/settle/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD settlement orchestrator (settlePayment + pollConfirmation)</name>
  <files>src/settle/settle-payment.ts, tests/unit/settle/settle-payment.test.ts</files>
  <action>
Build using RED-GREEN-REFACTOR cycle.

**Constants (hardcoded, not configurable per research recommendation):**
```typescript
const POLL_INTERVAL_MS = 5_000;
const POLL_TIMEOUT_MS = 120_000;
const DEDUP_TTL_SECONDS = 86_400; // 24 hours
```

**Core functions to implement:**

1. `computeDedupKey(cborBytes: Uint8Array): string`
   - Returns `settle:${createHash('sha256').update(cborBytes).digest('hex')}`
   - Import `createHash` from `node:crypto`

2. `pollConfirmation(txHash, blockfrost, timeoutMs, intervalMs, logger): Promise<{ confirmed: boolean; blockHeight?: number }>`
   - Loop: call `blockfrost.getTransaction(txHash)`
   - If result is not null (tx found in a block), return `{ confirmed: true, blockHeight: result.block_height }`
   - Otherwise, `await new Promise(r => setTimeout(r, intervalMs))` and retry
   - Check `Date.now() < deadline` before each poll
   - On timeout: return `{ confirmed: false }`

3. `settlePayment(ctx, cborBytes, blockfrost, redis, network, logger): Promise<SettleResult>`

   Full flow:
   a. **Re-verify**: Call `verifyPayment(ctx, logger)`. If `!result.isValid`, return `{ success: false, reason: 'verification_failed' }`.

   b. **Dedup check**: Compute dedup key via `computeDedupKey(cborBytes)`. Use `redis.set(dedupKey, JSON.stringify(record), 'EX', DEDUP_TTL_SECONDS, 'NX')` to atomically claim the key. If SET NX returns null (key already exists):
      - Read the existing record via `redis.get(dedupKey)`
      - Parse as `SettlementRecord`
      - If `status === 'confirmed'`, return `{ success: true, transaction: record.txHash, network }`
      - If `status === 'submitted'` or `status === 'timeout'`, poll for current status:
        - Call `blockfrost.getTransaction(record.txHash)`
        - If confirmed now, update Redis record to 'confirmed' + confirmedAt, return success
        - Otherwise return `{ success: false, reason: 'confirmation_timeout', transaction: record.txHash }`
      - If `status === 'failed'`, return `{ success: false, reason: record.reason ?? 'internal_error' }`

   c. **Submit**: Call `blockfrost.submitTransaction(cborBytes)` in a try/catch.
      - On success: receive `txHash` string
      - On `BlockfrostServerError` with `status_code === 400`: return `{ success: false, reason: 'invalid_transaction' }`
      - On other errors: update Redis record to 'failed', return `{ success: false, reason: 'submission_rejected' }`

   d. **Update Redis**: After successful submission, update the dedup record with `txHash` and `status: 'submitted'`.

   e. **Poll for confirmation**: Call `pollConfirmation(txHash, blockfrost, POLL_TIMEOUT_MS, POLL_INTERVAL_MS, logger)`.
      - If confirmed: update Redis record to `{ status: 'confirmed', confirmedAt: Date.now() }`. Return `{ success: true, transaction: txHash, network }`.
      - If timeout: update Redis record to `{ status: 'timeout' }`. Return `{ success: false, reason: 'confirmation_timeout', transaction: txHash }`.

   Import `BlockfrostServerError` from `@blockfrost/blockfrost-js` for the 400-status check.

**Important implementation details:**
- The initial Redis SET NX record should be: `{ txHash: '', status: 'submitted', submittedAt: Date.now() }` -- the txHash is empty initially because we haven't submitted yet, but we need to claim the key before submission (TOCTOU prevention).
- After `submitTransaction` succeeds, update the record: `redis.set(dedupKey, JSON.stringify({ ...record, txHash }), 'EX', DEDUP_TTL_SECONDS)` -- this overwrites with the tx hash while preserving the TTL.
- Use `JSON.stringify` / `JSON.parse` for Redis record serialization (no BigInt values in SettlementRecord, so standard JSON is fine).

**Test cases (write FIRST in TDD red phase):**

Tests should mock `verifyPayment`, `blockfrost.submitTransaction`, `blockfrost.getTransaction`, and `redis` (get/set methods).

1. **Happy path**: verify passes, no dedup, submit succeeds, poll confirms on first check -> returns `{ success: true, transaction, network }`
2. **Verification failure**: verify returns isValid: false -> returns `{ success: false, reason: 'verification_failed' }`
3. **Dedup hit - already confirmed**: SET NX fails, GET returns confirmed record -> returns success without resubmission
4. **Dedup hit - still pending**: SET NX fails, GET returns submitted record, getTransaction returns confirmed -> updates record, returns success
5. **Dedup hit - still pending, not confirmed**: SET NX fails, GET returns submitted record, getTransaction returns null -> returns timeout
6. **Submit 400 error**: submitTransaction throws BlockfrostServerError(400) -> returns `{ success: false, reason: 'invalid_transaction' }`
7. **Submit other error**: submitTransaction throws non-400 error -> returns `{ success: false, reason: 'submission_rejected' }`
8. **Poll timeout**: submit succeeds, getTransaction always returns null until timeout -> returns `{ success: false, reason: 'confirmation_timeout', transaction }`
9. **Poll confirms on second attempt**: submit succeeds, first getTransaction null, second returns TxInfo -> returns success
10. **Dedup hit - failed record**: SET NX fails, GET returns failed record -> returns failure with stored reason

For poll timeout test: mock `Date.now()` or use `vi.useFakeTimers()` to avoid waiting 120 seconds. The poll loop checks `Date.now() < deadline`, so advancing fake timers past the deadline makes the test fast.

**RED phase**: Write all tests first. They will fail because `settlePayment` doesn't exist yet.
**GREEN phase**: Implement `settlePayment`, `pollConfirmation`, and `computeDedupKey` to make all tests pass.
**REFACTOR phase**: Clean up if needed. Ensure no lint violations.

Update `src/settle/index.ts` barrel to export `settlePayment` from `./settle-payment.js`.
  </action>
  <verify>
Run `pnpm test -- --run tests/unit/settle/settle-payment.test.ts` -- all tests pass. Then run `pnpm build && pnpm lint && pnpm test` -- everything green. Verify:
- settlePayment returns SettleResult
- At least 10 test cases covering the state machine
- Redis SET NX is used (not plain SET) for the initial dedup claim
- BlockfrostServerError 400 is caught and mapped to 'invalid_transaction'
- Poll loop uses setTimeout-based sleep, not busy-wait
  </verify>
  <done>Settlement orchestrator implements the full flow: re-verify -> dedup -> submit -> poll -> result. All error paths handled with specific reason codes. Redis NX prevents TOCTOU race. 10+ tests verify the state machine. Exported via barrel.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (all existing + new settle tests)
- settlePayment re-verifies via verifyPayment() before submission
- Redis SET NX used for atomic dedup claim
- pollConfirmation loops with 5-second async sleep intervals
- 120-second timeout produces confirmation_timeout reason
- 400 from Blockfrost produces invalid_transaction reason
- Already-confirmed dedup records return success without resubmission
</verification>

<success_criteria>
The settlement orchestrator correctly implements the locked sync settlement flow: re-verify, dedup, submit, poll, return. All error paths produce the correct snake_case reason codes. TDD tests cover the full state machine including dedup scenarios, submission failures, and poll timeout. Ready for route wiring in Plan 03.
</success_criteria>

<output>
After completion, create `.planning/phases/04-settlement/04-02-SUMMARY.md`
</output>
