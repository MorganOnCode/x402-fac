---
phase: 05-stablecoins
plan: 02
type: tdd
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/verify/checks.ts
  - tests/unit/verify/checks.test.ts
autonomous: true

must_haves:
  truths:
    - "Unsupported tokens are rejected with reason 'unsupported_token' before output scanning"
    - "ADA payments pass token_supported check without registry lookup"
    - "Token amount is verified from output.assets map using the concatenated unit key"
    - "ADA amount check still uses output.lovelace (unchanged behavior)"
    - "Overpayment is allowed for both ADA and token amounts (>= comparison)"
    - "min_utxo check verifies sufficient ADA in recipient output for all payment types"
    - "min_utxo failure includes required amount in details for client diagnostics"
    - "Verification pipeline has 10 checks in correct order"
  artifacts:
    - path: "src/verify/checks.ts"
      provides: "checkTokenSupported, modified checkAmount (ADA/token branching), checkMinUtxo, updated VERIFICATION_CHECKS (10 items)"
      exports: ["checkTokenSupported", "checkMinUtxo", "checkAmount", "VERIFICATION_CHECKS"]
    - path: "tests/unit/verify/checks.test.ts"
      provides: "Tests for new/modified checks: token_supported, amount branching, min_utxo"
  key_links:
    - from: "src/verify/checks.ts"
      to: "src/verify/token-registry.ts"
      via: "Import SUPPORTED_TOKENS, LOVELACE_UNIT, assetToUnit for token validation"
      pattern: "import.*from.*token-registry"
    - from: "src/verify/checks.ts"
      to: "src/verify/types.ts"
      via: "VerifyContext.asset and VerifyContext.getMinUtxoLovelace consumed by new checks"
      pattern: "ctx\\.asset|ctx\\.getMinUtxoLovelace"
---

<objective>
Implement three verification check changes using TDD: add checkTokenSupported, modify checkAmount for token branching, and add checkMinUtxo. Update the VERIFICATION_CHECKS array from 8 to 10 checks.

Purpose: These checks enforce the core stablecoin verification logic -- only whitelisted tokens accepted, correct token amounts verified, and min UTXO ADA validated. TDD ensures each check has comprehensive test coverage before implementation.

Output: Updated `src/verify/checks.ts`, updated `tests/unit/verify/checks.test.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-stablecoins/05-CONTEXT.md
@.planning/phases/05-stablecoins/05-RESEARCH.md
@.planning/phases/05-stablecoins/05-01-SUMMARY.md
@src/verify/checks.ts
@src/verify/types.ts
@src/verify/token-registry.ts
@tests/unit/verify/checks.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD -- checkTokenSupported (RED then GREEN)</name>
  <files>tests/unit/verify/checks.test.ts, src/verify/checks.ts</files>
  <action>
**RED phase -- Write failing tests first.**

Add a new `describe('checkTokenSupported')` block in `tests/unit/verify/checks.test.ts`. Import `checkTokenSupported` from `../../../src/verify/checks.js` (add to existing import statement). Use the existing `makeCtx()` helper, adding `asset` and `getMinUtxoLovelace` to its defaults (if not already done by Plan 01's test updates).

Use mocked policy IDs for test tokens -- do NOT use real mainnet IDs in tests per locked decision. Define test constants at the top of the describe block:

```typescript
const MOCK_POLICY_ID = 'aa'.repeat(28); // 56-char hex
const MOCK_ASSET_NAME = 'bbccdd';
const MOCK_UNIT = MOCK_POLICY_ID + MOCK_ASSET_NAME; // concatenated
const MOCK_ASSET_DOT = MOCK_POLICY_ID + '.' + MOCK_ASSET_NAME; // API format
```

**Test cases for checkTokenSupported (7 tests):**

1. Passes for ADA payment (`ctx.asset = 'lovelace'`)
2. Passes for USDM (use the real USDM unit from SUPPORTED_TOKENS to verify the real registry works -- this is the one exception to mocked IDs, confirming the registry data is correct)
3. Passes for DJED (same -- one integration-style test per token)
4. Passes for iUSD (same)
5. Fails with reason 'unsupported_token' for unknown token (`ctx.asset = MOCK_ASSET_DOT` where MOCK_POLICY_ID is not in registry)
6. Fails with details including the asset identifier
7. Check name is 'token_supported' in all results

For tests 2-4, use the dot-separated format (policyId.assetNameHex) since that is the API wire format stored in `ctx.asset`.

Run tests -- they MUST fail (checkTokenSupported does not exist yet).

**GREEN phase -- Implement checkTokenSupported.**

Add to `src/verify/checks.ts`:

```typescript
import { SUPPORTED_TOKENS, LOVELACE_UNIT, assetToUnit } from './token-registry.js';
```

```typescript
/**
 * Validate that the requested asset is supported by this facilitator.
 * ADA ("lovelace") is always supported. Token payments must be in
 * the SUPPORTED_TOKENS registry.
 *
 * Must come BEFORE recipient check for fast rejection of unsupported tokens.
 */
export function checkTokenSupported(ctx: VerifyContext): CheckResult {
  if (ctx.asset === LOVELACE_UNIT) {
    return { check: 'token_supported', passed: true };
  }

  const unit = assetToUnit(ctx.asset);
  if (SUPPORTED_TOKENS.has(unit)) {
    return { check: 'token_supported', passed: true };
  }

  return {
    check: 'token_supported',
    passed: false,
    reason: 'unsupported_token',
    details: { asset: ctx.asset },
  };
}
```

Do NOT update VERIFICATION_CHECKS yet -- that happens in Task 2. Run tests -- all checkTokenSupported tests must now pass, plus all existing tests still pass.
  </action>
  <verify>
Run `pnpm test -- tests/unit/verify/checks.test.ts` -- all tests pass including the new checkTokenSupported tests. Run `npx tsc --noEmit` -- no type errors. Verify checkTokenSupported returns `{ check: 'token_supported', passed: true }` for 'lovelace' and for known tokens, and `{ passed: false, reason: 'unsupported_token' }` for unknown tokens.
  </verify>
  <done>checkTokenSupported implemented and tested with 7 tests. ADA always passes. Known tokens (USDM, DJED, iUSD) pass via registry lookup using dot-separated API format. Unknown tokens fail with reason 'unsupported_token'. All existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: TDD -- Modify checkAmount for token branching + add checkMinUtxo + update pipeline (RED then GREEN)</name>
  <files>tests/unit/verify/checks.test.ts, src/verify/checks.ts</files>
  <action>
**RED phase -- Write failing tests for modified checkAmount.**

Update the existing `describe('checkAmount')` block with additional token-specific tests. The existing ADA tests should continue to work unchanged. Add new tests:

**checkAmount token branching tests (6 new tests):**

Use mock token data:
```typescript
const MOCK_TOKEN_UNIT = 'cc'.repeat(28) + 'ddee'; // concatenated for assets map key
const MOCK_TOKEN_ASSET = 'cc'.repeat(28) + '.' + 'ddee'; // dot-separated API format
```

1. Passes when token amount in output.assets meets required amount (`output.assets[MOCK_TOKEN_UNIT] = 5_000_000n`, `ctx.requiredAmount = 5_000_000n`, `ctx.asset = MOCK_TOKEN_ASSET`)
2. Passes when token amount exceeds required (overpayment, `output.assets[MOCK_TOKEN_UNIT] = 10_000_000n`, `ctx.requiredAmount = 5_000_000n`)
3. Fails with 'amount_insufficient' when token amount is less than required
4. Fails with 'amount_insufficient' when token is missing from output.assets entirely (no key present -- `output.assets = {}`)
5. Fails with details including `asset` field showing which token was checked
6. ADA payment (`ctx.asset = 'lovelace'`) still uses output.lovelace (existing behavior unchanged -- ensure an existing ADA test still passes as a regression guard)

**RED phase -- Write failing tests for checkMinUtxo.**

Add a new `describe('checkMinUtxo')` block. Import `checkMinUtxo` from checks.

**checkMinUtxo tests (8 tests):**

1. Passes (skips) when `ctx.getMinUtxoLovelace` is not provided (backward compat -- existing routes before Plan 03)
2. Passes when output.lovelace >= min UTXO for ADA-only output (`ctx.asset = 'lovelace'`, `ctx.getMinUtxoLovelace` returns 1_000_000n, output.lovelace = 2_000_000n)
3. Passes when output.lovelace >= min UTXO for token output (higher min due to assets)
4. Fails with 'min_utxo_insufficient' when output.lovelace < min UTXO
5. Failure details include `required` (the min amount) and `actual` (the output lovelace) as strings
6. Failure details include `message` with human-readable text: `"min UTXO requires X lovelace, got Y"` per locked decision
7. Fails when `_matchingOutputIndex` is undefined (returns reason 'cbor_required')
8. Check name is 'min_utxo' in all results

Set up `ctx.getMinUtxoLovelace` as `vi.fn().mockResolvedValue(1_000_000n)` for ADA tests and `vi.fn().mockResolvedValue(1_200_000n)` for token tests.

Note: `checkMinUtxo` counts the number of distinct asset keys in `output.assets` and passes that count to `ctx.getMinUtxoLovelace(numAssets)`.

Run tests -- checkAmount token tests and checkMinUtxo tests MUST fail.

**GREEN phase -- Implement changes.**

**1. Modify `checkAmount` in `src/verify/checks.ts`:**

```typescript
export function checkAmount(ctx: VerifyContext): CheckResult {
  // Determine the effective asset (default to lovelace for backward compat)
  const asset = ctx.asset ?? LOVELACE_UNIT;

  if (asset === LOVELACE_UNIT) {
    // ADA payment: use existing _matchingOutputAmount (set by checkRecipient)
    // This preserves backward compatibility with existing test mocks
    if (ctx._matchingOutputAmount === undefined) {
      return {
        check: 'amount',
        passed: false,
        reason: 'amount_insufficient',
        details: { error: 'no matching output found' },
      };
    }
    if (ctx._matchingOutputAmount >= ctx.requiredAmount) {
      return { check: 'amount', passed: true };
    }
    return {
      check: 'amount',
      passed: false,
      reason: 'amount_insufficient',
      details: {
        expected: ctx.requiredAmount.toString(),
        actual: ctx._matchingOutputAmount.toString(),
      },
    };
  }

  // Token payment: must use _parsedTx to access the assets map
  if (ctx._matchingOutputIndex === undefined || !ctx._parsedTx) {
    return {
      check: 'amount',
      passed: false,
      reason: 'amount_insufficient',
      details: { error: 'no matching output found' },
    };
  }

  const output = ctx._parsedTx.body.outputs[ctx._matchingOutputIndex];
  const unit = assetToUnit(asset);
  const tokenAmount = output.assets[unit] ?? 0n;
  if (tokenAmount >= ctx.requiredAmount) {
    return { check: 'amount', passed: true };
  }
  return {
    check: 'amount',
    passed: false,
    reason: 'amount_insufficient',
    details: {
      expected: ctx.requiredAmount.toString(),
      actual: tokenAmount.toString(),
      asset: asset,
    },
  };
}
```

The key design: ADA path continues to use `ctx._matchingOutputAmount` (set by `checkRecipient`) which preserves backward compatibility with all existing test mocks that set `_matchingOutputAmount` without `_parsedTx`. Token path uses `ctx._parsedTx.body.outputs[ctx._matchingOutputIndex].assets` because token amounts live in the assets map, not in `_matchingOutputAmount`.

The `ctx.asset` field is optional (Plan 01 makes it optional for incremental rollout). When absent, defaults to `LOVELACE_UNIT`, preserving existing ADA behavior exactly.

IMPORTANT: Existing orchestrator tests that mock `_matchingOutputAmount` for ADA checks will continue to work unchanged. Only token-specific tests need `_parsedTx` with populated `assets` maps.

Use `>= ` for overpayment (matching existing ADA behavior per discretion recommendation).

**2. Add `checkMinUtxo` to `src/verify/checks.ts`:**

```typescript
/**
 * Validate that the recipient output contains enough ADA for the min UTXO requirement.
 * Applies to ALL payments (ADA and token). Token outputs require more ADA due to
 * multi-asset serialization overhead.
 *
 * Uses ChainProvider.getMinUtxoLovelace(numAssets) via the ctx callback.
 * The error includes the required amount so clients can fix their transaction.
 *
 * If ctx.getMinUtxoLovelace is not provided (optional field), the check passes
 * with a skip -- this allows existing routes to work before Plan 03 wires it in.
 */
export async function checkMinUtxo(ctx: VerifyContext): Promise<CheckResult> {
  // Skip if callback not provided (backward compat until Plan 03 wires it)
  if (!ctx.getMinUtxoLovelace) {
    return { check: 'min_utxo', passed: true };
  }

  if (ctx._matchingOutputIndex === undefined || !ctx._parsedTx) {
    return { check: 'min_utxo', passed: false, reason: 'cbor_required' };
  }

  const output = ctx._parsedTx.body.outputs[ctx._matchingOutputIndex];
  const numAssets = Object.keys(output.assets).length;
  const requiredMinAda = await ctx.getMinUtxoLovelace(numAssets);

  if (output.lovelace >= requiredMinAda) {
    return { check: 'min_utxo', passed: true };
  }

  return {
    check: 'min_utxo',
    passed: false,
    reason: 'min_utxo_insufficient',
    details: {
      required: requiredMinAda.toString(),
      actual: output.lovelace.toString(),
      message: `min UTXO requires ${requiredMinAda.toString()} lovelace, got ${output.lovelace.toString()}`,
    },
  };
}
```

**3. Update `VERIFICATION_CHECKS` array:**

Insert `checkTokenSupported` at position 4 (after network, before recipient) and `checkMinUtxo` at position 7 (after amount, before witness):

```typescript
export const VERIFICATION_CHECKS: VerifyCheck[] = [
  checkCborValid,      // 1. Parse CBOR
  checkScheme,         // 2. Validate scheme
  checkNetwork,        // 3. Validate network
  checkTokenSupported, // 4. NEW: Validate asset is supported
  checkRecipient,      // 5. Find matching output
  checkAmount,         // 6. MODIFIED: Check ADA or token amount
  checkMinUtxo,        // 7. NEW: Check min UTXO ADA
  checkWitness,        // 8. Check signatures present
  checkTtl,            // 9. Check TTL not expired
  checkFee,            // 10. Check fee bounds
];
```

**4. Update the VERIFICATION_CHECKS test at the bottom of the test file:**

The existing test "VERIFICATION_CHECKS has all checks in order" should be updated to expect 10 checks and verify the new order. The test currently checks `VERIFICATION_CHECKS.length === 8` and verifies function names -- update to 10 with the new check names.

Run all tests -- everything must pass (new + existing).
  </action>
  <verify>
Run `pnpm test -- tests/unit/verify/checks.test.ts` -- all tests pass (existing 30 + new ~20). Run `pnpm build && pnpm test` -- full suite passes. Verify `VERIFICATION_CHECKS.length === 10`. Verify checkAmount handles both ADA (lovelace comparison) and token (assets map lookup) paths. Verify checkMinUtxo returns required amount in failure details.
  </verify>
  <done>Three check changes complete via TDD. checkTokenSupported rejects unknown tokens at position 4. checkAmount branches on ctx.asset for ADA vs token amount verification with overpayment allowed. checkMinUtxo validates sufficient ADA in recipient output at position 7. VERIFICATION_CHECKS array updated from 8 to 10 checks in correct order. All tests pass including regression tests for existing ADA behavior.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (all existing + all new tests)
- `npx tsc --noEmit` passes
- `VERIFICATION_CHECKS` has 10 entries in order: cbor, scheme, network, token_supported, recipient, amount, min_utxo, witness, ttl, fee
- checkTokenSupported passes for 'lovelace' and all three registered tokens
- checkTokenSupported fails with 'unsupported_token' for unknown tokens
- checkAmount checks output.lovelace for ADA, output.assets[unit] for tokens
- checkAmount allows overpayment (>=) for both ADA and tokens
- checkMinUtxo counts assets in output and passes numAssets to getMinUtxoLovelace
- checkMinUtxo failure details include required, actual, and human-readable message
- All existing ADA verification tests pass unchanged (backward compatibility)
</verification>

<success_criteria>
Verification pipeline extended from 8 to 10 checks with full token support. Token validation rejects unsupported tokens early. Amount check branches correctly for ADA vs token payments. Min UTXO check validates sufficient ADA for all output types. All checks tested via TDD with comprehensive coverage. Foundation ready for Plan 03 (route integration).
</success_criteria>

<output>
After completion, create `.planning/phases/05-stablecoins/05-02-SUMMARY.md`
</output>
