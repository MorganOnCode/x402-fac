---
phase: 03-verification
plan: 05
type: execute
wave: 4
depends_on: ["03-04"]
files_modified:
  - src/routes/verify.ts
  - src/server.ts
  - src/types/index.ts
  - src/verify/index.ts
  - tests/unit/verify/routes.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /verify accepts x402 verify request and returns verification result"
    - "POST /verify accepts Base64-encoded PAYMENT-SIGNATURE header as alternative input"
    - "GET /nonce returns a fresh facilitator-issued nonce"
    - "All verify responses are HTTP 200 (isValid true/false conveys result)"
    - "Failed verifications are logged at INFO with payer, reason, payload details"
    - "NonceStore is initialized at server startup and available on fastify instance"
  artifacts:
    - path: "src/routes/verify.ts"
      provides: "POST /verify and GET /nonce route handlers"
      exports: ["verifyRoutesPlugin"]
    - path: "src/server.ts"
      provides: "Server with NonceStore initialization and verify routes registration"
      contains: "nonceStore"
    - path: "src/types/index.ts"
      provides: "Fastify augmentation with nonceStore"
      contains: "nonceStore"
    - path: "tests/unit/verify/routes.test.ts"
      provides: "Route-level tests for /verify and /nonce endpoints"
      min_lines: 80
  key_links:
    - from: "src/routes/verify.ts"
      to: "src/verify/verify-payment.ts"
      via: "Calls verifyPayment orchestrator"
      pattern: "verifyPayment"
    - from: "src/routes/verify.ts"
      to: "src/verify/nonce-store.ts"
      via: "Calls nonceStore.generate() for GET /nonce"
      pattern: "nonceStore\\.generate"
    - from: "src/server.ts"
      to: "src/routes/verify.ts"
      via: "Registers verifyRoutesPlugin"
      pattern: "verifyRoutesPlugin"
    - from: "src/server.ts"
      to: "src/verify/nonce-store.ts"
      via: "Creates and decorates NonceStore"
      pattern: "createNonceStore|nonceStore"
---

<objective>
Wire up the /verify and /nonce routes, integrate NonceStore into the server lifecycle, and complete the Phase 3 verification layer.

Purpose: This plan connects all Phase 3 components into the running server. The routes handle HTTP concerns (parsing, header decoding, response formatting), delegate to the orchestrator for verification logic, and use the NonceStore for nonce issuance. The server initializes the NonceStore alongside the chain provider.

Output: Working `/verify` and `/nonce` endpoints on the running server, with full integration into Fastify lifecycle.
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-verification/03-CONTEXT.md
@.planning/phases/03-verification/03-RESEARCH.md
@.planning/phases/03-verification/03-01-SUMMARY.md
@.planning/phases/03-verification/03-02-SUMMARY.md
@.planning/phases/03-verification/03-03-SUMMARY.md
@.planning/phases/03-verification/03-04-SUMMARY.md
@src/server.ts
@src/routes/health.ts
@src/types/index.ts
@src/verify/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create verify routes plugin</name>
  <files>src/routes/verify.ts</files>
  <action>
Create `src/routes/verify.ts` following the pattern of `src/routes/health.ts` (FastifyPluginCallback + fp wrapper).

**POST /verify route:**

1. Check for PAYMENT-SIGNATURE header first (Base64-encoded JSON, per CONTEXT.md):
   ```typescript
   const headerValue = request.headers['payment-signature'] as string | undefined;
   let body: unknown = request.body;
   if (headerValue && !body) {
     try {
       body = JSON.parse(Buffer.from(headerValue, 'base64').toString('utf-8'));
     } catch {
       return reply.status(200).send({
         isValid: false,
         invalidReason: 'invalid_format',
         extra: { errors: ['Failed to decode PAYMENT-SIGNATURE header'] },
       });
     }
   }
   ```

2. Parse with VerifyRequestSchema.safeParse(body):
   - If parsing fails: return HTTP 200 `{ isValid: false, invalidReason: 'invalid_format', extra: { errors: [...] } }`
   - If parsing succeeds: proceed

3. Derive facilitator address from chain provider:
   ```typescript
   const lucid = fastify.chainProvider.getLucid();
   const facilitatorAddress = await lucid.wallet().address();
   ```

4. Call verifyPayment:
   ```typescript
   const result = await verifyPayment(
     parsed.data,
     {
       chainProvider: fastify.chainProvider,
       nonceStore: fastify.nonceStore,
       config: fastify.config.chain,
     },
     facilitatorAddress,
   );
   ```

5. Log verification result at INFO level (per CONTEXT.md):
   ```typescript
   fastify.log.info(
     {
       payer: result.payer,
       isValid: result.isValid,
       reason: result.invalidReason,
       scheme: parsed.data.paymentRequirements.scheme,
       network: parsed.data.paymentRequirements.network,
     },
     'Payment verification result'
   );
   ```
   Do NOT log signature, key, or nonce values (secrets).

6. Return HTTP 200 with result (always 200 per CONTEXT.md).

**GET /nonce route:**

Simple:
```typescript
fastify.get('/nonce', async (_request, reply) => {
  const nonce = fastify.nonceStore.generate();
  return reply.send({ nonce });
});
```

**CORS:** Add 'Payment-Signature' to allowed headers (update will be in server.ts task).

Export as `verifyRoutesPlugin` using fp with `{ name: 'verify-routes', fastify: '5.x' }`.
  </action>
  <verify>
File compiles: `npx tsc --noEmit` passes.
  </verify>
  <done>POST /verify route handles both JSON body and PAYMENT-SIGNATURE header, delegates to verifyPayment, logs results at INFO. GET /nonce returns fresh nonce. All responses HTTP 200.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate NonceStore and verify routes into server</name>
  <files>src/server.ts, src/types/index.ts</files>
  <action>
**1. Update `src/types/index.ts`:**

Add NonceStore to Fastify augmentation:
```typescript
import type { NonceStore } from '../verify/nonce-store.js';

declare module 'fastify' {
  interface FastifyInstance {
    config: Config;
    redis: Redis;
    chainProvider: ChainProvider;
    nonceStore: NonceStore;
  }
}
```

**2. Update `src/server.ts`:**

a. Add imports:
```typescript
import { createNonceStore } from './verify/index.js';
import { verifyRoutesPlugin } from './routes/verify.js';
```

b. After chain provider initialization (after `server.decorate('chainProvider', chainProvider)`), create and decorate NonceStore:
```typescript
const nonceStore = createNonceStore(redis, config.chain, server.log);
// Recover persisted nonces from Redis (same pattern as reservation recovery)
await nonceStore.loadFromRedis();
server.decorate('nonceStore', nonceStore);
server.log.info('Nonce store initialized');
```

c. Register verify routes after health routes:
```typescript
await server.register(verifyRoutesPlugin);
```

d. Add 'Payment-Signature' to CORS allowedHeaders:
```typescript
allowedHeaders: ['Content-Type', 'Authorization', 'X-Request-ID', 'Payment-Signature'],
```

IMPORTANT: The NonceStore initialization goes INSIDE the existing try/catch block for chain layer initialization (it depends on Redis being connected). If chain layer fails, NonceStore is not created (which is correct -- facilitator is useless without chain access).
  </action>
  <verify>
`pnpm build` passes. `pnpm test` passes (existing tests should still work -- NonceStore is initialized only when chain config is present, which tests may mock).
  </verify>
  <done>Server creates NonceStore at startup, decorates fastify with it, recovers persisted nonces from Redis, registers verify routes plugin, and includes Payment-Signature in CORS headers.</done>
</task>

<task type="auto">
  <name>Task 3: Add route-level tests for /verify and /nonce</name>
  <files>tests/unit/verify/routes.test.ts</files>
  <action>
Create `tests/unit/verify/routes.test.ts` with tests that exercise the routes through Fastify's inject() method.

**Setup:**
- Use Fastify inject (no real HTTP server needed)
- Mock chainProvider, nonceStore, and config on the Fastify instance
- Register verify routes plugin on a test Fastify instance

**Test cases:**

1. **GET /nonce returns 200 with nonce string:**
   - Mock nonceStore.generate() to return a known nonce
   - Assert response status 200, body `{ nonce: '...' }`

2. **POST /verify with valid JSON body returns 200:**
   - Mock verifyPayment to return `{ isValid: true, payer: 'addr...' }`
   - Send valid VerifyRequest as JSON body
   - Assert response status 200, body has `isValid: true`

3. **POST /verify with PAYMENT-SIGNATURE header returns 200:**
   - Encode a valid VerifyRequest as Base64
   - Send as Payment-Signature header with empty body
   - Assert verifyPayment was called (header decoded correctly)

4. **POST /verify with invalid JSON returns 200 with invalidReason:**
   - Send `{ invalid: 'garbage' }` as body
   - Assert response status 200, body has `isValid: false, invalidReason: 'invalid_format'`

5. **POST /verify with invalid Base64 header returns 200 with invalidReason:**
   - Send `Payment-Signature: not-valid-base64!!!` header
   - Assert response status 200, body has `isValid: false, invalidReason: 'invalid_format'`

6. **POST /verify logs verification result:**
   - Mock Fastify logger
   - Send a verification request
   - Assert logger.info was called with payer and isValid

**Mock strategy:**
Create a test helper that builds a Fastify instance with mocked decorations:
```typescript
function buildTestServer() {
  const app = fastify({ logger: false });
  app.decorate('config', mockConfig);
  app.decorate('chainProvider', mockChainProvider);
  app.decorate('nonceStore', mockNonceStore);
  app.register(verifyRoutesPlugin);
  return app;
}
```

This tests the routing/HTTP layer, not the verification logic (which is tested in verify-payment.test.ts and checks.test.ts).
  </action>
  <verify>
`pnpm test -- tests/unit/verify/routes.test.ts` -- all tests pass. `pnpm test` -- full suite passes.
  </verify>
  <done>Route tests verify HTTP layer: JSON body parsing, PAYMENT-SIGNATURE header decoding, invalid format handling, nonce endpoint, and verification result logging. All responses HTTP 200.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (all existing + new tests)
- Server starts and responds to GET /nonce with a nonce
- Server starts and responds to POST /verify with verification result
- CORS allows Payment-Signature header
- NonceStore decorated on Fastify instance and recovered from Redis at startup
</verification>

<success_criteria>
POST /verify and GET /nonce endpoints are live, integrated with NonceStore and ChainProvider via Fastify decorations. Both JSON body and PAYMENT-SIGNATURE header accepted. All responses HTTP 200. Verification results logged at INFO without secrets. Route tests cover happy path, error cases, and header decoding.
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-05-SUMMARY.md`
</output>
