---
phase: 03-verification
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/verify/nonce-store.ts
  - src/verify/index.ts
  - tests/unit/verify/nonce-store.test.ts
autonomous: true

must_haves:
  truths:
    - "Nonces are generated with structured timestamp-random format"
    - "Valid nonces are consumed exactly once (replay rejected)"
    - "Expired nonces are rejected without store lookup"
    - "Nonce state persists to Redis for crash recovery"
    - "Expired entries are lazily cleaned on generate/consume"
  artifacts:
    - path: "src/verify/nonce-store.ts"
      provides: "NonceStore class with generate, consume, loadFromRedis, getActiveCount"
      exports: ["NonceStore", "createNonceStore"]
    - path: "tests/unit/verify/nonce-store.test.ts"
      provides: "Unit tests covering generate, consume, expiry, replay, format validation, Redis persistence"
      min_lines: 80
  key_links:
    - from: "src/verify/nonce-store.ts"
      to: "ioredis"
      via: "Fire-and-forget Redis SET/DEL for persistence"
      pattern: "redis\\.set|redis\\.del"
    - from: "src/verify/nonce-store.ts"
      to: "node:crypto"
      via: "randomUUID for nonce random component"
      pattern: "randomUUID"
---

<objective>
Implement the NonceStore using TDD -- a two-layer (Map + Redis) nonce management system for replay protection.

Purpose: Nonces prevent replay attacks. The facilitator issues nonces via GET /nonce (or in 402 responses). Each nonce can be consumed exactly once during verification. This follows the Phase 2 UtxoReservation pattern (in-memory Map + fire-and-forget Redis, TTL-based lazy cleanup).

Output: Working, tested `NonceStore` class in `src/verify/nonce-store.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-verification/03-CONTEXT.md
@.planning/phases/03-verification/03-RESEARCH.md
@.planning/phases/03-verification/03-01-SUMMARY.md
@src/chain/utxo-reservation.ts
@src/verify/types.ts
</context>

<feature>
  <name>NonceStore - Two-layer nonce management with structured format</name>
  <files>src/verify/nonce-store.ts, tests/unit/verify/nonce-store.test.ts</files>
  <behavior>
**Nonce format:** `{unix_ms}-{random_hex_16}` (e.g., `1706745600000-a1b2c3d4e5f67890`)
- Timestamp enables server-side expiry check from the nonce string itself
- Random component from `randomUUID().replace(/-/g, '').slice(0, 16)`

**NonceStore class:**

Constructor: `{ redis: Redis, ttlMs: number, logger: FastifyBaseLogger }`

**generate() -> string:**
- Calls cleanExpired() first (lazy cleanup)
- Creates structured nonce: `${Date.now()}-${random16hex}`
- Stores entry in Map: `{ nonce, issuedAt, expiresAt, used: false }`
- Fire-and-forget Redis SET with PX ttlMs: `nonce:{nonce}` -> JSON entry
- Returns nonce string

**consume(nonce: string) -> { valid: boolean; reason?: string }:**
- Calls cleanExpired() first
- Parse timestamp from nonce format (split on first `-`)
- If format invalid: `{ valid: false, reason: 'nonce_invalid_format' }`
- If timestamp + ttlMs < now: `{ valid: false, reason: 'nonce_expired' }`
- If not in Map: `{ valid: false, reason: 'nonce_unknown' }`
- If entry.used === true: `{ valid: false, reason: 'nonce_already_used' }`
- Mark entry.used = true, delete from Map
- Fire-and-forget Redis DEL
- Log at WARN if already used (replay attempt per CONTEXT.md)
- Return `{ valid: true }`

**loadFromRedis() -> Promise<void>:**
- Scan for `nonce:*` keys, parse values, load non-expired/unused entries
- Called once at startup for crash recovery
- Same pattern as UtxoReservation.loadFromRedis()

**getActiveCount() -> number:**
- Returns count of active (non-expired, unused) nonces after cleanup

**cleanExpired() (private):**
- Iterate Map, delete entries where expiresAt <= now
- Fire-and-forget Redis DEL for each cleaned entry

**Test cases (input -> expected output):**
- generate() returns string matching `/^\d+-[0-9a-f]{16}$/`
- generate() stores entry in internal state (getActiveCount increments)
- consume(valid_nonce) -> { valid: true }
- consume(valid_nonce) second time -> { valid: false, reason: 'nonce_already_used' }
- consume('bad-format') -> { valid: false, reason: 'nonce_invalid_format' }
- consume('notinnonce') where no dash -> { valid: false, reason: 'nonce_invalid_format' }
- consume(expired_nonce) -> { valid: false, reason: 'nonce_expired' }
- consume(unknown_nonce) with valid format but never generated -> { valid: false, reason: 'nonce_unknown' }
- After TTL passes, expired entries cleaned from Map
- Redis SET called on generate, Redis DEL called on consume
- loadFromRedis recovers non-expired entries
  </behavior>
  <implementation>
Follow UtxoReservation pattern exactly:
- In-memory Map<string, NonceEntry> as primary store
- Fire-and-forget Redis SET/DEL for persistence
- PX (millisecond) TTL on Redis keys
- Lazy cleanup via cleanExpired()
- Factory function: `createNonceStore(redis, config, logger)`

NonceEntry interface:
```typescript
interface NonceEntry {
  nonce: string;
  issuedAt: number;
  expiresAt: number;
  used: boolean;
}
```

Redis key prefix: `nonce:`

Mock Redis in tests using the same class-based mock pattern from Phase 2 tests.

After implementing, update `src/verify/index.ts` barrel to export `NonceStore` and `createNonceStore`.
  </implementation>
</feature>

<verification>
- `pnpm test -- tests/unit/verify/nonce-store.test.ts` -- all tests pass
- `pnpm test` -- full suite passes (no regressions)
- `pnpm build` succeeds
</verification>

<success_criteria>
NonceStore generates structured nonces, consumes them exactly once, rejects replays/expired/unknown nonces, persists to Redis, and recovers from Redis on startup. All test cases green.
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-02-SUMMARY.md`
</output>
