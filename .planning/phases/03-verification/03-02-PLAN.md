---
phase: 03-verification
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/verify/cbor.ts
  - src/verify/checks.ts
  - src/verify/types.ts
  - src/verify/index.ts
  - tests/unit/verify/cbor.test.ts
  - tests/unit/verify/checks.test.ts
autonomous: true

must_haves:
  truths:
    - "Base64-encoded CBOR transactions can be deserialized into structured objects with inputs, outputs, fee, TTL, and witness presence"
    - "Invalid base64 and invalid CBOR produce distinct, specific error messages"
    - "A transaction output matching the required recipient and amount can be found among multiple outputs"
    - "Network mismatch between transaction addresses and configured network is detected"
    - "Expired transactions (TTL < current slot) are detected"
    - "Unreasonable fees (outside configured bounds) are detected"
    - "Unsigned transactions (empty witness set) are detected"
  artifacts:
    - path: "src/verify/cbor.ts"
      provides: "CBOR transaction deserialization and parsed transaction type"
      exports: ["deserializeTransaction", "DeserializedTx"]
    - path: "src/verify/checks.ts"
      provides: "Eight individual verification check functions"
      exports: ["checkCborValid", "checkScheme", "checkNetwork", "checkRecipient", "checkAmount", "checkWitness", "checkTtl", "checkFee", "VERIFICATION_CHECKS"]
    - path: "tests/unit/verify/cbor.test.ts"
      provides: "Unit tests for CBOR deserialization"
    - path: "tests/unit/verify/checks.test.ts"
      provides: "Unit tests for all eight verification checks"
  key_links:
    - from: "src/verify/cbor.ts"
      to: "@lucid-evolution/lucid"
      via: "CML.Transaction.from_cbor_hex() for CBOR parsing"
      pattern: "CML\\.Transaction\\.from_cbor_hex"
    - from: "src/verify/checks.ts"
      to: "src/verify/cbor.ts"
      via: "deserializeTransaction used by checkCborValid"
      pattern: "deserializeTransaction"
    - from: "src/verify/checks.ts"
      to: "src/verify/types.ts"
      via: "CheckResult and VerifyContext types used by all checks"
      pattern: "CheckResult.*VerifyContext"
---

<objective>
Implement CBOR transaction deserialization and all eight verification check functions using TDD.

Purpose: These are the core verification primitives. The CBOR module converts base64-encoded signed Cardano transactions into structured objects. The check functions each examine one aspect of the transaction against the payment requirements. Together they form the verification pipeline consumed by the orchestrator (Plan 03).

Output: `src/verify/cbor.ts`, `src/verify/checks.ts`, updated `src/verify/types.ts` and `src/verify/index.ts`, plus comprehensive tests
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-verification/03-RESEARCH.md
@.planning/phases/03-verification/03-01-SUMMARY.md
@src/verify/types.ts
@src/verify/index.ts
@src/chain/provider.ts
</context>

<feature>
  <name>CBOR Transaction Deserialization</name>
  <files>src/verify/cbor.ts, tests/unit/verify/cbor.test.ts</files>
  <behavior>
  The `deserializeTransaction(base64Cbor: string)` function:

  1. Converts base64 string to hex via `Buffer.from(base64Cbor, 'base64').toString('hex')`
  2. Parses hex CBOR using `CML.Transaction.from_cbor_hex(cborHex)` (import CML from `@lucid-evolution/lucid`)
  3. Extracts transaction body fields into a structured `DeserializedTx` object:
     - `cborHex: string` (the hex representation for hashing)
     - `body.inputs: Array<{ txHash: string; index: bigint }>` (from `TransactionInputList`)
     - `body.outputs: Array<{ addressCborHex: string; addressBech32: string; lovelace: bigint; networkId: number }>` (from `TransactionOutputList`)
     - `body.fee: bigint` (from `TransactionBody.fee()`)
     - `body.ttl: bigint | undefined` (from `TransactionBody.ttl()`, may not be set)
     - `body.networkId: number | undefined` (from `TransactionBody.network_id()` or first output address)
     - `hasWitnesses: boolean` (true if VKey witnesses exist in witness set)
     - `txHash: string` (computed via `CML.hash_transaction(body).to_hex()`)

  Address comparison uses canonical CBOR hex (`address.to_cbor_hex()`), NOT bech32 string comparison (per research pitfall #2). Both hex and bech32 are stored for different uses.

  For networkId extraction: try `body.network_id()` first (returns NetworkId | undefined). If undefined, use `outputs[0].address().network_id()` as fallback.

  For witness check: parse `witness_set().to_json()` and check for `vkeywitnesses` array presence with length > 0.

  IMPORTANT CML memory management: Call `.free()` on CML objects in try/finally where practical, especially the top-level Transaction object after extraction is complete.

  Error handling:
  - If base64 decode produces invalid hex (not a valid hex string after conversion): throws with message containing "base64"
  - If CML.Transaction.from_cbor_hex() throws: let the CML error propagate (caught by checkCborValid)

  Test cases:
  - Valid transaction round-trip: build a minimal CML transaction, serialize to base64, deserialize back, verify all fields match
  - Invalid base64: pass non-base64 string (contains invalid characters), expect throw
  - Invalid CBOR hex: pass valid base64 that decodes to invalid CBOR, expect CML throw
  - Multi-output transaction: verify all outputs are parsed with correct addresses and amounts
  - Transaction with TTL set vs TTL not set
  - Transaction with vs without witnesses

  NOTE: Tests that construct CML Transaction objects will need the CML WASM to be loaded. If CML WASM init fails in test environment (libsodium issue), mock CML at the module level as done in Phase 2 integration tests. However, try without mocking first -- the libsodium fix (02-06) may have resolved this.
  </behavior>
  <implementation>
  Import `CML` from `@lucid-evolution/lucid`. Define `DeserializedTx` interface. Implement `deserializeTransaction()` as described above. Export both from the module.

  If CML WASM is problematic in tests, create a test helper that builds base64 CBOR test fixtures from known hex strings (hardcoded valid CBOR hex from a real testnet transaction).
  </implementation>
</feature>

<feature>
  <name>Verification Check Functions</name>
  <files>src/verify/checks.ts, src/verify/types.ts, tests/unit/verify/checks.test.ts</files>
  <behavior>
  Eight check functions, each with signature `(ctx: VerifyContext) => CheckResult | Promise<CheckResult>`:

  **First: Update `src/verify/types.ts` to add pipeline state fields to VerifyContext:**
  Add these optional fields to the VerifyContext interface for inter-check state sharing:
  ```typescript
  // Pipeline state (set by earlier checks, consumed by later checks)
  _parsedTx?: DeserializedTx;        // Set by checkCborValid
  _matchingOutputIndex?: number;      // Set by checkRecipient
  _matchingOutputAmount?: bigint;     // Set by checkRecipient
  ```
  Import `DeserializedTx` type from `./cbor.js`.

  **1. `checkCborValid(ctx)`**
  - Calls `deserializeTransaction(ctx.transactionCbor)`
  - On success: stores result on `ctx._parsedTx`, returns `{ check: 'cbor_valid', passed: true }`
  - On base64 error: `{ check: 'cbor_valid', passed: false, reason: 'invalid_base64' }`
  - On CBOR parse error: `{ check: 'cbor_valid', passed: false, reason: 'invalid_cbor', details: { error: cmlErrorMessage } }`

  **2. `checkScheme(ctx)`**
  - Checks `ctx.scheme === 'exact'`
  - Pass: `{ check: 'scheme', passed: true }`
  - Fail: `{ check: 'scheme', passed: false, reason: 'unsupported_scheme', details: { scheme: ctx.scheme } }`

  **3. `checkNetwork(ctx)`**
  - If no `ctx._parsedTx`: return `{ check: 'network', passed: false, reason: 'cbor_required' }` (dependency failed)
  - Checks `ctx.network === ctx.configuredNetwork` (CAIP-2 match)
  - Also checks tx output addresses have expected network ID via `CAIP2_TO_NETWORK_ID[ctx.configuredNetwork]`
  - Pass: `{ check: 'network', passed: true }`
  - Fail: `{ check: 'network', passed: false, reason: 'network_mismatch', details: { expected, actual } }`

  **4. `checkRecipient(ctx)`**
  - If no `ctx._parsedTx`: return dependency-failed result
  - Iterates outputs, comparing `addressCborHex` against `CML.Address.from_bech32(ctx.payTo).to_cbor_hex()`
  - Finds FIRST matching output, stores index and lovelace on ctx
  - Pass: `{ check: 'recipient', passed: true }`
  - Fail: `{ check: 'recipient', passed: false, reason: 'recipient_mismatch', details: { expected: ctx.payTo } }`

  **5. `checkAmount(ctx)`**
  - If no matching output: `{ check: 'amount', passed: false, reason: 'amount_insufficient', details: { error: 'no matching output found' } }`
  - Checks `ctx._matchingOutputAmount >= ctx.requiredAmount`
  - Pass: `{ check: 'amount', passed: true }`
  - Fail with details showing expected vs actual amounts (as strings for BigInt safety)

  **6. `checkWitness(ctx)`**
  - If no `ctx._parsedTx`: return dependency-failed result
  - Checks `ctx._parsedTx.hasWitnesses === true`
  - Pass: `{ check: 'witness', passed: true }`
  - Fail: `{ check: 'witness', passed: false, reason: 'missing_witness' }`

  **7. `checkTtl(ctx)` (async)**
  - If no `ctx._parsedTx`: return dependency-failed
  - If TTL undefined: skip -> `{ check: 'ttl', passed: true }`
  - If TTL set: call `ctx.getCurrentSlot()`, compare
  - Expired: `{ check: 'ttl', passed: false, reason: 'transaction_expired', details: { ttl, currentSlot } }`

  **8. `checkFee(ctx)`**
  - If no `ctx._parsedTx`: return dependency-failed
  - Checks `fee >= ctx.feeMin && fee <= ctx.feeMax`
  - Fail: `{ check: 'fee', passed: false, reason: 'unreasonable_fee', details: { fee, min, max } }`

  **Export `VERIFICATION_CHECKS` array** with all eight in order.

  Test cases for each check (use mock DeserializedTx objects on ctx._parsedTx to isolate check logic from CML):
  - checkCborValid: valid CBOR passes, invalid base64 -> 'invalid_base64', garbage hex -> 'invalid_cbor'
  - checkScheme: 'exact' passes, 'threshold' fails
  - checkNetwork: matching network passes, mismatched fails
  - checkRecipient: matching output passes, no match fails, multi-output with match passes
  - checkAmount: exact amount passes, overpay passes, insufficient fails
  - checkWitness: witnesses present passes, empty witness set fails
  - checkTtl: no TTL -> passes, future TTL -> passes, past TTL -> fails
  - checkFee: in-range passes, too low fails, too high fails
  </behavior>
  <implementation>
  Import types from `./types.js`, import `deserializeTransaction` from `./cbor.js`, import `CML` from `@lucid-evolution/lucid` (only in checkRecipient for address parsing).

  Update `src/verify/index.ts` barrel to export `deserializeTransaction`, `DeserializedTx`, all check functions, and `VERIFICATION_CHECKS`.
  </implementation>
</feature>

<verification>
- `pnpm test -- tests/unit/verify/` -- all new tests pass
- `pnpm test` -- full suite passes (no regressions)
- `pnpm build` succeeds
- `pnpm lint` passes
- cbor.ts exports `deserializeTransaction` and `DeserializedTx`
- checks.ts exports all 8 check functions and `VERIFICATION_CHECKS` array
- Each check function returns `CheckResult` with correct `check` name, `passed` boolean, and `reason` on failure
- Invalid base64 produces `invalid_base64`, invalid CBOR produces `invalid_cbor` (two-level granularity)
- Address comparison uses CBOR hex, not bech32 string comparison
- TTL check uses `getCurrentSlot()` from context
- Fee check uses configurable bounds from context
</verification>

<success_criteria>
CBOR deserialization extracts all needed transaction fields. All eight verification checks pass their tests independently. The VERIFICATION_CHECKS array defines the execution order. Pipeline state sharing via ctx._parsedTx avoids redundant CBOR parsing. Ready for orchestrator (Plan 03).
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-02-SUMMARY.md`
</output>
