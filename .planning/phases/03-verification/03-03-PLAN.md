---
phase: 03-verification
plan: 03
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/verify/checks.ts
  - tests/unit/verify/checks.test.ts
autonomous: true

must_haves:
  truths:
    - "Unsupported scheme is rejected with 'unsupported_scheme'"
    - "Network mismatch is rejected with 'network_mismatch'"
    - "Recipient mismatch is rejected with 'recipient_mismatch'"
    - "Expired payment is rejected with 'expired'"
    - "Future payment is rejected with 'payment_not_yet_valid'"
    - "Amount mismatch is rejected with 'amount_mismatch'"
    - "Insufficient balance is rejected with 'insufficient_funds'"
    - "Invalid CIP-8/CIP-30 signature is rejected with 'invalid_signature'"
    - "Valid signature extracts payer address from COSE_Sign1 into ctx.payerAddress"
    - "Balance check runs after signature check and uses extracted payerAddress"
    - "Invalid or consumed nonce is rejected with appropriate nonce reason"
    - "Nonce is consumed last (after all other checks) to allow client retry on non-nonce failures"
  artifacts:
    - path: "src/verify/checks.ts"
      provides: "8 verification check functions and VERIFICATION_CHECKS ordered array"
      exports: ["checkScheme", "checkNetwork", "checkRecipient", "checkTimeWindow", "checkAmount", "checkBalance", "checkSignature", "checkNonce", "VERIFICATION_CHECKS"]
    - path: "tests/unit/verify/checks.test.ts"
      provides: "Unit tests for all 8 check functions"
      min_lines: 150
  key_links:
    - from: "src/verify/checks.ts"
      to: "@lucid-evolution/lucid"
      via: "verifyData() for CIP-8/CIP-30 signature verification"
      pattern: "verifyData"
    - from: "src/verify/checks.ts"
      to: "src/verify/types.ts"
      via: "VerifyContext, CheckResult, VerifyDeps types"
      pattern: "VerifyContext|CheckResult|VerifyDeps"
    - from: "src/verify/checks.ts"
      to: "@emurgo/cardano-message-signing-nodejs"
      via: "COSESign1 parsing for payer address extraction in checkSignature"
      pattern: "COSESign1|COSE"
    - from: "src/verify/checks.ts"
      to: "@lucid-evolution/core-utils"
      via: "CML Address conversion (bech32 <-> hex) for verifyData parameters"
      pattern: "CML|Address|from_bech32|to_hex"
---

<objective>
Implement all 8 verification check functions using TDD -- the individual check functions that form the verification pipeline.

Purpose: Each check validates one aspect of the payment. The orchestrator (Plan 04) runs these in order and collects results. Breaking checks into individual functions enables isolated testing and clear error attribution. Check order is: scheme, network, recipient, timeWindow, amount, signature, balance, nonce. Balance runs after signature because it needs the payer address extracted from COSE_Sign1. Nonce is consumed last to allow client retry on other failures.

Output: Working, tested check functions in `src/verify/checks.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-verification/03-CONTEXT.md
@.planning/phases/03-verification/03-RESEARCH.md
@.planning/phases/03-verification/03-01-SUMMARY.md
@src/verify/types.ts
@src/chain/provider.ts
@src/chain/types.ts
</context>

<feature>
  <name>Verification check functions - ordered pipeline</name>
  <files>src/verify/checks.ts, tests/unit/verify/checks.test.ts</files>
  <behavior>
All check functions have signature: `(ctx: VerifyContext, deps: VerifyDeps) => Promise<CheckResult>`

`VerifyDeps` is defined in `src/verify/types.ts` (created in Plan 03-01) with `NonceConsumer` interface for nonce consumption. Import `VerifyDeps`, `VerifyContext`, `CheckResult`, and `VerifyCheck` from there. Plan 03-01 defines `VerifyCheck` as `(ctx: VerifyContext, deps: VerifyDeps) => Promise<CheckResult>` so the type is already correct.

**Check 1: checkScheme**
- Input: ctx.scheme
- Pass: scheme === 'exact' (only supported scheme in Phase 3)
- Fail: `{ check: 'scheme', passed: false, reason: 'unsupported_scheme' }`

**Check 2: checkNetwork**
- Input: ctx.network, deps.config.network
- Convert config network (e.g., 'Preview') to CAIP-2 (e.g., 'cardano:preview') using CAIP2_CHAIN_IDS
- Pass: ctx.network === expected CAIP-2 string
- Fail: `{ check: 'network', passed: false, reason: 'network_mismatch' }`

**Check 3: checkRecipient**
- Input: ctx.payTo, deps.config (facilitator address -- derive from config or pass via context)
- NOTE: For Phase 3, the facilitator address needs to be available. The ChainProvider has getLucid() which can derive the address. For now, add `facilitatorAddress: string` to VerifyContext (set during context assembly in the orchestrator).
- Pass: ctx.payTo === ctx.facilitatorAddress
- Fail: `{ check: 'recipient', passed: false, reason: 'recipient_mismatch' }`

**Check 4: checkTimeWindow**
- Input: ctx.maxTimeoutSeconds, ctx.requestedAt, deps.config.verification.graceBufferSeconds
- The payment was signed with a maxTimeoutSeconds. The payment is valid from signing time until signing time + maxTimeoutSeconds.
- Since we don't have the exact signing timestamp, use the nonce timestamp as proxy (embedded in nonce format).
- Extract nonce timestamp from ctx.nonce (parse `{timestamp}-{random}`)
- validUntil = nonceTimestamp + (ctx.maxTimeoutSeconds * 1000)
- Pass: ctx.requestedAt <= validUntil + (graceBuffer * 1000) AND nonceTimestamp <= ctx.requestedAt (not future)
- If nonceTimestamp > ctx.requestedAt: `{ check: 'time_window', passed: false, reason: 'payment_not_yet_valid' }`
- If ctx.requestedAt > validUntil + graceBuffer: `{ check: 'time_window', passed: false, reason: 'expired' }`

**Check 5: checkAmount**
- Input: ctx.maxAmountRequired
- Pass: ctx.maxAmountRequired > 0n (basic sanity -- amount must be positive)
- Note: In "exact" scheme, the amount in PaymentRequirements IS the required amount. The actual amount matching happens during settlement. Here we just validate it's a positive value.
- Fail: `{ check: 'amount', passed: false, reason: 'amount_mismatch' }`

**Check 6: checkSignature**
- Input: ctx.signature, ctx.key, ctx.nonce, ctx.payTo
- Uses `verifyData()` from `@lucid-evolution/lucid`
- Wrap the entire check in try/catch. On any exception, return `{ check: 'signature', passed: false, reason: 'invalid_signature' }`

**Step-by-step implementation for COSE parameter extraction:**

The `verifyData(addressHex, keyHash, payloadHex, signedMessage)` function requires 4 parameters that must be carefully prepared:

**(a) payloadHex** -- the hex-encoded nonce that was signed:
```typescript
const payloadHex = Buffer.from(ctx.nonce).toString('hex');
```

**(b) signedMessage** -- pass through directly from CIP-30 signData output:
```typescript
const signedMessage = { signature: ctx.signature, key: ctx.key };
```

**(c) addressHex** -- convert payer's bech32 address to raw hex bytes:
The payer address is NOT in ctx yet (that's what we're trying to extract). We need to get the address from the COSE_Sign1 protected headers. Use `@emurgo/cardano-message-signing-nodejs` (available as transitive dep) to parse the COSE_Sign1:
```typescript
import { COSESign1 } from '@emurgo/cardano-message-signing-nodejs';
import { CML } from '@lucid-evolution/core-utils';  // or import CML directly

// Parse COSE_Sign1 from signature hex to extract the address
const coseSign1 = COSESign1.from_bytes(Buffer.from(ctx.signature, 'hex'));
const protectedHeaders = coseSign1.headers().protected().deserialized_headers();
const addressBytes = protectedHeaders.header(CML.Label.new_text('address'))?.as_bytes();
// addressHex is the raw address bytes as hex
const addressHex = Buffer.from(addressBytes).toString('hex');
```

**Alternative (simpler, recommended if verifyData handles internally):** If reading the `verifyData()` source confirms it extracts the address from the COSE_Sign1 internally and only uses addressHex for COMPARISON, then we can derive addressHex from ctx.payTo (the facilitator address in payment requirements -- but this is WRONG because the signer is the PAYER, not the facilitator). The correct approach: the COSE_Sign1 protected headers contain the signer's address. Extract it as shown above, OR use `getAddressDetails()` from Lucid if we know the payer's bech32 address from another source.

**Practical recommendation for executor:** Read the actual `verifyData()` source at `node_modules/.pnpm/@lucid-evolution+sign_data@*/node_modules/@lucid-evolution/sign_data/dist/index.js` before implementing. The function may handle address extraction and key hash derivation internally from the COSE structures, in which case you only need to provide the "expected" addressHex for comparison. If so:
```typescript
// If we know the payer address (e.g., from client-provided data or COSE extraction):
const addressHex = CML.Address.from_bech32(payerBech32).to_hex();
```

**(d) keyHash** -- blake2b-224 hash of the public key from the COSE_Key:
```typescript
import { COSEKey } from '@emurgo/cardano-message-signing-nodejs';
import { CML } from '@lucid-evolution/core-utils';

// Parse COSE_Key to extract public key bytes
const coseKey = COSEKey.from_bytes(Buffer.from(ctx.key, 'hex'));
const publicKeyBytes = coseKey.header(CML.Label.new_int(CML.Int.new_negative(CML.BigNum.from_str('2'))))?.as_bytes();
// Hash with blake2b-224 to get keyHash
const publicKey = CML.PublicKey.from_bytes(publicKeyBytes);
const keyHash = publicKey.hash().to_hex();
```

**Alternative (if verifyData handles internally):** `verifyData()` may compute the keyHash internally from the COSE_Key. In that case, derive keyHash from the payer's address payment credential:
```typescript
const addressDetails = getAddressDetails(payerBech32);
const keyHash = addressDetails.paymentCredential?.hash;
```
where `getAddressDetails` is from `@lucid-evolution/lucid`.

**After verifyData succeeds, extract payer address for ctx.payerAddress:**
```typescript
// Extract payer bech32 address from COSE_Sign1 protected headers
// The address bytes from COSE_Sign1 can be converted back to bech32:
const payerAddress = CML.Address.from_bytes(addressBytes).to_bech32();
// OR if we extracted addressHex:
const payerAddress = CML.Address.from_hex(addressHex).to_bech32();
ctx.payerAddress = payerAddress;
```

- Pass: verifyData returns true
- Fail: `{ check: 'signature', passed: false, reason: 'invalid_signature' }`
- After successful verification, set ctx.payerAddress from the extracted COSE address. This MUST happen before checkBalance runs so the balance check has the payer address.

**Check 7: checkBalance**
- Input: ctx.payerAddress, ctx.maxAmountRequired, deps.chainProvider
- If no payerAddress (signature check failed or was skipped): skip with `{ check: 'balance', passed: true }` (balance is definitively checked at settlement time regardless)
- Otherwise: `const balance = await deps.chainProvider.getBalance(ctx.payerAddress)`
- Pass: balance >= ctx.maxAmountRequired
- Fail: `{ check: 'balance', passed: false, reason: 'insufficient_funds' }`
- NOTE: Balance check runs AFTER signature check (Check 6) because it needs the payerAddress that checkSignature extracts from the COSE_Sign1 structure. This ordering enables early "insufficient_funds" feedback when the signature is valid. If signature fails, balance gracefully skips (no payerAddress = pass/skip).

**Check 8: checkNonce**
- Input: ctx.nonce, deps.nonceStore
- Call `deps.nonceStore.consume(ctx.nonce)`
- Pass: result.valid === true
- Fail: `{ check: 'nonce', passed: false, reason: result.reason }` (forwards the specific nonce failure reason: nonce_invalid_format, nonce_expired, nonce_already_used, nonce_unknown)
- NOTE: Nonce check is LAST because it has a side effect (marks nonce as used). If earlier checks fail, we don't want to consume the nonce -- the client should fix issues and retry with the same nonce.

**ORDERING RATIONALE -- Why nonce is checked LAST despite "invalid signatures rejected before state changes":**

The locked decision "Invalid signatures rejected before any state changes" refers to **settlement state changes** (UTXO reservation, on-chain transactions), NOT verification-level bookkeeping. Nonce consumption during verification is a verification-level state change that tracks replay prevention -- it does not move funds or reserve UTXOs.

The current ordering (signature at Check 6, nonce at Check 8) is intentionally correct because:
1. **Client retry UX:** If a client submits a malformed signature, they can fix the signature and retry with the same nonce. Consuming the nonce on a bad signature would force the client to request a new nonce for every failed attempt.
2. **Scope of "state changes":** The security concern is that an invalid signature should never trigger settlement (fund movement). Nonce tracking is a verification-internal concern, not a settlement concern.
3. **EVM reference parity:** The x402 EVM reference implementation also validates the signature before consuming the authorization nonce (ERC-3009 `transferWithAuthorization` checks signature validity before marking the authorization as used).

Executors: Add a code comment in checks.ts above the VERIFICATION_CHECKS array explaining this ordering decision so future maintainers understand why nonce is last.

**Export the ordered array:**
```typescript
export const VERIFICATION_CHECKS: VerifyCheck[] = [
  checkScheme,      // 1. Reject unsupported schemes immediately
  checkNetwork,     // 2. Reject wrong network
  checkRecipient,   // 3. Reject wrong recipient
  checkTimeWindow,  // 4. Reject expired/future payments
  checkAmount,      // 5. Reject invalid amounts
  checkSignature,   // 6. Verify CIP-8/CIP-30 signature (extracts payerAddress)
  checkBalance,     // 7. Check payer balance (needs payerAddress from step 6)
  checkNonce,       // 8. Consume nonce LAST (side effect -- see ordering note below)
];
```

**Test cases:**

For each check, create tests with a mock VerifyContext and mock VerifyDeps:
- checkScheme: 'exact' -> passes; 'flexible' -> fails with 'unsupported_scheme'
- checkNetwork: matching CAIP-2 -> passes; mismatched -> fails with 'network_mismatch'
- checkRecipient: matching address -> passes; different address -> fails with 'recipient_mismatch'
- checkTimeWindow: within window -> passes; expired -> fails with 'expired'; future nonce -> fails with 'payment_not_yet_valid'
- checkAmount: positive bigint -> passes; 0n -> fails with 'amount_mismatch'
- checkSignature: mock verifyData to return true -> passes and sets ctx.payerAddress; mock returns false -> fails with 'invalid_signature'; mock throws -> fails with 'invalid_signature'
- checkBalance: sufficient -> passes; insufficient -> fails with 'insufficient_funds'; no payerAddress (sig failed) -> passes (skip)
- checkNonce: mock nonceStore.consume returns valid -> passes; returns invalid with reason -> fails with that reason

Mock `verifyData` at the module level using vi.mock. Mock ChainProvider.getBalance using vi.fn(). Mock NonceStore.consume using vi.fn().

The VERIFICATION_CHECKS array should have exactly 8 entries in the specified order.
  </behavior>
  <implementation>
Import verifyData from '@lucid-evolution/lucid'. The COSE parameter extraction is the hardest part of this plan -- see the detailed guidance in Check 6 above.

**CRITICAL -- Read verifyData() source first:** Before implementing checkSignature, read the actual `verifyData()` source at `node_modules/.pnpm/@lucid-evolution+sign_data@*/node_modules/@lucid-evolution/sign_data/dist/index.js`. The function likely handles COSE_Sign1 parsing and address/keyHash extraction internally. Understanding what it does internally determines whether you need to pre-extract addressHex/keyHash or just provide expected values for comparison.

For address conversion (bech32 to hex), use `CML.Address.from_bech32(addr).to_hex()` via `@lucid-evolution/core-utils` or the CML re-export from Lucid. For keyHash, use `getAddressDetails()` from Lucid (returns `paymentCredential.hash`) or `CML.PublicKey.from_bytes(pubkeyBytes).hash().to_hex()`.

For extracting the payer address from COSE_Sign1 (needed for ctx.payerAddress): Use `@emurgo/cardano-message-signing-nodejs` COSESign1 class to parse protected headers and extract address bytes, then convert to bech32 via CML.

Reference: Research PITFALL 1 (address format mismatch) and PITFALL 2 (keyHash derivation). Both are documented in 03-RESEARCH.md Common Pitfalls section.

Mock strategy for tests:
- vi.mock('@lucid-evolution/lucid') for verifyData
- Create mock VerifyContext factory with sensible defaults
- Create mock VerifyDeps with vi.fn() stubs

After implementing, update `src/verify/index.ts` barrel to export all check functions and VERIFICATION_CHECKS.
  </implementation>
</feature>

<verification>
- `pnpm test -- tests/unit/verify/checks.test.ts` -- all tests pass
- `pnpm test` -- full suite passes
- `pnpm build` succeeds
- Each check function returns CheckResult with correct reason strings matching x402 snake_case convention
</verification>

<success_criteria>
All 8 check functions implemented and tested. Each returns CheckResult with the correct pass/fail and snake_case reason. VERIFICATION_CHECKS array exported in correct order: scheme, network, recipient, timeWindow, amount, signature, balance, nonce. Signature check uses Lucid's verifyData() with properly extracted COSE parameters (addressHex, keyHash) and sets ctx.payerAddress. Balance check runs after signature and uses payerAddress. Nonce check is last (side-effect ordering, with code comment explaining why).
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-03-SUMMARY.md`
</output>
