---
phase: 03-verification
plan: 03
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/verify/checks.ts
  - tests/unit/verify/checks.test.ts
autonomous: true

must_haves:
  truths:
    - "Unsupported scheme is rejected with 'unsupported_scheme'"
    - "Network mismatch is rejected with 'network_mismatch'"
    - "Recipient mismatch is rejected with 'recipient_mismatch'"
    - "Expired payment is rejected with 'expired'"
    - "Future payment is rejected with 'payment_not_yet_valid'"
    - "Amount mismatch is rejected with 'amount_mismatch'"
    - "Insufficient balance is rejected with 'insufficient_funds'"
    - "Invalid CIP-8/CIP-30 signature is rejected with 'invalid_signature'"
    - "Invalid or consumed nonce is rejected with appropriate nonce reason"
  artifacts:
    - path: "src/verify/checks.ts"
      provides: "8 verification check functions and VERIFICATION_CHECKS ordered array"
      exports: ["checkScheme", "checkNetwork", "checkRecipient", "checkTimeWindow", "checkAmount", "checkBalance", "checkSignature", "checkNonce", "VERIFICATION_CHECKS"]
    - path: "tests/unit/verify/checks.test.ts"
      provides: "Unit tests for all 8 check functions"
      min_lines: 150
  key_links:
    - from: "src/verify/checks.ts"
      to: "@lucid-evolution/lucid"
      via: "verifyData() for CIP-8/CIP-30 signature verification"
      pattern: "verifyData"
    - from: "src/verify/checks.ts"
      to: "src/verify/types.ts"
      via: "VerifyContext, CheckResult types"
      pattern: "VerifyContext|CheckResult"
---

<objective>
Implement all 8 verification check functions using TDD -- the individual check functions that form the verification pipeline.

Purpose: Each check validates one aspect of the payment (scheme, network, recipient, time window, amount, balance, signature, nonce). The orchestrator (Plan 05) runs these in order and collects results. Breaking checks into individual functions enables isolated testing and clear error attribution.

Output: Working, tested check functions in `src/verify/checks.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-verification/03-CONTEXT.md
@.planning/phases/03-verification/03-RESEARCH.md
@.planning/phases/03-verification/03-01-SUMMARY.md
@src/verify/types.ts
@src/chain/provider.ts
@src/chain/types.ts
</context>

<feature>
  <name>Verification check functions - ordered pipeline</name>
  <files>src/verify/checks.ts, tests/unit/verify/checks.test.ts</files>
  <behavior>
All check functions have signature: `(ctx: VerifyContext) => Promise<CheckResult>`

The VerifyContext includes an `deps` bag that provides runtime dependencies:
```typescript
interface VerifyDeps {
  chainProvider: ChainProvider;
  nonceStore: NonceStore;
  config: ChainConfig;
}
```
Add `deps: VerifyDeps` to VerifyContext (update types.ts if needed, or pass deps separately -- the function signature can be `(ctx: VerifyContext, deps: VerifyDeps) => Promise<CheckResult>`).

**Check 1: checkScheme**
- Input: ctx.scheme
- Pass: scheme === 'exact' (only supported scheme in Phase 3)
- Fail: `{ check: 'scheme', passed: false, reason: 'unsupported_scheme' }`

**Check 2: checkNetwork**
- Input: ctx.network, deps.config.network
- Convert config network (e.g., 'Preview') to CAIP-2 (e.g., 'cardano:preview') using CAIP2_CHAIN_IDS
- Pass: ctx.network === expected CAIP-2 string
- Fail: `{ check: 'network', passed: false, reason: 'network_mismatch' }`

**Check 3: checkRecipient**
- Input: ctx.payTo, deps.config (facilitator address -- derive from config or pass via context)
- NOTE: For Phase 3, the facilitator address needs to be available. The ChainProvider has getLucid() which can derive the address. For now, add `facilitatorAddress: string` to VerifyContext (set during context assembly in the orchestrator).
- Pass: ctx.payTo === ctx.facilitatorAddress
- Fail: `{ check: 'recipient', passed: false, reason: 'recipient_mismatch' }`

**Check 4: checkTimeWindow**
- Input: ctx.maxTimeoutSeconds, ctx.requestedAt, deps.config.verification.graceBufferSeconds
- The payment was signed with a maxTimeoutSeconds. The payment is valid from signing time until signing time + maxTimeoutSeconds.
- Since we don't have the exact signing timestamp, use the nonce timestamp as proxy (embedded in nonce format).
- Extract nonce timestamp from ctx.nonce (parse `{timestamp}-{random}`)
- validUntil = nonceTimestamp + (ctx.maxTimeoutSeconds * 1000)
- Pass: ctx.requestedAt <= validUntil + (graceBuffer * 1000) AND nonceTimestamp <= ctx.requestedAt (not future)
- If nonceTimestamp > ctx.requestedAt: `{ check: 'time_window', passed: false, reason: 'payment_not_yet_valid' }`
- If ctx.requestedAt > validUntil + graceBuffer: `{ check: 'time_window', passed: false, reason: 'expired' }`

**Check 5: checkBalance**
- Input: ctx.payerAddress, ctx.maxAmountRequired, deps.chainProvider
- If no payerAddress yet (can't extract before signature check): skip with `{ check: 'balance', passed: true }` (balance re-checked at settlement)
- Otherwise: `const balance = await deps.chainProvider.getBalance(ctx.payerAddress)`
- Pass: balance >= ctx.maxAmountRequired
- Fail: `{ check: 'balance', passed: false, reason: 'insufficient_funds' }`

**Check 6: checkAmount**
- Input: ctx.maxAmountRequired
- Pass: ctx.maxAmountRequired > 0n (basic sanity -- amount must be positive)
- Note: In "exact" scheme, the amount in PaymentRequirements IS the required amount. The actual amount matching happens during settlement. Here we just validate it's a positive value.
- Fail: `{ check: 'amount', passed: false, reason: 'amount_mismatch' }`

**Check 7: checkSignature**
- Input: ctx.signature, ctx.key, ctx.nonce, ctx.payTo
- Uses `verifyData()` from `@lucid-evolution/lucid`
- The payload that was signed is the nonce (hex-encoded). Convert nonce string to hex: `Buffer.from(ctx.nonce).toString('hex')`
- The addressHex needs bech32-to-hex conversion. Use CML: import from `@lucid-evolution/lucid` or `@anastasia-labs/cardano-multiplatform-lib-nodejs`
- The keyHash is blake2b-224 of the public key extracted from COSE_Key. However, `verifyData()` handles this internally -- it takes `(addressHex, keyHash, payloadHex, signedMessage)`.
- CRITICAL PITFALL: We need to extract addressHex and keyHash from the COSE structures BEFORE calling verifyData(). Read the verifyData() source to understand exact parameters:
  - `addressHex`: hex of the address the signer claims (extract from COSE_Sign1 protected headers, or use the payTo address converted to hex)
  - `keyHash`: blake2b-224 hash of the public key
  - `payloadHex`: hex of the payload that was signed (the nonce)
  - `signedMessage`: `{ signature: ctx.signature, key: ctx.key }` (hex strings from CIP-30 signData)
- Wrap in try/catch. On any exception, return `{ check: 'signature', passed: false, reason: 'invalid_signature' }`
- Pass: verifyData returns true
- Fail: `{ check: 'signature', passed: false, reason: 'invalid_signature' }`
- After successful verification, extract the payer address from the COSE_Sign1 protected headers and set it on ctx.payerAddress (mutate context).

**Check 8: checkNonce**
- Input: ctx.nonce, deps.nonceStore
- Call `deps.nonceStore.consume(ctx.nonce)`
- Pass: result.valid === true
- Fail: `{ check: 'nonce', passed: false, reason: result.reason }` (forwards the specific nonce failure reason: nonce_invalid_format, nonce_expired, nonce_already_used, nonce_unknown)
- NOTE: Nonce check is LAST because it has a side effect (marks nonce as used). If earlier checks fail, we don't want to consume the nonce -- the client should fix issues and retry with the same nonce.

**Export the ordered array:**
```typescript
export const VERIFICATION_CHECKS: VerifyCheck[] = [
  checkScheme,
  checkNetwork,
  checkRecipient,
  checkTimeWindow,
  checkBalance,
  checkAmount,
  checkSignature,
  checkNonce,
];
```

**Test cases:**

For each check, create tests with a mock VerifyContext and mock VerifyDeps:
- checkScheme: 'exact' -> passes; 'flexible' -> fails with 'unsupported_scheme'
- checkNetwork: matching CAIP-2 -> passes; mismatched -> fails with 'network_mismatch'
- checkRecipient: matching address -> passes; different address -> fails with 'recipient_mismatch'
- checkTimeWindow: within window -> passes; expired -> fails with 'expired'; future nonce -> fails with 'payment_not_yet_valid'
- checkBalance: sufficient -> passes; insufficient -> fails with 'insufficient_funds'; no payerAddress -> passes (skip)
- checkAmount: positive bigint -> passes; 0n -> fails with 'amount_mismatch'
- checkSignature: mock verifyData to return true -> passes; mock returns false -> fails with 'invalid_signature'; mock throws -> fails with 'invalid_signature'
- checkNonce: mock nonceStore.consume returns valid -> passes; returns invalid with reason -> fails with that reason

Mock `verifyData` at the module level using vi.mock. Mock ChainProvider.getBalance using vi.fn(). Mock NonceStore.consume using vi.fn().

The VERIFICATION_CHECKS array should have exactly 8 entries in the specified order.
  </behavior>
  <implementation>
Import verifyData from '@lucid-evolution/lucid'. For address conversion (bech32 to hex), try importing from Lucid's utilities or CML. If CML import is complex, use a helper function.

For the blake2b-224 key hash, explore if Lucid provides a utility or if we need to use CML's `PublicKey.from_bytes().hash()`.

Mock strategy for tests:
- vi.mock('@lucid-evolution/lucid') for verifyData
- Create mock VerifyContext factory with sensible defaults
- Create mock VerifyDeps with vi.fn() stubs

After implementing, update `src/verify/index.ts` barrel to export all check functions and VERIFICATION_CHECKS.
  </implementation>
</feature>

<verification>
- `pnpm test -- tests/unit/verify/checks.test.ts` -- all tests pass
- `pnpm test` -- full suite passes
- `pnpm build` succeeds
- Each check function returns CheckResult with correct reason strings matching x402 snake_case convention
</verification>

<success_criteria>
All 8 check functions implemented and tested. Each returns CheckResult with the correct pass/fail and snake_case reason. VERIFICATION_CHECKS array exported in correct order. Signature check uses Lucid's verifyData(). Nonce check is last (side-effect ordering).
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-03-SUMMARY.md`
</output>
