---
phase: 03-verification
plan: 03
type: tdd
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/verify/verify-payment.ts
  - src/verify/index.ts
  - tests/unit/verify/verify-payment.test.ts
autonomous: true

must_haves:
  truths:
    - "Verification orchestrator runs all checks and collects all failures (not fail-fast)"
    - "Success response includes isValid: true, payer address, and transaction hash in extensions"
    - "Failure response includes isValid: false, primary invalidReason (first failure), and all errors in extensions.errors"
    - "All BigInt values are converted to strings before JSON serialization"
    - "HTTP response is always 200 regardless of verification result"
  artifacts:
    - path: "src/verify/verify-payment.ts"
      provides: "Verification orchestrator that runs VERIFICATION_CHECKS and builds VerifyResponse"
      exports: ["verifyPayment"]
    - path: "tests/unit/verify/verify-payment.test.ts"
      provides: "Unit tests for orchestrator covering success, single failure, multi-failure, and edge cases"
      min_lines: 60
  key_links:
    - from: "src/verify/verify-payment.ts"
      to: "src/verify/checks.ts"
      via: "Imports and iterates VERIFICATION_CHECKS array"
      pattern: "VERIFICATION_CHECKS"
    - from: "src/verify/verify-payment.ts"
      to: "src/verify/types.ts"
      via: "Uses VerifyContext to build context, VerifyResponse for output shape"
      pattern: "VerifyContext.*VerifyResponse"
---

<objective>
Implement the verification orchestrator using TDD -- the function that runs all verification checks, collects errors, and builds the x402 V2 VerifyResponse.

Purpose: This is the coordination layer between the route handler and individual checks. It iterates VERIFICATION_CHECKS, collects all CheckResults, and constructs the appropriate success or failure response. The key requirement is collect-all-errors behavior (not fail-fast), with the first error becoming the primary `invalidReason`.

Output: Working, tested `verifyPayment()` function in `src/verify/verify-payment.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-verification/03-RESEARCH.md
@.planning/phases/03-verification/03-01-SUMMARY.md
@.planning/phases/03-verification/03-02-SUMMARY.md
@src/verify/types.ts
@src/verify/checks.ts
@src/verify/cbor.ts
</context>

<feature>
  <name>Verification Orchestrator - verifyPayment()</name>
  <files>src/verify/verify-payment.ts, tests/unit/verify/verify-payment.test.ts</files>
  <behavior>
  The `verifyPayment(ctx: VerifyContext)` function:

  1. Iterates all checks from `VERIFICATION_CHECKS` array (imported from `./checks.js`)
  2. Awaits each check (some are async, e.g., checkTtl which calls getCurrentSlot())
  3. Collects all failed CheckResults into an `errors` array
  4. Builds the VerifyResponse based on results

  **Important behavior:** Run ALL checks, not fail-fast. Even if checkCborValid fails, still run checkScheme (which doesn't need parsed tx). However, checks that depend on `ctx._parsedTx` will return dependency-failed results if CBOR parsing failed. This is correct behavior -- the pipeline naturally degrades.

  **Success response (no failures):**
  ```typescript
  {
    isValid: true,
    payer: ctx.payerAddress ?? undefined,
    extensions: {
      scheme: ctx.scheme,
      amount: ctx.requiredAmount.toString(),
      payTo: ctx.payTo,
      txHash: ctx._parsedTx?.txHash,
    },
  }
  ```

  **Failure response (one or more failures):**
  ```typescript
  {
    isValid: false,
    invalidReason: errors[0].reason,       // Primary failure (first in check order)
    invalidMessage: describeFailure(errors[0]),  // Human-readable message
    payer: ctx.payerAddress ?? undefined,
    extensions: {
      errors: errors.map(e => e.reason),   // All failure reasons
      // Include details from first failure for debugging
      ...(errors[0].details ? { expected: errors[0].details } : {}),
    },
  }
  ```

  **Helper: `describeFailure(result: CheckResult): string`**
  Maps snake_case reasons to human-readable messages:
  - 'invalid_base64' -> 'Transaction data is not valid base64'
  - 'invalid_cbor' -> 'Transaction CBOR could not be parsed'
  - 'unsupported_scheme' -> 'Payment scheme is not supported'
  - 'network_mismatch' -> 'Transaction targets the wrong network'
  - 'recipient_mismatch' -> 'No output pays to the required recipient'
  - 'amount_insufficient' -> 'Payment amount is less than required'
  - 'missing_witness' -> 'Transaction has no signatures'
  - 'transaction_expired' -> 'Transaction TTL has expired'
  - 'unreasonable_fee' -> 'Transaction fee is outside acceptable bounds'
  - 'cbor_required' -> 'Transaction CBOR is required for this check'
  - default -> `Verification failed: ${reason}`

  **BigInt safety:** All BigInt values must be converted to strings before inclusion in the response object (which will be JSON-serialized by Fastify). The `extensions` object must contain only JSON-safe values.

  **Logging:** The orchestrator should accept an optional logger (Fastify logger) and log:
  - On success: log.info({ payer, txHash, scheme }, 'Payment verified')
  - On failure: log.info({ payer, reasons: errors.map(e => e.reason) }, 'Payment verification failed')
  - Do NOT log the raw transaction CBOR (could be large)

  **Function signature:**
  ```typescript
  export async function verifyPayment(
    ctx: VerifyContext,
    logger?: FastifyBaseLogger
  ): Promise<VerifyResponse>
  ```
  Import `VerifyResponse` type from types (the inferred Zod type). The return value must conform to the VerifyResponseSchema shape.

  **Test cases:**

  1. **All checks pass:** Build a VerifyContext where all checks will pass. Mock `deserializeTransaction` to return a valid DeserializedTx. Expect `{ isValid: true, payer, extensions: { txHash } }`.

  2. **Single failure (scheme mismatch):** Set scheme to 'threshold'. Expect `{ isValid: false, invalidReason: 'unsupported_scheme' }`.

  3. **Multiple failures:** Set scheme to 'threshold' AND set invalid CBOR. Expect `invalidReason` to be the first failure in VERIFICATION_CHECKS order, and `extensions.errors` to contain all failure reasons.

  4. **CBOR failure cascading:** Set invalid CBOR. Expect cbor_valid fails, plus network/recipient/witness/ttl/fee return dependency-failed results. But scheme still passes (no CBOR dependency).

  5. **BigInt serialization:** Ensure no BigInt values in the returned object (would crash JSON.stringify).

  6. **Payer address included:** When ctx.payerAddress is set, it appears in both success and failure responses.

  7. **No payer address:** When ctx.payerAddress is undefined, the `payer` field is undefined in the response.

  Mock strategy:
  - Mock `./checks.js` module to provide controllable check functions, OR
  - Create realistic VerifyContext objects with mock functions (getCurrentSlot) and let real checks run
  - For simpler tests, mock the entire VERIFICATION_CHECKS array with custom check functions that return predetermined results
  </behavior>
  <implementation>
  Import `VERIFICATION_CHECKS` from `./checks.js` and `VerifyContext`, `VerifyResponse`, `CheckResult` from `./types.js`.

  Implement as a simple async loop:
  ```typescript
  const errors: CheckResult[] = [];
  for (const check of VERIFICATION_CHECKS) {
    const result = await check(ctx);
    if (!result.passed) {
      errors.push(result);
    }
  }
  ```

  Then build the response based on `errors.length === 0`.

  Update `src/verify/index.ts` barrel to export `verifyPayment`.
  </implementation>
</feature>

<verification>
- `pnpm test -- tests/unit/verify/verify-payment.test.ts` -- all tests pass
- `pnpm test` -- full suite passes
- `pnpm build` succeeds
- `pnpm lint` passes
- verifyPayment() runs all checks even after first failure
- Success response includes txHash in extensions
- Failure response includes primary reason + all errors
- No BigInt values in response objects
</verification>

<success_criteria>
verifyPayment() orchestrates the full verification pipeline, collecting all errors. Success returns isValid: true with transaction metadata. Failure returns isValid: false with primary reason and error list. All BigInt values safely converted. Ready for route integration (Plan 04).
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-03-SUMMARY.md`
</output>
