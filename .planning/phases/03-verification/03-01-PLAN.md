---
phase: 03-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/verify/types.ts
  - src/verify/errors.ts
  - src/verify/index.ts
  - src/config/schema.ts
  - src/chain/config.ts
  - src/errors/index.ts
autonomous: true

must_haves:
  truths:
    - "Verification domain types define the x402 V2 wire format for Cardano transaction-based model"
    - "Verification errors are distinct from chain errors and follow VERIFY_* naming"
    - "Config schema accepts verification settings (graceBufferSeconds, maxTimeoutSeconds, fee bounds) with defaults"
    - "CAIP-2 chain ID mapping exists for Preview, Preprod, Mainnet"
  artifacts:
    - path: "src/verify/types.ts"
      provides: "VerifyRequest, VerifyResponse, CardanoPayload, PaymentRequirements, CheckResult, VerifyContext Zod schemas and TS types"
      exports: ["VerifyRequestSchema", "VerifyResponseSchema", "CardanoPayloadSchema", "PaymentRequirementsSchema", "CheckResult", "VerifyCheck", "VerifyContext", "CAIP2_CHAIN_IDS", "CAIP2_TO_NETWORK_ID", "NETWORK_ID_EXPECTED"]
    - path: "src/verify/errors.ts"
      provides: "VERIFY_* domain errors"
      exports: ["VerifyInvalidFormatError", "VerifyInternalError"]
    - path: "src/verify/index.ts"
      provides: "Barrel exports for verify module"
    - path: "src/chain/config.ts"
      provides: "Extended config with verification section"
      contains: "verification"
  key_links:
    - from: "src/verify/types.ts"
      to: "x402 V2 spec"
      via: "VerifyRequest/VerifyResponse shapes matching spec with transaction-based payload"
      pattern: "isValid.*boolean"
    - from: "src/verify/types.ts"
      to: "src/chain/types.ts"
      via: "CardanoNetwork import for CAIP-2 mapping"
      pattern: "CAIP2_CHAIN_IDS"
    - from: "src/errors/index.ts"
      to: "src/verify/errors.ts"
      via: "re-export of VERIFY_* errors"
      pattern: "VerifyInvalidFormatError"
---

<objective>
Define all verification domain types, Zod schemas, domain errors, and config schema extension for Phase 3's transaction-based verification model.

Purpose: Establish the type foundation that all subsequent verification plans depend on. The key change from the old plans: NO nonces, NO COSE/CIP-8 types, NO NonceStore interface. The payload contains a single `transaction` field (base64-encoded signed CBOR) and an optional `payer` field. UTXO-based replay protection is inherent.

Output: `src/verify/types.ts`, `src/verify/errors.ts`, `src/verify/index.ts`, updated `src/chain/config.ts`, updated `src/errors/index.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-verification/03-CONTEXT.md
@.planning/phases/03-verification/03-RESEARCH.md
@src/chain/types.ts
@src/chain/config.ts
@src/config/schema.ts
@src/errors/index.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create verification types and Zod schemas for transaction-based model</name>
  <files>src/verify/types.ts</files>
  <action>
Create `src/verify/types.ts` with all verification domain types and Zod schemas.

IMPORTANT: This is the TRANSACTION-BASED model. There are NO nonces, NO COSE signatures, NO signData payloads.

**x402 V2 Wire Format Schemas (Zod):**

1. `PaymentRequirementsSchema` - what the server requires:
   - `scheme: z.literal('exact')` (only supported scheme for now)
   - `network: z.string().regex(/^[a-z0-9]+:[a-z0-9]+$/)` (CAIP-2 chain ID, e.g., "cardano:preview")
   - `asset: z.string()` ("lovelace" for ADA)
   - `maxAmountRequired: z.string().min(1)` (lovelace as string for BigInt safety in JSON; named per x402 spec)
   - `payTo: z.string().min(1)` (bech32 Cardano address of recipient)
   - `maxTimeoutSeconds: z.number().int().positive()`
   - `extra: z.record(z.unknown()).optional()` (PaymentRequirements uses `extra` per spec)
   - Use `.passthrough()` on the object for lenient unknown-field handling

2. `CardanoPayloadSchema` - what the client sends (transaction-based):
   - `transaction: z.string().min(1)` (base64-encoded signed CBOR transaction)
   - `payer: z.string().optional()` (bech32 address of the payer, declared by client)

3. `PaymentPayloadSchema` - the full payment payload wrapper:
   - `x402Version: z.literal(2)`
   - `scheme: z.literal('exact')`
   - `network: z.string()`
   - `payload: CardanoPayloadSchema`
   - Use `.passthrough()`

4. `VerifyRequestSchema` - POST /verify body:
   - `paymentPayload: PaymentPayloadSchema`
   - `paymentRequirements: PaymentRequirementsSchema`

5. `VerifyResponseSchema` - verify response (for documentation/testing, not runtime validation):
   - `isValid: z.boolean()`
   - `payer: z.string().optional()` (bech32 address)
   - `invalidReason: z.string().optional()` (snake_case reason code)
   - `invalidMessage: z.string().optional()` (human-readable message)
   - `extensions: z.record(z.unknown()).optional()` (NOTE: `extensions` not `extra` in VerifyResponse per x402 V2)

**Internal Types (plain TypeScript, no Zod):**

6. `CheckResult` interface:
   - `check: string` (check name, e.g., "cbor_valid", "scheme", "network")
   - `passed: boolean`
   - `reason?: string` (snake_case invalidReason, e.g., "invalid_cbor", "recipient_mismatch")
   - `details?: Record<string, unknown>` (debug info: expected vs actual values)

7. `VerifyCheck` type: `(ctx: VerifyContext) => CheckResult | Promise<CheckResult>`
   NOTE: No separate VerifyDeps -- the context carries everything needed.

8. `VerifyContext` interface (assembled by route handler from parsed request + runtime):
   - `scheme: string`
   - `network: string` (CAIP-2, e.g., "cardano:preview")
   - `payTo: string` (bech32 recipient)
   - `requiredAmount: bigint` (converted from string)
   - `maxTimeoutSeconds: number`
   - `transactionCbor: string` (base64-encoded signed CBOR from payload)
   - `payerAddress?: string` (from CardanoPayload.payer, if provided)
   - `requestedAt: number` (Date.now() when request arrived)
   - `getCurrentSlot: () => Promise<number>` (injected from ChainProvider)
   - `configuredNetwork: string` (the network our facilitator is configured for, as CAIP-2)
   - `feeMin: bigint` (from config, default 150_000n)
   - `feeMax: bigint` (from config, default 5_000_000n)

9. `CAIP2_CHAIN_IDS` constant mapping CardanoNetwork to CAIP-2 strings:
   ```typescript
   export const CAIP2_CHAIN_IDS = {
     Preview: 'cardano:preview',
     Preprod: 'cardano:preprod',
     Mainnet: 'cardano:mainnet',
   } as const;
   ```
   Import `CardanoNetwork` from `../chain/types.js`.

10. `CAIP2_TO_NETWORK_ID` constant mapping CAIP-2 strings to Cardano network IDs:
    ```typescript
    export const CAIP2_TO_NETWORK_ID: Record<string, number> = {
      'cardano:preview': 0,
      'cardano:preprod': 0,
      'cardano:mainnet': 1,
    };
    ```

11. Infer and export TypeScript types from all Zod schemas:
    ```typescript
    export type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;
    export type CardanoPayload = z.infer<typeof CardanoPayloadSchema>;
    export type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;
    export type VerifyRequest = z.infer<typeof VerifyRequestSchema>;
    export type VerifyResponse = z.infer<typeof VerifyResponseSchema>;
    ```

Export all schemas, inferred types, interfaces, the VerifyCheck type, and the CAIP2 constants.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile with no errors. The types file should export schemas (5), inferred types (5), interfaces (CheckResult, VerifyContext), VerifyCheck type, and CAIP2 constants (2).
  </verify>
  <done>All x402 V2 wire format types have Zod schemas reflecting the transaction-based model (no nonces, no COSE). Internal types (CheckResult, VerifyContext, VerifyCheck) are plain interfaces/types. CAIP2_CHAIN_IDS and CAIP2_TO_NETWORK_ID provide network mapping. No NonceStore, no NonceConsumer, no buildSignedPayload.</done>
</task>

<task type="auto">
  <name>Task 2: Create verification errors, barrel exports, and extend config</name>
  <files>src/verify/errors.ts, src/verify/index.ts, src/chain/config.ts, src/errors/index.ts</files>
  <action>
**1. Create `src/verify/errors.ts`:**

Using `@fastify/error` (same pattern as `src/chain/errors.ts`):
- `VerifyInvalidFormatError` - code `VERIFY_INVALID_FORMAT`, message `'Invalid verification request format: %s'`, status 200 (NOT 400 -- per locked decision "always HTTP 200")
- `VerifyInternalError` - code `VERIFY_INTERNAL_ERROR`, message `'Verification internal error: %s'`, status 500

NOTE: Most verification failures are NOT errors -- they return `{ isValid: false }` as HTTP 200. These errors are only for truly exceptional cases (e.g., CML WASM crash).

**2. Create `src/verify/index.ts`:**

Barrel exports for the verify module:
- All types and schemas from `./types.js` (use `export type { ... }` for type-only exports per ESM decision)
- All errors from `./errors.js`
- Comment placeholders for future exports: cbor, checks, verify-payment (Plans 02-04)

**3. Extend `src/chain/config.ts`:**

Add a `verification` section to `ChainConfigSchema` z.object (after `redis`, before `.superRefine`):
```typescript
verification: z.object({
  /** Grace buffer in seconds for TTL check (default 30s per locked decision) */
  graceBufferSeconds: z.number().int().min(0).max(120).default(30),
  /** Default max timeout in seconds (default 300s = 5 min) */
  maxTimeoutSeconds: z.number().int().min(60).max(3600).default(300),
  /** Minimum acceptable fee in lovelace (sanity check lower bound) */
  feeMinLovelace: z.number().int().min(100000).max(500000).default(150000),
  /** Maximum acceptable fee in lovelace (sanity check upper bound) */
  feeMaxLovelace: z.number().int().min(1000000).max(10000000).default(5000000),
}).default(() => ({
  graceBufferSeconds: 30,
  maxTimeoutSeconds: 300,
  feeMinLovelace: 150000,
  feeMaxLovelace: 5000000,
})),
```

NOTE: No `nonceTtlSeconds` -- there are no nonces in the transaction-based model.

**4. Update `src/errors/index.ts`:**

Add re-export of verify errors (same pattern as chain errors re-export):
```typescript
// Verification errors (VERIFY_*) - re-exported from verify domain
export {
  VerifyInvalidFormatError,
  VerifyInternalError,
} from '../verify/errors.js';
```

**5. Run `pnpm build` to verify everything compiles.**

IMPORTANT: The `verification` config section goes inside `ChainConfigSchema` because verification settings are chain-specific (grace buffer relates to Cardano block times, fee bounds are Cardano-specific).
  </action>
  <verify>
Run `pnpm build && pnpm lint && pnpm test`. All should pass. Verify `src/verify/index.ts` re-exports types and errors. Verify `src/errors/index.ts` re-exports VERIFY_* errors. Verify `src/chain/config.ts` includes the verification section with defaults. Existing tests must not break (defaults maintain backward compatibility).
  </verify>
  <done>VERIFY_* errors created with @fastify/error. Barrel exports working. Config schema extended with verification.graceBufferSeconds (default 30), verification.maxTimeoutSeconds (default 300), verification.feeMinLovelace (default 150000), verification.feeMaxLovelace (default 5000000). No nonce TTL. All existing tests still pass.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (existing tests unbroken by config extension -- defaults maintain backward compat)
- `npx tsc --noEmit` passes
- Types file exports Zod schemas for transaction-based VerifyRequest, CardanoPayload (with `transaction` field, no `signature`/`key`/`nonce`), PaymentRequirements
- CAIP2_CHAIN_IDS maps Preview/Preprod/Mainnet to cardano:* strings
- CAIP2_TO_NETWORK_ID maps cardano:* strings to 0/1 network IDs
- Config accepts verification section with grace buffer, timeout, and fee bounds
- NO nonce-related types, interfaces, or config exist anywhere in verify module
</verification>

<success_criteria>
All verification domain types, Zod schemas, errors, barrel exports, and config schema extensions exist and compile. The type foundation reflects the transaction-based model (not the old CIP-8/nonce model). No existing tests broken. Foundation ready for Plans 02-04.
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-01-SUMMARY.md`
</output>
