---
phase: 03-verification
plan: 04
type: execute
wave: 4
depends_on: ["03-03"]
files_modified:
  - src/routes/verify.ts
  - src/server.ts
  - tests/integration/verify-route.test.ts
autonomous: true

must_haves:
  truths:
    - "POST /verify accepts a JSON body matching VerifyRequestSchema and returns VerifyResponse"
    - "Invalid request bodies return HTTP 200 with isValid: false and invalidReason: 'invalid_request'"
    - "Valid request bodies are processed through verifyPayment() and return the verification result as HTTP 200"
    - "The verify route is registered as a Fastify plugin following the existing fp() pattern"
    - "Server.ts registers the verify route plugin alongside the health route"
  artifacts:
    - path: "src/routes/verify.ts"
      provides: "POST /verify route plugin"
      exports: ["verifyRoutesPlugin"]
    - path: "src/server.ts"
      provides: "Server factory with verify route registration"
      contains: "verifyRoutesPlugin"
    - path: "tests/integration/verify-route.test.ts"
      provides: "Integration tests for the /verify endpoint"
      min_lines: 60
  key_links:
    - from: "src/routes/verify.ts"
      to: "src/verify/verify-payment.ts"
      via: "Calls verifyPayment() with assembled VerifyContext"
      pattern: "verifyPayment"
    - from: "src/routes/verify.ts"
      to: "src/verify/types.ts"
      via: "Uses VerifyRequestSchema for request validation"
      pattern: "VerifyRequestSchema"
    - from: "src/server.ts"
      to: "src/routes/verify.ts"
      via: "Registers verifyRoutesPlugin"
      pattern: "verifyRoutesPlugin"
---

<objective>
Implement the POST /verify route and integrate it into the server.

Purpose: This is the final integration layer that exposes the verification pipeline via HTTP. The route validates the request body with Zod, assembles a VerifyContext from the parsed request and server state, calls verifyPayment(), and returns the result. All responses are HTTP 200.

Output: `src/routes/verify.ts`, updated `src/server.ts`, integration tests
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-verification/03-RESEARCH.md
@.planning/phases/03-verification/03-01-SUMMARY.md
@.planning/phases/03-verification/03-02-SUMMARY.md
@.planning/phases/03-verification/03-03-SUMMARY.md
@src/routes/health.ts
@src/server.ts
@src/verify/types.ts
@src/verify/verify-payment.ts
@src/verify/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /verify route plugin</name>
  <files>src/routes/verify.ts</files>
  <action>
Create `src/routes/verify.ts` following the exact pattern of `src/routes/health.ts`:

```typescript
import type { FastifyPluginCallback } from 'fastify';
import fp from 'fastify-plugin';
import { VerifyRequestSchema, CAIP2_CHAIN_IDS } from '../verify/types.js';
import { verifyPayment } from '../verify/verify-payment.js';
import type { VerifyContext } from '../verify/types.js';
import type { CardanoNetwork } from '../chain/types.js';
```

**Route: `POST /verify`**

1. **Parse request body** with `VerifyRequestSchema.safeParse(request.body)`:
   - If parsing fails: return HTTP 200 with:
     ```json
     {
       "isValid": false,
       "invalidReason": "invalid_request",
       "invalidMessage": "Request body does not match expected format",
       "extensions": { "errors": ["zodIssue1", "zodIssue2"] }
     }
     ```
   - NOTE: Always HTTP 200, even for malformed requests (per locked decision). The only time we return non-200 is for truly unexpected server errors (500).

2. **Assemble VerifyContext** from parsed request + server state:
   ```typescript
   const { paymentPayload, paymentRequirements } = parsed.data;
   const chainConfig = fastify.config.chain;
   const verificationConfig = chainConfig.verification;

   const ctx: VerifyContext = {
     scheme: paymentRequirements.scheme,
     network: paymentRequirements.network,
     payTo: paymentRequirements.payTo,
     requiredAmount: BigInt(paymentRequirements.amount),
     maxTimeoutSeconds: paymentRequirements.maxTimeoutSeconds,
     transactionCbor: paymentPayload.payload.transaction,
     payerAddress: paymentPayload.payload.payer,
     requestedAt: Date.now(),
     getCurrentSlot: () => fastify.chainProvider.getCurrentSlot(),
     configuredNetwork: CAIP2_CHAIN_IDS[chainConfig.network as CardanoNetwork],
     feeMin: BigInt(verificationConfig.feeMinLovelace),
     feeMax: BigInt(verificationConfig.feeMaxLovelace),
   };
   ```

3. **Call verifyPayment(ctx, fastify.log)**

4. **Return result** as HTTP 200:
   ```typescript
   return reply.status(200).send(result);
   ```

5. **Wrap in try/catch** for unexpected errors (CML WASM crash, etc.):
   - Log the error at `error` level
   - Return HTTP 500 with generic error (do NOT leak internal details)

**Export as plugin:**
```typescript
export const verifyRoutesPlugin = fp(verifyRoutes, {
  name: 'verify-routes',
  fastify: '5.x',
});
```
  </action>
  <verify>
Run `npx tsc --noEmit` -- should compile. The route plugin should export `verifyRoutesPlugin`.
  </verify>
  <done>POST /verify route plugin created following the Fastify fp() pattern. Request validation via Zod, context assembly from server state, verifyPayment() call, and HTTP 200 response for all cases.</done>
</task>

<task type="auto">
  <name>Task 2: Register verify route in server and write integration tests</name>
  <files>src/server.ts, tests/integration/verify-route.test.ts</files>
  <action>
**1. Update `src/server.ts`:**

Add import and registration of the verify route plugin:
```typescript
import { verifyRoutesPlugin } from './routes/verify.js';
```

Register it alongside the health route (after chain layer initialization, since the route needs chainProvider):
```typescript
// Routes
await server.register(healthRoutesPlugin);
await server.register(verifyRoutesPlugin);
```

**2. Create `tests/integration/verify-route.test.ts`:**

Integration tests using `fastify.inject()` (same pattern as existing health route tests).

IMPORTANT: Since these tests need ChainProvider (which requires Redis + Blockfrost), mock the chain layer similarly to existing integration tests. Mock `@lucid-evolution/lucid` at the package level if CML WASM is problematic.

**Test helper: `createTestVerifyRequest(overrides?)`**
Creates a valid VerifyRequest object with sensible defaults:
```typescript
function createTestVerifyRequest(overrides?: Partial<...>) {
  return {
    paymentPayload: {
      x402Version: 2,
      scheme: 'exact',
      network: 'cardano:preview',
      payload: {
        transaction: 'validBase64CborHere',  // Will need a real or mocked base64 CBOR
        payer: 'addr_test1qz...',
      },
    },
    paymentRequirements: {
      scheme: 'exact',
      network: 'cardano:preview',
      asset: 'lovelace',
      amount: '2000000',
      payTo: 'addr_test1qx...',
      maxTimeoutSeconds: 300,
    },
    ...overrides,
  };
}
```

**Test cases:**

1. **Valid request structure, mock verification passes:**
   - POST /verify with valid body
   - Mock verifyPayment to return `{ isValid: true, payer: '...' }`
   - Expect HTTP 200 with `isValid: true`

2. **Invalid request body (missing required fields):**
   - POST /verify with `{}`
   - Expect HTTP 200 with `{ isValid: false, invalidReason: 'invalid_request' }`

3. **Invalid request body (wrong x402Version):**
   - POST /verify with `x402Version: 1`
   - Expect HTTP 200 with `{ isValid: false, invalidReason: 'invalid_request' }`

4. **Valid request structure, verification fails:**
   - POST /verify with valid body
   - Mock verifyPayment to return `{ isValid: false, invalidReason: 'recipient_mismatch' }`
   - Expect HTTP 200 with `isValid: false`

5. **Content-Type enforcement:**
   - POST /verify with non-JSON content type
   - Expect appropriate error (Fastify handles this automatically)

6. **Route exists and responds:**
   - POST /verify -> not 404
   - GET /verify -> 404 (only POST is registered)

**Mock strategy:**
- Mock verifyPayment at the module level to avoid needing real CML/Blockfrost
- OR mock the chain layer (Redis, Blockfrost) and let real verification run with mock CBOR data
- Recommended: Mock verifyPayment for route-level integration tests. The verification pipeline has its own unit tests.

**3. Run all tests:**
`pnpm build && pnpm lint && pnpm test`
  </action>
  <verify>
Run `pnpm build && pnpm lint && pnpm test`. All should pass including existing tests. Verify POST /verify route responds with HTTP 200 for both valid and invalid requests.
  </verify>
  <done>POST /verify route registered in server.ts. Integration tests verify: valid requests processed, invalid requests return isValid: false with invalid_request reason, route exists as POST only. All existing tests still pass.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds
- `pnpm lint` passes
- `pnpm test` passes (all existing + new tests)
- POST /verify returns HTTP 200 for all request types
- Invalid request bodies return `{ isValid: false, invalidReason: 'invalid_request' }`
- Valid request bodies are processed through verifyPayment()
- Route is registered in server.ts alongside health route
- No secrets or raw CBOR logged
</verification>

<success_criteria>
The POST /verify endpoint is live, integrated into the server, and tested. It validates requests with Zod, assembles VerifyContext from server state, calls verifyPayment(), and returns the result as HTTP 200. Phase 3 verification layer is complete.
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-04-SUMMARY.md`
</output>
