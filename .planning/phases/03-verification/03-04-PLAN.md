---
phase: 03-verification
plan: 04
type: tdd
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/verify/verify-payment.ts
  - src/verify/index.ts
  - tests/unit/verify/verify-payment.test.ts
autonomous: true

must_haves:
  truths:
    - "Orchestrator runs all checks and collects all failures (not fail-fast)"
    - "Success response includes payer, scheme, amount, address in extra"
    - "Failure response uses first failure as primary invalidReason"
    - "Multiple failures listed in extra.errors array"
    - "BigInt amounts are serialized as strings in response"
  artifacts:
    - path: "src/verify/verify-payment.ts"
      provides: "verifyPayment orchestrator function"
      exports: ["verifyPayment"]
    - path: "tests/unit/verify/verify-payment.test.ts"
      provides: "Unit tests for orchestrator covering success, single failure, multiple failures, context assembly"
      min_lines: 80
  key_links:
    - from: "src/verify/verify-payment.ts"
      to: "src/verify/checks.ts"
      via: "Iterates VERIFICATION_CHECKS array"
      pattern: "VERIFICATION_CHECKS"
    - from: "src/verify/verify-payment.ts"
      to: "src/verify/types.ts"
      via: "Returns VerifyResponse shape"
      pattern: "isValid|invalidReason"
---

<objective>
Implement the verifyPayment orchestrator using TDD -- the function that runs all checks, collects errors, and builds the x402 VerifyResponse.

Purpose: The orchestrator is the core verification logic. It takes a parsed VerifyRequest, assembles a VerifyContext, runs all checks in order, and returns a VerifyResponse. Per CONTEXT.md, it runs ALL checks (not fail-fast) so clients get complete error information.

Output: Working, tested `verifyPayment` function in `src/verify/verify-payment.ts`
</objective>

<execution_context>
@/Users/morgan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/morgan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/03-verification/03-CONTEXT.md
@.planning/phases/03-verification/03-RESEARCH.md
@.planning/phases/03-verification/03-01-SUMMARY.md
@.planning/phases/03-verification/03-02-SUMMARY.md
@.planning/phases/03-verification/03-03-SUMMARY.md
@src/verify/types.ts
@src/verify/checks.ts
@src/verify/nonce-store.ts
</context>

<feature>
  <name>verifyPayment orchestrator - runs all checks and builds response</name>
  <files>src/verify/verify-payment.ts, tests/unit/verify/verify-payment.test.ts</files>
  <behavior>
**verifyPayment function signature:**
```typescript
async function verifyPayment(
  request: VerifyRequest,   // parsed from Zod schema
  deps: VerifyDeps,         // { chainProvider, nonceStore, config }
  facilitatorAddress: string, // bech32 address of facilitator
): Promise<VerifyResponse>
```

**Step 1: Assemble VerifyContext from request:**
```typescript
const ctx: VerifyContext = {
  scheme: request.paymentRequirements.scheme,
  network: request.paymentRequirements.network,
  payTo: request.paymentRequirements.payTo,
  maxAmountRequired: BigInt(request.paymentRequirements.maxAmountRequired),
  maxTimeoutSeconds: request.paymentRequirements.maxTimeoutSeconds,
  signature: request.paymentPayload.payload.signature,
  key: request.paymentPayload.payload.key,
  nonce: request.paymentPayload.payload.nonce,
  facilitatorAddress,
  requestedAt: Date.now(),
  extra: request.paymentRequirements.extra,
};
```

**Step 2: Run all checks, collect failures:**
```typescript
const errors: CheckResult[] = [];
for (const check of VERIFICATION_CHECKS) {
  const result = await check(ctx, deps);
  if (!result.passed) {
    errors.push(result);
  }
}
```

NOTE: Run ALL checks even if earlier ones fail (per CONTEXT.md "run all verification checks and report all failures, not fail-fast"). Exception: if the check function requires data from a prior check (e.g., balance check needs payerAddress set by signature check), the check should gracefully handle the missing data (skip/pass).

**Step 3: Build response:**

Success (no errors):
```typescript
{
  isValid: true,
  payer: ctx.payerAddress,  // set by checkSignature
  extra: {
    scheme: ctx.scheme,
    amount: ctx.maxAmountRequired.toString(),  // BigInt -> string
    address: ctx.payTo,
  },
}
```

Failure (one or more errors):
```typescript
{
  isValid: false,
  invalidReason: errors[0].reason,  // Primary = first in check order
  payer: ctx.payerAddress,          // may be undefined if sig check failed
  extra: {
    errors: errors.map(e => e.reason),
    // Include debug details for first error if available
  },
}
```

**Test cases:**

1. All checks pass -> `{ isValid: true, payer: '...', extra: { scheme: 'exact', amount: '2000000', address: '...' } }`
2. Single failure (scheme) -> `{ isValid: false, invalidReason: 'unsupported_scheme', extra: { errors: ['unsupported_scheme'] } }`
3. Multiple failures (network + amount) -> `{ isValid: false, invalidReason: 'network_mismatch', extra: { errors: ['network_mismatch', 'amount_mismatch'] } }` (first in order is primary)
4. BigInt amount serialized as string in extra.amount (not thrown, not dropped)
5. Context assembly correctly converts maxAmountRequired string to BigInt
6. payerAddress undefined when signature check fails
7. All checks run even when early ones fail (verify mock check call count)

Mock strategy: Mock the VERIFICATION_CHECKS array or mock individual check functions. Create a helper to build valid VerifyRequest objects for testing.
  </behavior>
  <implementation>
The orchestrator is relatively simple -- the complexity lives in the individual checks. This function:
1. Assembles context from the parsed request
2. Loops through checks
3. Builds response from results

Ensure BigInt values are converted to strings before including in response (avoid JSON.stringify TypeError).

After implementing, update `src/verify/index.ts` barrel to export `verifyPayment`.
  </implementation>
</feature>

<verification>
- `pnpm test -- tests/unit/verify/verify-payment.test.ts` -- all tests pass
- `pnpm test` -- full suite passes
- `pnpm build` succeeds
</verification>

<success_criteria>
verifyPayment orchestrator runs all checks (not fail-fast), collects all failures, returns first failure as primary invalidReason, includes all failures in extra.errors, serializes BigInt as string, and sets payer from signature check. All tests green.
</success_criteria>

<output>
After completion, create `.planning/phases/03-verification/03-04-SUMMARY.md`
</output>
