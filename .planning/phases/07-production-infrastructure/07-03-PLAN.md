---
phase: 07-production-infrastructure
plan: 07-03
type: execute
wave: 2
depends_on: [07-01, 07-02]
files_modified:
  - src/instrument.ts
  - src/routes/health.ts
  - config/config.example.json
  - docs/operations.md
autonomous: true

must_haves:
  truths:
    - "Sentry tracesSampleRate is configurable via config (not hardcoded 1.0)"
    - "Health endpoint version reads from package.json (not npm_package_version env var)"
    - "Health endpoint does not expose sensitive state"
    - "Operational runbook covers startup, shutdown, common issues, and recovery"
    - "config.example.json documents production-relevant fields"
  artifacts:
    - path: "src/instrument.ts"
      provides: "Sentry initialization with configurable trace sample rate"
      exports: ["initSentry", "Sentry"]
    - path: "src/routes/health.ts"
      provides: "Health endpoint with reliable version reporting"
      exports: ["healthRoutesPlugin"]
    - path: "config/config.example.json"
      provides: "Example configuration with production guidance comments"
      exports: []
    - path: "docs/operations.md"
      provides: "Operational runbook for the facilitator"
      exports: []
  key_links:
    - from: "src/instrument.ts"
      to: "src/config/schema.ts"
      via: "Reads tracesSampleRate from sentry config"
      pattern: "tracesSampleRate"
    - from: "src/routes/health.ts"
      to: "package.json"
      via: "Reads version from package.json at startup"
      pattern: "version"
---

<objective>
Harden operational readiness: make Sentry trace sampling configurable, fix health endpoint version reporting, update config examples for production, and create an operational runbook.

Purpose: The facilitator is functionally complete and security-hardened, but has small operational gaps. Sentry's 100% trace sampling will be expensive at scale. The health endpoint reports version "0.0.0" because `npm_package_version` isn't set in production (only when running via `pnpm`/`npm` scripts). The operational runbook gives operators confidence to deploy and troubleshoot.

Output: Updated `src/instrument.ts`, `src/routes/health.ts`, `config/config.example.json`, `docs/operations.md`
</objective>

<context>
@src/instrument.ts
@src/routes/health.ts
@src/config/schema.ts
@src/config/index.ts
@src/index.ts
@config/config.example.json
@docker-compose.yml
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make Sentry trace sample rate configurable</name>
  <files>src/config/schema.ts, src/instrument.ts</files>
  <action>
**1. Extend the sentry config schema** in `src/config/schema.ts`:

Add `tracesSampleRate` to the existing sentry object:

```typescript
sentry: z
  .object({
    dsn: z.string().url(),
    environment: z.string().default('development'),
    tracesSampleRate: z.number().min(0).max(1).default(0.1),
  })
  .optional(),
```

Default is `0.1` (10%) — reasonable for production. Development can override to `1.0` in their config.

**2. Update `src/instrument.ts`** to accept the sample rate:

Change the function signature to accept the full sentry config (or just add the rate parameter):

```typescript
export function initSentry(dsn: string | undefined, environment: string, tracesSampleRate = 0.1): void {
  if (!dsn) {
    console.log('Sentry DSN not configured, error tracking disabled');
    return;
  }

  Sentry.init({
    dsn,
    environment,
    tracesSampleRate,
    integrations: [Sentry.onUnhandledRejectionIntegration()],
  });

  console.log(`Sentry initialized for environment: ${environment}`);
}
```

**3. Update the call site** in `src/index.ts`:

```typescript
initSentry(config.sentry?.dsn, config.env, config.sentry?.tracesSampleRate);
```

This is a minimal change. The third parameter defaults to `0.1` when sentry config is absent.
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm test` passes (existing Sentry mock tests still work)
- Default trace rate is 0.1, not 1.0
  </verify>
  <done>Sentry trace sample rate configurable via config, defaulting to 10% instead of 100%.</done>
</task>

<task type="auto">
  <name>Task 2: Fix health endpoint version reporting</name>
  <files>src/routes/health.ts</files>
  <action>
The current health endpoint uses `process.env.npm_package_version ?? '0.0.0'` for the version. This works when running via `pnpm dev` or `pnpm start`, but returns `'0.0.0'` when running the built output directly (`node dist/index.js`) — which is exactly how the production Docker image runs.

**Fix:** Read the version from `package.json` at module load time using `createRequire` or a simpler approach.

Since the project is ESM-only, use `import` with `assert { type: 'json' }` or read from the filesystem:

**Simplest approach — read package.json once at module level:**

At the top of `src/routes/health.ts`, add:

```typescript
import { readFileSync } from 'node:fs';
import { resolve } from 'node:path';

// Read version once at startup (not on every request)
const packageJson = JSON.parse(
  readFileSync(resolve(process.cwd(), 'package.json'), 'utf-8')
) as { version: string };
const APP_VERSION = packageJson.version;
```

Then replace the version line in the response:

```typescript
version: APP_VERSION,
```

Remove the `process.env.npm_package_version ?? '0.0.0'` pattern.

This works in both dev (`tsx watch`) and production (`node dist/index.js`) because `process.cwd()` resolves to the project root where `package.json` lives. In Docker, `WORKDIR /app` is the project root with `package.json` copied in.
  </action>
  <verify>
- `pnpm typecheck` passes
- `pnpm test` passes (health endpoint tests still work)
- Health endpoint returns the actual version from package.json, not '0.0.0'
  </verify>
  <done>Health endpoint reads version from package.json at startup. Correct in both dev and production (Docker).</done>
</task>

<task type="auto">
  <name>Task 3: Update config example for production</name>
  <files>config/config.example.json</files>
  <action>
Update `config/config.example.json` to include the new `tracesSampleRate` field and add production-relevant values as comments (JSON doesn't support comments, but the field names and values serve as documentation):

```json
{
  "server": {
    "host": "0.0.0.0",
    "port": 3000
  },
  "logging": {
    "level": "info",
    "pretty": false
  },
  "sentry": {
    "dsn": "https://your-sentry-dsn@sentry.io/project-id",
    "environment": "production",
    "tracesSampleRate": 0.1
  },
  "env": "production",
  "rateLimit": {
    "global": 100,
    "sensitive": 20,
    "windowMs": 60000
  },
  "chain": {
    "network": "Preview",
    "blockfrost": {
      "projectId": "your-blockfrost-project-id",
      "tier": "free"
    },
    "facilitator": {
      "seedPhrase": "your 24-word seed phrase here"
    },
    "cache": {
      "utxoTtlSeconds": 60
    },
    "reservation": {
      "ttlSeconds": 120,
      "maxConcurrent": 20
    },
    "redis": {
      "host": "redis-prod",
      "port": 6379,
      "password": "your-redis-password",
      "db": 0
    },
    "verification": {
      "graceBufferSeconds": 30,
      "maxTimeoutSeconds": 300,
      "feeMinLovelace": 150000,
      "feeMaxLovelace": 5000000
    }
  }
}
```

Changes from current example:
- `env` set to `"production"` (was `"development"`)
- `logging.pretty` set to `false` (was `true`) — JSON logs for production log aggregation
- Added `sentry.tracesSampleRate: 0.1`
- Added `sentry.environment: "production"`
- Added `rateLimit` section (was missing from example)
- Redis `host` set to `"redis-prod"` (Docker service name) with `password` field
  </action>
  <verify>
- `config/config.example.json` is valid JSON
- Includes all current config fields plus new `tracesSampleRate`
- Shows production-appropriate defaults
  </verify>
  <done>Config example updated with production values, Redis auth, Sentry trace rate, and rate limits.</done>
</task>

<task type="auto">
  <name>Task 4: Create operational runbook</name>
  <files>docs/operations.md</files>
  <action>
Create `docs/operations.md` covering the operational knowledge needed to deploy and run the facilitator.

**Structure:**

```markdown
# Operations Runbook

## Prerequisites

- Node.js 20+
- Docker and Docker Compose
- Blockfrost API key (https://blockfrost.io)
- Redis 7+ (provided via Docker or external)

## Quick Start (Development)

1. Copy config: `cp config/config.example.json config/config.json`
2. Edit config: set your Blockfrost project ID and seed phrase
3. Start dependencies: `docker compose up -d`
4. Start server: `pnpm dev`
5. Verify: `curl http://localhost:3000/health`

## Production Deployment (Docker)

### 1. Create production config

Copy `config/config.example.json` to `config/config.json` and set:
- `env` to `"production"`
- `logging.pretty` to `false`
- `chain.redis.host` to `"redis-prod"` (Docker service name)
- `chain.redis.password` to your Redis password
- `chain.blockfrost.projectId` to your Blockfrost key
- `chain.facilitator.seedPhrase` to your facilitator wallet seed

### 2. Set Redis password

Export the Redis password for Docker Compose:
```
export REDIS_PASSWORD=your-secure-password-here
```

### 3. Start production stack

```
docker compose --profile production up -d
```

This starts:
- `x402-facilitator` — the payment facilitator (port 3000)
- `x402-redis-prod` — Redis with authentication (port 6380)

### 4. Verify deployment

```
curl http://localhost:3000/health
```

Expected: `{"status":"healthy","version":"1.0.0",...}`

## Startup

The facilitator starts in this order:
1. Load and validate config from `config/config.json`
2. Initialize Sentry error tracking (if DSN configured)
3. Connect to Redis
4. Initialize Lucid Evolution (Blockfrost provider)
5. Create chain provider (UTXO cache, reservation system)
6. Start HTTP server on configured host:port
7. Register SIGINT/SIGTERM shutdown handlers

If any step fails, the process exits with code 1 and logs the error.

## Shutdown

The facilitator handles graceful shutdown on SIGINT and SIGTERM:
1. Stop accepting new requests
2. Wait for in-flight requests to complete
3. Disconnect Redis client
4. Exit process

In Docker: `docker compose --profile production stop` sends SIGTERM.

## Health Check

`GET /health` returns:

| Status | HTTP | Meaning |
|--------|------|---------|
| healthy | 200 | All dependencies up |
| degraded | 200 | Some dependencies down (Redis) |
| unhealthy | 503 | All dependencies down |

**Alert on:** `unhealthy` status or health endpoint unreachable.
**Investigate:** `degraded` status — check Redis connectivity.

## Common Issues

### Config validation error on startup

**Symptom:** `ConfigInvalidError: chain.blockfrost.projectId: Blockfrost project ID is required`
**Fix:** Ensure `config/config.json` exists and all required fields are set. Compare with `config/config.example.json`.

### Redis connection refused

**Symptom:** `Chain layer initialization failed` with ECONNREFUSED
**Fix:** Ensure Redis is running. In Docker: `docker compose --profile production ps` to check redis-prod is healthy.

### Mainnet safety block

**Symptom:** `Mainnet connection requires explicit MAINNET=true environment variable`
**Fix:** Set `MAINNET=true` in environment if intentionally connecting to mainnet. This is a safety guardrail.

### Rate limiting (429)

**Symptom:** Clients receive 429 Too Many Requests
**Fix:** Default limits: 100 req/min global, 20 req/min on /verify, /settle, /status. Adjust in config `rateLimit` section.

### Health endpoint shows version 0.0.0

**Symptom:** Health endpoint returns version "0.0.0"
**Fix:** Ensure `package.json` is in the working directory. In Docker, this is handled automatically.

## Monitoring

### Logs

Production logs are structured JSON (pino format):
```json
{"level":30,"time":1707000000000,"msg":"Server listening at http://0.0.0.0:3000"}
```

Use `pino-pretty` for human-readable output during debugging:
```
docker logs x402-facilitator | npx pino-pretty
```

Key log fields:
- `reqId` — request correlation ID (UUID)
- `responseTime` — request duration in ms
- `statusCode` — HTTP response status

### Sentry

If configured, Sentry captures:
- All 5xx errors with request context (requestId, URL, method)
- Unhandled promise rejections
- Performance traces (sample rate configurable, default 10%)

### Redis

Monitor Redis with:
```
redis-cli -a $REDIS_PASSWORD -p 6380 info
```

Key metrics: `connected_clients`, `used_memory`, `keyspace_hits/misses`.

## Recovery

### After crash / restart

1. Redis persistence (AOF) preserves UTXO reservations
2. On restart, the facilitator reconnects and resumes normal operation
3. In-flight settlements may time out — clients should retry via /status

### After Redis data loss

1. UTXO reservations are lost (they have 120s TTL anyway)
2. Dedup keys are lost (24h TTL) — duplicate submissions temporarily possible
3. UTXO cache rebuilds automatically from Blockfrost
4. No manual intervention required
```
  </action>
  <verify>
- `docs/operations.md` exists
- Covers startup, shutdown, common issues, and recovery
- Includes Docker production deployment steps
- Includes health check monitoring guidance
  </verify>
  <done>Operational runbook created covering deployment, monitoring, troubleshooting, and recovery.</done>
</task>

</tasks>

<verification>
- `pnpm typecheck` passes
- `pnpm test` passes (all 298+ tests)
- `pnpm build` succeeds
- Health endpoint returns actual version from package.json
- Sentry accepts configurable trace rate
- `config/config.example.json` is valid JSON with production values
- `docs/operations.md` covers all five success criteria areas
</verification>

<success_criteria>
Operational gaps closed: Sentry won't burn through trace quota at 100%, health endpoint reports the real version, operators have a clear guide for deployment and troubleshooting. Combined with Plan 07-01 (CI) and Plan 07-02 (Docker), the facilitator is production-ready.
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-infrastructure/07-03-SUMMARY.md`
</output>
