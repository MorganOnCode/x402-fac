This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  scripts/
    validate-skills.js
  workflows/
    validate-skills.yml
devnet-in-a-box/
  assets/
    always-true.plutus
    datum.json
  scripts/
    hydra_ws.py
    rehearsal.sh
    smoke.sh
  docker-compose.override.yml
  README.md
  run.sh
openclaw/
  EXEC_APPROVALS.md
  exec-approvals.template.json
scripts/
  apply-approvals.ps1
  apply-approvals.sh
  install.ps1
  install.sh
  oc-safe.sh
shared/
  PRINCIPLES.md
skills/
  aiken-dex-security-audit/
    references/
      audit-framework.md
      findings-severity-guide.md
    templates/
      audit-report.md
      invariants-checklist.md
      tx-shapes.md
    SKILL.md
  aiken-dex-security-audit-operator/
    SKILL.md
  aiken-smart-contracts/
    reference/
      aiken-workflow.md
    SKILL.md
  cardano-cli-doctor/
    reference/
      docker-fallback.md
      doctor.md
    scripts/
      cardano-cli-doctor.sh
      cardano-cli.sh
    SKILL.md
  cardano-cli-operator/
    reference/
      operator.md
    scripts/
      cardano-cli.sh
    SKILL.md
  cardano-cli-plutus-scripts/
    reference/
      docker-fallback.md
      script-spend-template.md
    scripts/
      cardano-cli.sh
    SKILL.md
  cardano-cli-plutus-scripts-operator/
    SKILL.md
  cardano-cli-staking/
    reference/
      docker-fallback.md
      staking.md
    scripts/
      cardano-cli.sh
    SKILL.md
  cardano-cli-staking-operator/
    SKILL.md
  cardano-cli-transactions/
    reference/
      docker-fallback.md
      tx-send-ada.md
    scripts/
      cardano-cli.sh
    SKILL.md
  cardano-cli-transactions-operator/
    SKILL.md
  cardano-cli-wallets/
    reference/
      docker-fallback.md
      wallets.md
    scripts/
      cardano-cli.sh
    SKILL.md
  cardano-cli-wallets-operator/
    SKILL.md
  cardano-devnet-in-a-box/
    SKILL.md
  cardano-protocol-params/
    reference/
      docker-fallback.md
      pparams.md
    scripts/
      cardano-cli.sh
    SKILL.md
  hydra-head/
    reference/
      docker-fallback.md
      hydra-best-practices.md
      sources.md
    scripts/
      hydra-node.sh
    templates/
      runbook.md
    SKILL.md
  hydra-head-operator/
    reference/
      operator.md
    scripts/
      hydra-api.sh
      hydra-node.sh
    SKILL.md
  hydra-head-troubleshooter/
    reference/
      docker-fallback.md
      probes.md
      sources.md
    scripts/
      hydra-node.sh
    templates/
      incident-worksheet.md
    SKILL.md
  meshjs-cardano/
    reference/
      meshjs-patterns.md
    SKILL.md
  plutus-v3-conway/
    reference/
      v3-notes.md
    SKILL.md
.gitignore
CHANGELOG.md
LICENSE
OPENCLAW_METADATA_SNIPPETS.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/scripts/validate-skills.js">
#!/usr/bin/env node

/**
 * Validates all SKILL.md files in the skills/ directory
 * Checks:
 * - Valid YAML frontmatter
 * - Required fields (name, description)
 * - Name constraints (lowercase, hyphens, max 64 chars, no reserved words)
 * - No duplicate names
 */

const fs = require('fs');
const path = require('path');
const yaml = require('yaml');

const RESERVED_WORDS = ['claude', 'anthropic', 'skill', 'openai', 'gpt'];
const MAX_NAME_LENGTH = 64;
const NAME_PATTERN = /^[a-z][a-z0-9-]*$/;

const skillsDir = path.join(__dirname, '..', '..', 'skills');
const errors = [];
const warnings = [];
const seenNames = new Set();

function extractFrontmatter(content) {
  const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---/);
  if (!match) return null;
  try {
    return yaml.parse(match[1]);
  } catch (e) {
    return { _parseError: e.message };
  }
}

function validateSkill(skillPath, skillName) {
  const skillMdPath = path.join(skillPath, 'SKILL.md');

  if (!fs.existsSync(skillMdPath)) {
    errors.push(`${skillName}: Missing SKILL.md file`);
    return;
  }

  const content = fs.readFileSync(skillMdPath, 'utf8');
  const frontmatter = extractFrontmatter(content);

  if (!frontmatter) {
    errors.push(`${skillName}: No YAML frontmatter found`);
    return;
  }

  if (frontmatter._parseError) {
    errors.push(`${skillName}: Invalid YAML frontmatter - ${frontmatter._parseError}`);
    return;
  }

  // Required fields
  if (!frontmatter.name) {
    errors.push(`${skillName}: Missing required field 'name'`);
  }
  if (!frontmatter.description) {
    errors.push(`${skillName}: Missing required field 'description'`);
  }

  const name = frontmatter.name;
  if (name) {
    // Name validation
    if (!NAME_PATTERN.test(name)) {
      errors.push(`${skillName}: Name '${name}' must be lowercase with hyphens only, starting with a letter`);
    }
    if (name.length > MAX_NAME_LENGTH) {
      errors.push(`${skillName}: Name '${name}' exceeds ${MAX_NAME_LENGTH} characters`);
    }
    for (const reserved of RESERVED_WORDS) {
      if (name.includes(reserved)) {
        errors.push(`${skillName}: Name '${name}' contains reserved word '${reserved}'`);
      }
    }
    if (seenNames.has(name)) {
      errors.push(`${skillName}: Duplicate skill name '${name}'`);
    }
    seenNames.add(name);

    // Name should match directory
    if (name !== skillName) {
      warnings.push(`${skillName}: Skill name '${name}' doesn't match directory name '${skillName}'`);
    }
  }

  // Description length check
  if (frontmatter.description && frontmatter.description.length > 200) {
    warnings.push(`${skillName}: Description is long (${frontmatter.description.length} chars). Consider shortening for token efficiency.`);
  }

  console.log(`✓ ${skillName}`);
}

// Main
console.log('Validating skills...\n');

if (!fs.existsSync(skillsDir)) {
  console.error('Error: skills/ directory not found');
  process.exit(1);
}

const skills = fs.readdirSync(skillsDir).filter(f => {
  return fs.statSync(path.join(skillsDir, f)).isDirectory();
});

for (const skill of skills) {
  validateSkill(path.join(skillsDir, skill), skill);
}

console.log(`\nValidated ${skills.length} skills`);

if (warnings.length > 0) {
  console.log('\nWarnings:');
  warnings.forEach(w => console.log(`  ⚠ ${w}`));
}

if (errors.length > 0) {
  console.log('\nErrors:');
  errors.forEach(e => console.log(`  ✗ ${e}`));
  process.exit(1);
}

console.log('\n✓ All skills valid!');
</file>

<file path=".github/workflows/validate-skills.yml">
name: Validate Skills

on:
  push:
    branches: [main]
    paths:
      - 'skills/**'
      - '.github/workflows/validate-skills.yml'
  pull_request:
    branches: [main]
    paths:
      - 'skills/**'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install yaml

      - name: Validate skill frontmatter
        run: node .github/scripts/validate-skills.js
</file>

<file path="devnet-in-a-box/assets/always-true.plutus">
{
  "type": "PlutusScriptV2",
  "description": "Always true validator",
  "cborHex": "49480100002221200101"
}
</file>

<file path="devnet-in-a-box/assets/datum.json">
{
  "constructor": 0,
  "fields": [
    { "int": 42 }
  ]
}
</file>

<file path="devnet-in-a-box/scripts/hydra_ws.py">
\
#!/usr/bin/env python3
"""Minimal WebSocket client for Hydra node API (no external deps).

Why this exists:
- Deterministic rehearsal scripts shouldn't depend on `websocat` being installed.
- Hydra node exposes a WebSocket API on the same `--api-port` (default 4001).
- We only need: send one JSON command (Init/Close/Fanout/NewTx) and/or wait for a tagged ServerOutput.

Supports:
- ws:// and wss://
- One-shot send
- Wait for any of N tags with timeout
"""

from __future__ import annotations

import argparse
import base64
import hashlib
import json
import os
import select
import socket
import ssl
import sys
import time
from dataclasses import dataclass
from typing import Iterable, Tuple
from urllib.parse import urlparse

_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"


class WsError(RuntimeError):
    pass


@dataclass
class WsUrl:
    scheme: str
    host: str
    port: int
    resource: str  # includes path + query


def parse_ws_url(url: str) -> WsUrl:
    u = urlparse(url)
    if u.scheme not in ("ws", "wss"):
        raise WsError(f"Unsupported URL scheme: {u.scheme!r} (expected ws/wss)")
    if not u.hostname:
        raise WsError("URL missing hostname")
    host = u.hostname
    port = u.port or (443 if u.scheme == "wss" else 80)
    path = u.path or "/"
    resource = path + ("?" + u.query if u.query else "")
    return WsUrl(u.scheme, host, port, resource)


def _read_exact(sock: socket.socket, n: int) -> bytes:
    buf = bytearray()
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            raise WsError("Socket closed unexpectedly")
        buf.extend(chunk)
    return bytes(buf)


def _make_accept(key_b64: str) -> str:
    h = hashlib.sha1((key_b64 + _GUID).encode("utf-8")).digest()
    return base64.b64encode(h).decode("ascii")


def ws_connect(url: WsUrl, *, timeout: float = 10.0, insecure_tls: bool = False) -> socket.socket:
    raw = socket.create_connection((url.host, url.port), timeout=timeout)
    sock: socket.socket
    if url.scheme == "wss":
        ctx = ssl.create_default_context()
        if insecure_tls:
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
        sock = ctx.wrap_socket(raw, server_hostname=url.host)
    else:
        sock = raw

    key = base64.b64encode(os.urandom(16)).decode("ascii")
    req = (
        f"GET {url.resource} HTTP/1.1\r\n"
        f"Host: {url.host}:{url.port}\r\n"
        "Upgrade: websocket\r\n"
        "Connection: Upgrade\r\n"
        f"Sec-WebSocket-Key: {key}\r\n"
        "Sec-WebSocket-Version: 13\r\n"
        "User-Agent: devnet-in-a-box-rehearsal\r\n"
        "\r\n"
    ).encode("utf-8")
    sock.sendall(req)

    # Read HTTP response headers
    data = bytearray()
    while b"\r\n\r\n" not in data:
        chunk = sock.recv(4096)
        if not chunk:
            raise WsError("Handshake failed: connection closed")
        data.extend(chunk)
        if len(data) > 65536:
            raise WsError("Handshake failed: headers too large")
    header_bytes, _ = data.split(b"\r\n\r\n", 1)
    header_text = header_bytes.decode("iso-8859-1")
    lines = header_text.split("\r\n")
    if not lines or not lines[0].startswith("HTTP/1.1 101"):
        got = lines[0] if lines else ""
        raise WsError(f"Handshake failed: expected 101 Switching Protocols, got: {got}")
    headers = {}
    for line in lines[1:]:
        if ":" in line:
            k, v = line.split(":", 1)
            headers[k.strip().lower()] = v.strip()
    accept = headers.get("sec-websocket-accept")
    expected = _make_accept(key)
    if accept != expected:
        raise WsError("Handshake failed: Sec-WebSocket-Accept mismatch")
    return sock


def _send_frame(sock: socket.socket, opcode: int, payload: bytes) -> None:
    # Client-to-server frames MUST be masked.
    fin_opcode = 0x80 | (opcode & 0x0F)
    mask_key = os.urandom(4)
    length = len(payload)

    if length < 126:
        header = bytes([fin_opcode, 0x80 | length])
        ext = b""
    elif length < (1 << 16):
        header = bytes([fin_opcode, 0x80 | 126])
        ext = length.to_bytes(2, "big")
    else:
        header = bytes([fin_opcode, 0x80 | 127])
        ext = length.to_bytes(8, "big")

    masked = bytes(b ^ mask_key[i % 4] for i, b in enumerate(payload))
    sock.sendall(header + ext + mask_key + masked)


def ws_send_text(sock: socket.socket, text: str) -> None:
    _send_frame(sock, opcode=0x1, payload=text.encode("utf-8"))


def ws_send_close(sock: socket.socket) -> None:
    try:
        _send_frame(sock, opcode=0x8, payload=b"")
    except Exception:
        pass


def ws_send_pong(sock: socket.socket, payload: bytes) -> None:
    _send_frame(sock, opcode=0xA, payload=payload)


def _recv_frame(sock: socket.socket) -> Tuple[int, bytes]:
    # Returns (opcode, payload)
    b1, b2 = _read_exact(sock, 2)
    opcode = b1 & 0x0F
    masked = (b2 & 0x80) != 0
    length = b2 & 0x7F
    if length == 126:
        length = int.from_bytes(_read_exact(sock, 2), "big")
    elif length == 127:
        length = int.from_bytes(_read_exact(sock, 8), "big")
    mask_key = _read_exact(sock, 4) if masked else b""
    payload = _read_exact(sock, length) if length else b""
    if masked:
        payload = bytes(b ^ mask_key[i % 4] for i, b in enumerate(payload))
    return opcode, payload


def iter_text_messages(sock: socket.socket, *, timeout_s: float, print_all: bool = False) -> Iterable[str]:
    """Yield incoming text messages until timeout or socket close."""
    deadline = time.time() + timeout_s

    while True:
        remaining = deadline - time.time()
        if remaining <= 0:
            return

        r, _, _ = select.select([sock], [], [], remaining)
        if not r:
            return

        opcode, payload = _recv_frame(sock)

        if opcode == 0x8:  # close
            return
        if opcode == 0x9:  # ping
            ws_send_pong(sock, payload)
            continue
        if opcode == 0xA:  # pong
            continue
        if opcode == 0x2:  # binary
            continue
        if opcode == 0x1:  # text
            msg = payload.decode("utf-8", errors="replace")
            if print_all:
                print(msg)
            yield msg
            continue
        continue


def cmd_send(args: argparse.Namespace) -> int:
    url = parse_ws_url(args.url)
    msg: str
    if args.message_file:
        msg = open(args.message_file, "r", encoding="utf-8").read()
    else:
        msg = args.message

    sock = ws_connect(url, timeout=args.connect_timeout, insecure_tls=args.insecure_tls)
    try:
        ws_send_text(sock, msg)
        # Best-effort drain a tiny bit (some servers only start sending after a command)
        for _ in iter_text_messages(sock, timeout_s=args.drain_timeout, print_all=args.print_all):
            pass
    finally:
        ws_send_close(sock)
        try:
            sock.close()
        except Exception:
            pass
    return 0


def cmd_wait(args: argparse.Namespace) -> int:
    url = parse_ws_url(args.url)
    wanted = [t.strip() for t in args.wait_tags.split(",") if t.strip()]
    if not wanted:
        raise WsError("--wait-tags must include at least one tag")

    sock = ws_connect(url, timeout=args.connect_timeout, insecure_tls=args.insecure_tls)
    try:
        for msg in iter_text_messages(sock, timeout_s=args.timeout, print_all=args.print_all):
            try:
                obj = json.loads(msg)
            except json.JSONDecodeError:
                continue
            tag = obj.get("tag")
            if tag in wanted:
                if args.print_match:
                    print(msg)
                return 0
    finally:
        ws_send_close(sock)
        try:
            sock.close()
        except Exception:
            pass

    print(f"Timed out waiting for tags: {wanted}", file=sys.stderr)
    return 2


def main() -> int:
    ap = argparse.ArgumentParser(prog="hydra_ws.py")
    sub = ap.add_subparsers(dest="cmd", required=True)

    common = argparse.ArgumentParser(add_help=False)
    common.add_argument("--url", required=True, help="ws://... or wss://... hydra-node API endpoint")
    common.add_argument("--connect-timeout", type=float, default=10.0)
    common.add_argument("--insecure-tls", action="store_true", help="Disable TLS verification for wss:// (dev only)")
    common.add_argument("--print-all", action="store_true", help="Print all incoming messages")

    sp_send = sub.add_parser("send", parents=[common], help="Send one text message and exit")
    group = sp_send.add_mutually_exclusive_group(required=True)
    group.add_argument("--message", help="Raw message to send (typically JSON)")
    group.add_argument("--message-file", help="Path to file containing the message to send")
    sp_send.add_argument("--drain-timeout", type=float, default=0.5, help="Seconds to read after sending (best-effort)")
    sp_send.set_defaults(func=cmd_send)

    sp_wait = sub.add_parser("wait", parents=[common], help="Wait for one of the given tags and exit")
    sp_wait.add_argument("--wait-tags", required=True, help="Comma-separated list of tag values to wait for")
    sp_wait.add_argument("--timeout", type=float, default=60.0)
    sp_wait.add_argument("--print-match", action="store_true", help="Print the matching JSON message")
    sp_wait.set_defaults(func=cmd_wait)

    args = ap.parse_args()
    try:
        return int(args.func(args))
    except WsError as e:
        print(f"ERROR: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
</file>

<file path="devnet-in-a-box/scripts/rehearsal.sh">
\
#!/usr/bin/env bash
set -euo pipefail

# Deterministic Hydra rehearsal:
# - smoke checks (cardano-node + hydra APIs + optional kupo health)
# - init head
# - commit: alice(script UTxO + collateral) + bob + carol
# - submit one L2 tx (spend the script UTxO inside the head)
# - close + wait contestation + fanout
#
# Output: "GREEN" on success, "RED" on failure.

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
RUN_SH="$ROOT_DIR/run.sh"
HYDRA_DIR="$ROOT_DIR/.vendor/hydra"
DEMO_DIR="$HYDRA_DIR/demo"
CREDENTIALS_HOST="$HYDRA_DIR/hydra-cluster/config/credentials"
ASSETS_DIR="$ROOT_DIR/assets"
WS_PY="$ROOT_DIR/scripts/hydra_ws.py"

NETWORK_MAGIC="42"
NODE_SOCKET="/devnet/node.socket"

API_ALICE="http://localhost:4001"
API_BOB="http://localhost:4002"
API_CAROL="http://localhost:4003"

WS_ALICE_SEND="ws://localhost:4001?history=no"
WS_ALICE_HISTORY="ws://localhost:4001?history=yes"

TMP_HOST="$ROOT_DIR/.rehearsal-tmp"

log() { printf "[rehearsal] %s\n" "$*"; }
die() { printf "\n❌ RED — %s\n" "$*" >&2; exit 1; }

need() { command -v "$1" >/dev/null 2>&1 || die "missing required command: $1"; }

# docker compose v2 preferred, v1 fallback
COMPOSE_BIN="docker compose"
if ! docker compose version >/dev/null 2>&1; then
  if command -v docker-compose >/dev/null 2>&1; then
    COMPOSE_BIN="docker-compose"
  else
    die "docker compose (v2) or docker-compose (v1) is required"
  fi
fi

compose() { (cd "$DEMO_DIR" && $COMPOSE_BIN "$@"); }
cardano_cli() { compose exec -T cardano-node cardano-cli "$@"; }

ensure_tmp() {
  rm -rf "$TMP_HOST"
  mkdir -p "$TMP_HOST"
}

# ---- JSON helpers (host-side python) ----
\
py_pick_utxo() {
  # Prints: "<txin> <lovelace>" picking the largest ADA-only UTxO.
  python3 - "$1" <<'PY'
import json, sys
path=sys.argv[1]
data=json.load(open(path))
if not data:
  raise SystemExit(2)

def ada_only(val):
  return isinstance(val, dict) and set(val.keys())=={"lovelace"}

cands=[]
for txin, info in data.items():
  val=info.get("value",{})
  lov=int(val.get("lovelace",0) or 0)
  if ada_only(val):
    cands.append((lov, txin))

if cands:
  cands.sort(reverse=True)
  lov, txin = cands[0]
else:
  txin = next(iter(data.keys()))
  lov = int(data[txin]["value"]["lovelace"])

print(f"{txin} {lov}")
PY
}

\
py_make_commit_request() {
  # args: utxo_json_file blueprint_json_file out_file
  python3 - "$1" "$2" "$3" <<'PY'
import json, sys
utxo_path, blueprint_path, out_path = sys.argv[1:4]
utxo=json.load(open(utxo_path))
blueprint=json.load(open(blueprint_path))
req={"utxo": utxo, "blueprintTx": blueprint}
json.dump(req, open(out_path,"w"), separators=(",",":"))
PY
}

\
py_wrap_newtx() {
  # args: signed_tx_json_file out_file
  python3 - "$1" "$2" <<'PY'
import json, sys
tx_path, out_path = sys.argv[1:3]
tx=json.load(open(tx_path))
msg={"tag":"NewTx","transaction":tx}
json.dump(msg, open(out_path,"w"), separators=(",",":"))
PY
}

\
py_snapshot_has_txin() {
  # args: snapshot_json_file txin  (exit 0 if present, 1 otherwise)
  python3 - "$1" "$2" <<'PY'
import json, sys
snap_path, txin = sys.argv[1:3]
snap=json.load(open(snap_path))
raise SystemExit(0 if txin in snap else 1)
PY
}

\
py_json_len() {
  python3 - "$1" <<'PY'
import json, sys
d=json.load(open(sys.argv[1]))
print(len(d))
PY
}

# ---- Container file staging ----
stage_into_cardano_node() {
  local cid
  cid="$(compose ps -q cardano-node)"
  [ -n "$cid" ] || die "cardano-node container not found (is the stack up?)"

  log "Staging credentials + assets into cardano-node container..."
  compose exec -T cardano-node sh -lc 'rm -rf /tmp/rehearsal /tmp/credentials && mkdir -p /tmp/rehearsal' >/dev/null

  # Copy creds dir into /tmp (becomes /tmp/credentials)
  docker cp "$CREDENTIALS_HOST" "${cid}:/tmp" >/dev/null

  docker cp "$ASSETS_DIR/always-true.plutus" "${cid}:/tmp/rehearsal/always-true.plutus" >/dev/null
  docker cp "$ASSETS_DIR/datum.json" "${cid}:/tmp/rehearsal/datum.json" >/dev/null
}

build_party_addresses() {
  log "Building party addresses..."
  cardano_cli address build \
    --payment-verification-key-file /tmp/credentials/alice-funds.vk \
    --testnet-magic "$NETWORK_MAGIC" \
    --out-file /tmp/rehearsal/alice.addr

  cardano_cli address build \
    --payment-verification-key-file /tmp/credentials/bob-funds.vk \
    --testnet-magic "$NETWORK_MAGIC" \
    --out-file /tmp/rehearsal/bob.addr

  cardano_cli address build \
    --payment-verification-key-file /tmp/credentials/carol-funds.vk \
    --testnet-magic "$NETWORK_MAGIC" \
    --out-file /tmp/rehearsal/carol.addr

  ALICE_ADDR="$(compose exec -T cardano-node cat /tmp/rehearsal/alice.addr | tr -d '\r\n')"
  BOB_ADDR="$(compose exec -T cardano-node cat /tmp/rehearsal/bob.addr | tr -d '\r\n')"
  CAROL_ADDR="$(compose exec -T cardano-node cat /tmp/rehearsal/carol.addr | tr -d '\r\n')"
}

wait_for_tip() {
  log "Waiting for cardano-node tip..."
  for _ in $(seq 1 60); do
    if cardano_cli query tip --testnet-magic "$NETWORK_MAGIC" --socket-path "$NODE_SOCKET" >/dev/null 2>&1; then
      return 0
    fi
    sleep 1
  done
  die "cardano-node did not become ready"
}

smoke_checks() {
  log "Running smoke checks..."

  wait_for_tip

  curl -sf "$API_ALICE/head" >/dev/null || die "Hydra API (alice) not responding at $API_ALICE/head"
  curl -sf "$API_BOB/head"   >/dev/null || die "Hydra API (bob) not responding at $API_BOB/head"
  curl -sf "$API_CAROL/head" >/dev/null || die "Hydra API (carol) not responding at $API_CAROL/head"

  if curl -sf "http://localhost:1442/health" >/dev/null 2>&1; then
    log "Kupo: healthy"
  else
    log "Kupo: /health not responding (continuing; endpoint may differ depending on image/tag)"
  fi

  log "Smoke checks passed."
}

pick_utxo_for_address() {
  # args: label address out_prefix
  local label="$1"
  local addr="$2"
  local prefix="$3"

  cardano_cli query utxo \
    --address "$addr" \
    --testnet-magic "$NETWORK_MAGIC" \
    --socket-path "$NODE_SOCKET" \
    --output-json >"$TMP_HOST/${prefix}-utxo.json"

  if [ "$(py_json_len "$TMP_HOST/${prefix}-utxo.json")" = "0" ]; then
    die "$label: no UTxOs found at $addr"
  fi

  py_pick_utxo "$TMP_HOST/${prefix}-utxo.json"
}

lock_script_utxo() {
  log "Creating an always-true script UTxO on L1 (10 ADA locked with inline datum 42)..."

  # Build script address
  cardano_cli address build \
    --payment-script-file /tmp/rehearsal/always-true.plutus \
    --testnet-magic "$NETWORK_MAGIC" \
    --out-file /tmp/rehearsal/always-true.addr
  SCRIPT_ADDR="$(compose exec -T cardano-node cat /tmp/rehearsal/always-true.addr | tr -d '\r\n')"

  # Pick funding UTxO from Alice
  read -r ALICE_FUND_TXIN ALICE_FUND_LOVELACE < <(pick_utxo_for_address "alice" "$ALICE_ADDR" "alice-fund") || die "failed to pick alice funding UTxO"

  # Build + sign + submit tx that pays 10 ADA to script address with inline datum
  compose exec -T cardano-node sh -lc "cardano-cli conway transaction build \
    --tx-in '$ALICE_FUND_TXIN' \
    --tx-out '$SCRIPT_ADDR+10000000' \
    --tx-out-inline-datum-file /tmp/rehearsal/datum.json \
    --change-address '$ALICE_ADDR' \
    --testnet-magic '$NETWORK_MAGIC' \
    --socket-path '$NODE_SOCKET' \
    --out-file /tmp/rehearsal/lock.txbody"

  compose exec -T cardano-node sh -lc "cardano-cli conway transaction sign \
    --tx-body-file /tmp/rehearsal/lock.txbody \
    --signing-key-file /tmp/credentials/alice-funds.sk \
    --out-file /tmp/rehearsal/lock.signed.json"

  compose exec -T cardano-node sh -lc "cardano-cli conway transaction submit \
    --tx-file /tmp/rehearsal/lock.signed.json \
    --testnet-magic '$NETWORK_MAGIC' \
    --socket-path '$NODE_SOCKET'"

  # Wait until the script UTxO shows up
  for _ in $(seq 1 60); do
    cardano_cli query utxo \
      --address "$SCRIPT_ADDR" \
      --testnet-magic "$NETWORK_MAGIC" \
      --socket-path "$NODE_SOCKET" \
      --output-json >"$TMP_HOST/script-utxo.json" || true

    if [ "$(py_json_len "$TMP_HOST/script-utxo.json")" != "0" ]; then
      read -r SCRIPT_TXIN SCRIPT_LOVELACE < <(py_pick_utxo "$TMP_HOST/script-utxo.json") || true
      if [ -n "${SCRIPT_TXIN:-}" ]; then
        log "Script UTxO: $SCRIPT_TXIN (lovelace=$SCRIPT_LOVELACE)"
        return 0
      fi
    fi
    sleep 1
  done

  die "script UTxO did not appear at $SCRIPT_ADDR"
}

pick_alice_collateral_utxo() {
  # Pick a fresh ADA-only UTxO at Alice to use as collateral (and commit it).
  read -r ALICE_COLL_TXIN ALICE_COLL_LOVELACE < <(pick_utxo_for_address "alice" "$ALICE_ADDR" "alice-coll") || die "failed to pick alice collateral UTxO"
  log "Alice collateral UTxO: $ALICE_COLL_TXIN (lovelace=$ALICE_COLL_LOVELACE)"
}

hydra_send() {
  local msg="$1"
  python3 "$WS_PY" send --url "$WS_ALICE_SEND" --message "$msg" >/dev/null
}

hydra_wait() {
  local tags="$1"
  local timeout="${2:-60}"
  python3 "$WS_PY" wait --url "$WS_ALICE_HISTORY" --wait-tags "$tags" --timeout "$timeout" >/dev/null
}

commit_via_api() {
  # args: party (alice|bob|carol) api_base_url txin lovelace kind(script|basic)
  local party="$1"
  local api="$2"
  local txin="$3"
  local lovelace="$4"
  local kind="$5"
local pay_addr=""
case "$party" in
  alice) pay_addr="$ALICE_ADDR" ;;
  bob) pay_addr="$BOB_ADDR" ;;
  carol) pay_addr="$CAROL_ADDR" ;;
  *) die "unknown party: $party" ;;
esac


  local blueprint_cont="/tmp/rehearsal/${party}-${kind}-blueprint.json"
  local blueprint_host="$TMP_HOST/${party}-${kind}-blueprint.json"
  local utxo_host="$TMP_HOST/${party}-${kind}-utxo.json"
  local req_host="$TMP_HOST/${party}-${kind}-commit-request.json"
  local commit_tx_host="$TMP_HOST/${party}-${kind}-commit-tx.json"

  log "Commit (${party}/${kind}) via $api/commit ..."

  # Build blueprint tx inside container
  if [ "$kind" = "script" ]; then
    compose exec -T cardano-node sh -lc "cardano-cli conway transaction build-raw \
      --tx-in '$txin' \
      --tx-in-script-file /tmp/rehearsal/always-true.plutus \
      --tx-in-inline-datum-present \
      --tx-in-redeemer-value 42 \
      --tx-in-execution-units '(1000000, 100000)' \
      --tx-out '$ALICE_ADDR+10000000' \
      --fee 0 \
      --out-file '$blueprint_cont'"
  else
    compose exec -T cardano-node sh -lc "cardano-cli conway transaction build-raw \
      --tx-in '$txin' \
      --tx-out '$pay_addr+$lovelace' \
      --fee 0 \
      --out-file '$blueprint_cont'"
  fi

  # Copy blueprint out to host
  compose exec -T cardano-node cat "$blueprint_cont" >"$blueprint_host"

  # UTxO context for txin (on L1)
  cardano_cli query utxo \
    --tx-in "$txin" \
    --testnet-magic "$NETWORK_MAGIC" \
    --socket-path "$NODE_SOCKET" \
    --output-json >"$utxo_host"

  py_make_commit_request "$utxo_host" "$blueprint_host" "$req_host"

  # POST /commit and capture tx body
  curl -sf -X POST \
    -H "Content-Type: application/json" \
    --data @"$req_host" \
    "$api/commit" >"$commit_tx_host" || die "commit request failed for $party ($kind)"

  # Copy commit tx body into container, sign, submit
  local cid
  cid="$(compose ps -q cardano-node)"
  docker cp "$commit_tx_host" "${cid}:/tmp/rehearsal/${party}-${kind}-commit-tx.json" >/dev/null

  compose exec -T cardano-node sh -lc "cardano-cli conway transaction sign \
    --tx-body-file /tmp/rehearsal/${party}-${kind}-commit-tx.json \
    --signing-key-file /tmp/credentials/${party}-funds.sk \
    --signing-key-file /tmp/credentials/${party}.sk \
    --out-file /tmp/rehearsal/${party}-${kind}-commit-signed.json"

  compose exec -T cardano-node sh -lc "cardano-cli conway transaction submit \
    --tx-file /tmp/rehearsal/${party}-${kind}-commit-signed.json \
    --testnet-magic '$NETWORK_MAGIC' \
    --socket-path '$NODE_SOCKET'"
}

wait_snapshot_txin_present() {
  local txin="$1"
  for _ in $(seq 1 60); do
    curl -sf "$API_ALICE/snapshot/utxo" >"$TMP_HOST/snapshot.json" || true
    if py_snapshot_has_txin "$TMP_HOST/snapshot.json" "$txin"; then
      return 0
    fi
    sleep 1
  done
  return 1
}

submit_l2_spend_script() {
  log "Submitting L2 tx: spend the script UTxO inside the open Head..."

  log "Waiting until script txin is visible in snapshot..."
  wait_snapshot_txin_present "$SCRIPT_TXIN" || die "script txin not visible in snapshot; commit likely failed"

  # Build raw L2 tx (spend script txin, pay 10 ADA to Bob)
  compose exec -T cardano-node sh -lc "cardano-cli conway transaction build-raw \
    --tx-in '$SCRIPT_TXIN' \
    --tx-in-script-file /tmp/rehearsal/always-true.plutus \
    --tx-in-inline-datum-present \
    --tx-in-redeemer-value 42 \
    --tx-in-execution-units '(1000000, 100000)' \
    --tx-in-collateral '$ALICE_COLL_TXIN' \
    --tx-out '$BOB_ADDR+10000000' \
    --fee 0 \
    --out-file /tmp/rehearsal/l2.txbody"

  # Sign
  compose exec -T cardano-node sh -lc "cardano-cli conway transaction sign \
    --tx-body-file /tmp/rehearsal/l2.txbody \
    --signing-key-file /tmp/credentials/alice-funds.sk \
    --signing-key-file /tmp/credentials/alice.sk \
    --out-file /tmp/rehearsal/l2.signed.json"

  compose exec -T cardano-node cat /tmp/rehearsal/l2.signed.json >"$TMP_HOST/l2.signed.json"
  py_wrap_newtx "$TMP_HOST/l2.signed.json" "$TMP_HOST/newtx.json"

  python3 "$WS_PY" send --url "$WS_ALICE_SEND" --message-file "$TMP_HOST/newtx.json" >/dev/null

  # Verify it landed by polling snapshot UTxO until the script input is gone
  for _ in $(seq 1 60); do
    curl -sf "$API_ALICE/snapshot/utxo" >"$TMP_HOST/snapshot.json" || true
    if ! py_snapshot_has_txin "$TMP_HOST/snapshot.json" "$SCRIPT_TXIN"; then
      log "L2 tx confirmed (script txin spent in snapshot)."
      return 0
    fi
    sleep 1
  done

  die "L2 tx did not get confirmed (script txin still present in snapshot)"
}

main() {
  need docker
  need curl
  need python3
  need git

  ensure_tmp

  log "Reset stack to a known baseline..."
  "$RUN_SH" reset >/dev/null 2>&1 || true

  log "Bring devnet-in-a-box up..."
  "$RUN_SH" up >/dev/null

  [ -d "$DEMO_DIR" ] || die "missing demo dir at $DEMO_DIR"
  [ -d "$CREDENTIALS_HOST" ] || die "missing credentials dir at $CREDENTIALS_HOST"

  smoke_checks

  stage_into_cardano_node
  build_party_addresses

  lock_script_utxo
  pick_alice_collateral_utxo

  # Pick Bob + Carol commit UTxOs (after stack is up)
  read -r BOB_TXIN BOB_LOVELACE < <(pick_utxo_for_address "bob" "$BOB_ADDR" "bob") || die "failed to pick bob UTxO"
  read -r CAROL_TXIN CAROL_LOVELACE < <(pick_utxo_for_address "carol" "$CAROL_ADDR" "carol") || die "failed to pick carol UTxO"

  log "Init head (via WebSocket)..."
  hydra_send '{"tag":"Init"}'

  log "Waiting for HeadIsInitializing..."
  hydra_wait "HeadIsInitializing" 120 || die "Head did not enter initializing state"

  # Commit UTxOs (order doesn't really matter; keep it explicit)
  commit_via_api "alice" "$API_ALICE" "$SCRIPT_TXIN" "$SCRIPT_LOVELACE" "script"
  commit_via_api "alice" "$API_ALICE" "$ALICE_COLL_TXIN" "$ALICE_COLL_LOVELACE" "basic"
  commit_via_api "bob"   "$API_BOB"   "$BOB_TXIN"   "$BOB_LOVELACE"   "basic"
  commit_via_api "carol" "$API_CAROL" "$CAROL_TXIN" "$CAROL_LOVELACE" "basic"

  log "Waiting for HeadIsOpen..."
  hydra_wait "HeadIsOpen" 180 || die "Head did not open"

  submit_l2_spend_script

  log "Close head..."
  hydra_send '{"tag":"Close"}'

  log "Waiting for HeadIsClosed..."
  hydra_wait "HeadIsClosed" 180 || die "Head did not close"

  log "Waiting for ReadyToFanout (contestation period)..."
  hydra_wait "ReadyToFanout" 600 || die "Never became ready to fanout"

  log "Fanout..."
  hydra_send '{"tag":"Fanout"}'

  log "Waiting for fanout confirmation..."
  hydra_wait "HeadFannedOut,HeadIsFinalized" 600 || die "Fanout did not complete"

  printf "\n✅ GREEN — rehearsal succeeded (smoke + open/close + contract interaction)\n"
}

main "$@"
</file>

<file path="devnet-in-a-box/scripts/smoke.sh">
\
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
HYDRA_DIR="$ROOT_DIR/.vendor/hydra"
DEMO_DIR="$HYDRA_DIR/demo"

NETWORK_MAGIC="42"
NODE_SOCKET="/devnet/node.socket"

API_ALICE="http://localhost:4001"
API_BOB="http://localhost:4002"
API_CAROL="http://localhost:4003"

log() { printf "[smoke] %s\n" "$*"; }
die() { printf "\n❌ RED — %s\n" "$*" >&2; exit 1; }

# docker compose v2 preferred, v1 fallback
COMPOSE_BIN="docker compose"
if ! docker compose version >/dev/null 2>&1; then
  if command -v docker-compose >/dev/null 2>&1; then
    COMPOSE_BIN="docker-compose"
  else
    die "docker compose (v2) or docker-compose (v1) is required"
  fi
fi

compose() { (cd "$DEMO_DIR" && $COMPOSE_BIN "$@"); }
cardano_cli() { compose exec -T cardano-node cardano-cli "$@"; }

log "Checking cardano-node tip..."
cardano_cli query tip --testnet-magic "$NETWORK_MAGIC" --socket-path "$NODE_SOCKET" >/dev/null || die "cardano-node not ready"

log "Checking Hydra node APIs..."
curl -sf "$API_ALICE/head" >/dev/null || die "alice hydra api not responding"
curl -sf "$API_BOB/head"   >/dev/null || die "bob hydra api not responding"
curl -sf "$API_CAROL/head" >/dev/null || die "carol hydra api not responding"

if curl -sf "http://localhost:1442/health" >/dev/null 2>&1; then
  log "Kupo: healthy"
else
  log "Kupo: /health not responding (continuing)"
fi

printf "\n✅ GREEN — smoke checks passed\n"
</file>

<file path="devnet-in-a-box/docker-compose.override.yml">
# Adds Ogmios + Kupo to Hydra's official demo devnet.
#
# Usage:
#   (from hydra/demo)
#   docker compose up -d ogmios kupo
#
# This file is meant to be copied into the upstream hydra/demo folder as:
#   hydra/demo/docker-compose.override.yml
# so Compose auto-merges it with the demo's docker-compose.yml.

services:
  ogmios:
    image: cardanosolutions/ogmios:latest
    depends_on:
      - cardano-node
    # Ogmios reads the node config + connects over the node.socket.
    # NOTE: If this ever breaks due to upstream changes, run:
    #   docker compose run --rm ogmios --help
    command:
      - --node-socket
      - /devnet/node.socket
      - --node-config
      - /devnet/cardano-node.json
      - --host
      - 0.0.0.0
      - --port
      - "1337"
    volumes:
      - ./devnet:/devnet:ro
    ports:
      - "1337:1337"
    restart: unless-stopped

  kupo:
    image: cardanosolutions/kupo:latest
    depends_on:
      - cardano-node
    # Minimal setup based on the official Docker instructions:
    # https://hub.docker.com/r/cardanosolutions/kupo
    command:
      - --node-socket
      - /devnet/node.socket
      - --node-config
      - /devnet/cardano-node.json
      - --host
      - 0.0.0.0
      - --workdir
      - /db
      # Index everything in this local devnet.
      - --match
      - "*"
      - --since
      - origin
    volumes:
      - ./devnet:/devnet:ro
      - kupo-db:/db
    ports:
      - "1442:1442"
    restart: unless-stopped

volumes:
  kupo-db:
</file>

<file path="devnet-in-a-box/README.md">
# Cardano Devnet-in-a-Box (Hydra demo + Ogmios + Kupo)

This folder gives you a **one-command local rehearsal environment**:

- **cardano-node** (fast local devnet)
- **hydra-node** (3-node demo cluster: Alice/Bob/Carol)
- **ogmios** (WS API for chain sync / tx submission)
- **kupo** (chain-index)

It vendors **Hydra’s official demo** under `devnet-in-a-box/.vendor/hydra` and drops a `docker-compose.override.yml` into the upstream `hydra/demo` so you get Ogmios + Kupo alongside the canonical setup.

## Requirements

- Docker + Docker Compose
- Git

## Quickstart

From this folder:

```bash
./run.sh up
```

Then:

```bash
./run.sh tui 1
```

In other terminals:

```bash
./run.sh tui 2
./run.sh tui 3
```


## Deterministic rehearsal (green/red)

This is the "no vibes" end-to-end check: smoke test + Hydra open/close + one contract interaction (a tiny always-true Plutus script UTxO committed and spent inside the head).

```bash
cd devnet-in-a-box
./run.sh rehearsal
```

If it succeeds you get **GREEN**. If anything flakes, you get **RED** + the failing step.

You can also run the lightweight health check:

```bash
./run.sh smoke
```

## Endpoints

- Ogmios (WS): `ws://localhost:1337`
- Kupo (HTTP): `http://localhost:1442`
- Hydra API:
  - Alice: `http://localhost:4001`
  - Bob:   `http://localhost:4002`
  - Carol: `http://localhost:4003`

Optional monitoring:

```bash
./run.sh monitor
# Grafana: http://localhost:3000 (admin/admin)
```

## Reset / cleanup

```bash
./run.sh down
./run.sh reset
```

`reset` removes containers, volumes, and deletes the generated `hydra/demo/devnet` directory.

## Why this approach?

Hydra’s demo scripts (`prepare-devnet.sh`, `seed-devnet.sh`, etc.) are the “known good” path for:

- generating a local devnet with the right genesis start time
- publishing Hydra scripts
- funding the demo parties

So we **reuse that**, and just bolt on the two dApp-facing services you actually want for app rehearsal: Ogmios + Kupo.
</file>

<file path="devnet-in-a-box/run.sh">
#!/usr/bin/env bash
set -euo pipefail

CMD="${1:-up}"

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VENDOR_DIR="$ROOT_DIR/.vendor"
HYDRA_DIR="$VENDOR_DIR/hydra"
DEMO_DIR="$HYDRA_DIR/demo"

COMPOSE_BIN="docker compose"
if ! docker compose version >/dev/null 2>&1; then
  # docker-compose legacy fallback
  if command -v docker-compose >/dev/null 2>&1; then
    COMPOSE_BIN="docker-compose"
  else
    echo "ERROR: docker compose (v2) or docker-compose (v1) is required." >&2
    exit 1
  fi
fi

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || {
    echo "ERROR: missing required command: $1" >&2
    exit 1
  }
}

ensure_hydra_repo() {
  require_cmd git
  mkdir -p "$VENDOR_DIR"
  if [ ! -d "$HYDRA_DIR/.git" ]; then
    echo "[devnet] Cloning Hydra repo into: $HYDRA_DIR"
    git clone --depth 1 https://github.com/cardano-scaling/hydra.git "$HYDRA_DIR"
  fi

  if [ ! -d "$DEMO_DIR" ]; then
    echo "ERROR: expected Hydra demo dir at $DEMO_DIR" >&2
    exit 1
  fi
}

ensure_override() {
  local src="$ROOT_DIR/docker-compose.override.yml"
  local dst="$DEMO_DIR/docker-compose.override.yml"
  if [ ! -f "$src" ]; then
    echo "ERROR: missing override file: $src" >&2
    exit 1
  fi
  cp "$src" "$dst"
}

cd_demo() {
  cd "$DEMO_DIR"
}

print_endpoints() {
  cat <<'TXT'

✅ Devnet-in-a-Box is up.

Endpoints:
- Ogmios (WS):        ws://localhost:1337
- Kupo (HTTP):        http://localhost:1442
- Hydra API (Alice):  http://localhost:4001
- Hydra API (Bob):    http://localhost:4002
- Hydra API (Carol):  http://localhost:4003

Handy commands (run from this devnet-in-a-box folder):
- Start:   ./run.sh up
- TUI:     ./run.sh tui 1   # or 2 / 3
- Logs:    ./run.sh logs cardano-node
- Stop:    ./run.sh down
- Reset:   ./run.sh reset

TXT
}

wait_for_node() {
  # Wait until cardano-cli can query the tip.
  # We intentionally run cardano-cli inside the container so the host doesn't need it.
  echo "[devnet] Waiting for cardano-node to answer queries..."
  for i in {1..60}; do
    if $COMPOSE_BIN exec -T cardano-node cardano-cli query tip --testnet-magic 42 --socket-path /devnet/node.socket >/dev/null 2>&1; then
      echo "[devnet] cardano-node is responding."
      return 0
    fi
    sleep 1
  done
  echo "ERROR: cardano-node did not become ready in time." >&2
  echo "Try: ./run.sh logs cardano-node" >&2
  return 1
}

chmod_socket() {
  # Hydra docs sometimes recommend chmod on the node.socket when using volumes.
  # We do this from inside the container as root to avoid requiring sudo on the host.
  $COMPOSE_BIN exec -T -u root cardano-node sh -lc 'chmod a+w /devnet/node.socket || true' >/dev/null 2>&1 || true
}

case "$CMD" in
  up)
    require_cmd docker
    ensure_hydra_repo
    ensure_override
    cd_demo

    echo "[devnet] Pulling images (Hydra demo + Ogmios + Kupo)..."
    $COMPOSE_BIN pull

    echo "[devnet] Preparing devnet config (genesis start time, keys, etc.)..."
    ./prepare-devnet.sh

    echo "[devnet] Starting cardano-node..."
    $COMPOSE_BIN up -d cardano-node

    chmod_socket
    wait_for_node

    echo "[devnet] Seeding devnet (publish Hydra scripts + fund parties)..."
    ./seed-devnet.sh

    echo "[devnet] Starting Hydra nodes + Ogmios + Kupo..."
    $COMPOSE_BIN up -d hydra-node-1 hydra-node-2 hydra-node-3 ogmios kupo

    print_endpoints
    ;;

  tui)
    require_cmd docker
    ensure_hydra_repo
    ensure_override
    cd_demo

    WHICH="${2:-1}"
    case "$WHICH" in
      1|2|3) ;;
      *) echo "usage: ./run.sh tui [1|2|3]" >&2; exit 1;;
    esac

    # Run TUI container interactively.
    $COMPOSE_BIN run --rm "hydra-tui-$WHICH"
    ;;

  monitor)
    require_cmd docker
    ensure_hydra_repo
    ensure_override
    cd_demo
    $COMPOSE_BIN up -d prometheus grafana
    echo "Grafana: http://localhost:3000 (admin/admin)"
    ;;

  logs)
    require_cmd docker
    ensure_hydra_repo
    ensure_override
    cd_demo
    shift || true
    $COMPOSE_BIN logs -f "$@"
    ;;

  down)
    require_cmd docker
    ensure_hydra_repo
    ensure_override
    cd_demo
    $COMPOSE_BIN down --remove-orphans
    ;;

  reset)
    require_cmd docker
    ensure_hydra_repo
    ensure_override
    cd_demo
    $COMPOSE_BIN down -v --remove-orphans
    rm -rf "$DEMO_DIR/devnet" || true
    echo "[devnet] Reset complete (containers stopped, volumes removed, devnet folder deleted)."
    ;;

  update)
    require_cmd git
    ensure_hydra_repo
    echo "[devnet] Updating Hydra repo..."
    git -C "$HYDRA_DIR" pull --ff-only
    echo "[devnet] Done."
    ;;

smoke)
  "$ROOT_DIR/scripts/smoke.sh"
  ;;

rehearsal)
  "$ROOT_DIR/scripts/rehearsal.sh"
  ;;

  *)
    cat <<'USAGE'
Usage:
  ./run.sh up        # clone hydra demo, prepare devnet, seed, start services
  ./run.sh tui 1     # run hydra-tui for node 1 (or 2 / 3)
  ./run.sh monitor   # start prometheus + grafana (optional)
  ./run.sh logs ...  # follow logs
  ./run.sh down      # stop everything
  ./run.sh reset     # nuke volumes + devnet folder
  ./run.sh smoke     # quick health check (node + hydra APIs)
  ./run.sh rehearsal # deterministic end-to-end rehearsal (green/red)
  ./run.sh update    # git pull hydra upstream
USAGE
    exit 1
    ;;
esac
</file>

<file path="openclaw/EXEC_APPROVALS.md">
# OpenClaw Exec Approvals (template + how to apply)

OpenClaw host execution (`exec` on `gateway` or `node`) is gated by **Exec approvals**, stored on the execution host at:

- `~/.openclaw/exec-approvals.json`

This repo includes a starter template:

- `openclaw/exec-approvals.template.json`

## Apply the template (recommended)
Use the OpenClaw CLI approvals helper to replace approvals from a file:

```bash
openclaw approvals set --file ./openclaw/exec-approvals.template.json
# or target gateway / node specifically:
openclaw approvals set --gateway --file ./openclaw/exec-approvals.template.json
openclaw approvals set --node <id|name|ip> --file ./openclaw/exec-approvals.template.json
```

## Why this template is safe-ish (and still usable)
- Defaults are `deny` (no accidental host RCE).
- Agent `main` is `allowlist` + `ask=on-miss` + `askFallback=deny`.
- `autoAllowSkills=true` lets the node treat skill-referenced executables as allowlisted where supported.

## Important: update allowlist patterns to match your machine
Allowlist patterns must resolve to **paths**, not basenames. Add patterns for where your binaries live, e.g.:

- `/opt/homebrew/bin/docker`
- `/usr/bin/docker`

You can also add patterns using the CLI helper:

```bash
openclaw approvals allowlist add "/opt/homebrew/bin/docker"
openclaw approvals allowlist add "~/Projects/**/cardano-agent-skills/scripts/oc-safe.sh"
```

## Exec session defaults (per session)
You can set session overrides inside OpenClaw:

```text
/exec host=gateway security=allowlist ask=on-miss
```

(Approvals still apply; `security=full` is the "I know what I'm doing" mode and skips approvals.)


## One-command apply (recommended)

From repo root:

```bash
./scripts/apply-approvals.sh --local
# or
./scripts/apply-approvals.sh --gateway
# or
./scripts/apply-approvals.sh --node <id|name|ip>
```

This replaces approvals from `openclaw/exec-approvals.template.json` and then allowlists `scripts/oc-safe.sh` plus any common binaries found on PATH.


## Final-boss flags

- `--dry-run` prints what would be changed without applying anything.
- `--broad-paths` also adds broad directory globs (dangerous).
</file>

<file path="openclaw/exec-approvals.template.json">
{
  "version": 1,
  "defaults": {
    "security": "deny",
    "ask": "on-miss",
    "askFallback": "deny",
    "autoAllowSkills": false
  },
  "agents": {
    "main": {
      "security": "allowlist",
      "ask": "on-miss",
      "askFallback": "deny",
      "autoAllowSkills": true,
      "allowlist": [
        {
          "pattern": "/opt/homebrew/bin/docker"
        },
        {
          "pattern": "/opt/homebrew/bin/docker-compose"
        },
        {
          "pattern": "/opt/homebrew/bin/colima"
        },
        {
          "pattern": "/opt/homebrew/bin/curl"
        },
        {
          "pattern": "/usr/bin/curl"
        },
        {
          "pattern": "/usr/bin/git"
        },
        {
          "pattern": "~/Projects/**/cardano-agent-skills/scripts/oc-safe.sh"
        }
      ]
    }
  }
}
</file>

<file path="scripts/apply-approvals.ps1">
Param(
  [ValidateSet("local","gateway","node")]
  [string]$Target = "local",
  [string]$Node = "",
  [string]$Agent = "main",
  [switch]$Yes,
  [switch]$DryRun,
  [switch]$BroadPaths
)

$ErrorActionPreference = "Stop"

function Need($cmd) {
  if (-not (Get-Command $cmd -ErrorAction SilentlyContinue)) {
    throw "Missing dependency: $cmd"
  }
}

Need openclaw

$Root = Resolve-Path (Join-Path $PSScriptRoot "..")
$Template = Join-Path $Root "openclaw/exec-approvals.template.json"
$OcSafe = Join-Path $Root "scripts/oc-safe.sh"

if (-not (Test-Path $Template)) { throw "Missing template: $Template" }
if (-not (Test-Path $OcSafe)) { throw "Missing oc-safe: $OcSafe" }

$TargetArgs = @()
if ($Target -eq "gateway") { $TargetArgs = @("--gateway") }
elseif ($Target -eq "node") {
  if ([string]::IsNullOrWhiteSpace($Node)) { throw "Target=node requires -Node <id|name|ip>" }
  $TargetArgs = @("--node", $Node)
}

$os = $PSVersionTable.OS
if (-not $os) { $os = [System.Runtime.InteropServices.RuntimeInformation]::OSDescription }
$isMac = $os -match "Darwin|macOS|Mac"
$isLinux = $os -match "Linux"

Write-Host "== OpenClaw approvals apply (final boss) =="
Write-Host "Target: $Target"
Write-Host "Agent:  $Agent"
Write-Host "Repo:   $Root"
Write-Host "Dry:    $DryRun"
Write-Host "Broad:  $BroadPaths"
Write-Host ""

function RunCmd([string[]]$args) {
  if ($DryRun) {
    Write-Host ("+ openclaw " + ($args -join " "))
    return
  }
  & openclaw @args
}

if (-not $Yes -and -not $DryRun) {
  Write-Host "This will overwrite approvals using:"
  Write-Host "  $Template"
  Write-Host "and then add allowlist entries for:"
  Write-Host "  $OcSafe"
  Write-Host ""
  Write-Host "Optional (dangerous): -BroadPaths adds globs like /opt/homebrew/bin/* and /usr/bin/*."
  $ans = Read-Host "Proceed? [y/N]"
  if ($ans -notin @("y","Y","yes","YES")) { Write-Host "Aborted."; exit 0 }
}

# 1) Replace approvals from file
RunCmd @(@("approvals","set") + $TargetArgs + @("--file", "$Template"))

# 2) Allowlist repo-specific oc-safe (exact path)
RunCmd @(@("approvals","allowlist","add") + $TargetArgs + @("--agent",$Agent,"$OcSafe"))

# 3) Add resolved paths for common deps
Write-Host ""
Write-Host "== Adding common binaries (resolved paths, if found) =="
function MaybeAddBin($bin) {
  $cmd = Get-Command $bin -ErrorAction SilentlyContinue
  if ($cmd) {
    RunCmd @(@("approvals","allowlist","add") + $TargetArgs + @("--agent",$Agent,$cmd.Source))
    Write-Host "OK allowlisted: $($cmd.Source)"
  }
}
"docker","docker-compose","colima","curl","git","python3","node","npm","npx" | ForEach-Object { MaybeAddBin $_ }

# 4) OS-aware path patterns (safe-ish: targeted, not "everything")
Write-Host ""
Write-Host "== Adding OS-aware path patterns (safe-ish) =="

RunCmd @(@("approvals","allowlist","add") + $TargetArgs + @("--agent",$Agent,"~/Projects/**/cardano-agent-skills/scripts/oc-safe.sh"))
Write-Host "OK allowlisted: ~/Projects/**/cardano-agent-skills/scripts/oc-safe.sh"

if ($isMac) {
  $paths = @(
    "/opt/homebrew/bin/docker",
    "/opt/homebrew/bin/docker-compose",
    "/opt/homebrew/bin/colima",
    "/opt/homebrew/bin/curl",
    "/opt/homebrew/bin/git",
    "/usr/local/bin/docker",
    "/usr/local/bin/docker-compose",
    "/usr/local/bin/colima",
    "/usr/bin/curl",
    "/usr/bin/git",
    "/usr/bin/python3"
  )
} else {
  $paths = @(
    "/usr/bin/docker",
    "/usr/bin/docker-compose",
    "/usr/bin/curl",
    "/usr/bin/git",
    "/usr/bin/python3",
    "/usr/local/bin/docker",
    "/usr/local/bin/docker-compose",
    "/usr/local/bin/curl",
    "/usr/local/bin/git"
  )
}

foreach ($p in $paths) {
  RunCmd @(@("approvals","allowlist","add") + $TargetArgs + @("--agent",$Agent,$p))
  Write-Host "OK allowlisted: $p"
}

# 5) OPTIONAL broad patterns
if ($BroadPaths) {
  Write-Host ""
  Write-Host "== Adding BROAD directory globs (DANGEROUS) =="
  if ($isMac) {
    $globs = @("/opt/homebrew/bin/*","/usr/local/bin/*","/usr/bin/*")
  } else {
    $globs = @("/usr/local/bin/*","/usr/bin/*")
  }
  foreach ($g in $globs) {
    RunCmd @(@("approvals","allowlist","add") + $TargetArgs + @("--agent",$Agent,$g))
    Write-Host "WARNING allowlisted: $g"
  }
  Write-Host "WARNING Broad globs reduce safety. Prefer allowlisting oc-safe + specific binaries."
}

Write-Host ""
Write-Host "Done. Recommended session defaults inside OpenClaw:"
Write-Host "  /exec host=gateway security=allowlist ask=on-miss"
</file>

<file path="scripts/apply-approvals.sh">
#!/usr/bin/env bash
set -euo pipefail

# Final-boss OpenClaw approvals applier.
#
# Features:
# - OS-aware suggested allowlist patterns (brew + standard locations)
# - --dry-run to preview actions
# - optional broad path globs (dangerous) behind --broad-paths

usage() {
  cat <<'EOF'
Usage: scripts/apply-approvals.sh [--local|--gateway|--node <id|name|ip>] [--agent <name>] [--yes] [--dry-run] [--broad-paths]

Targets:
  --local      (default) edit local approvals file on this host
  --gateway    edit approvals on the gateway host (requires gateway caps)
  --node ...   edit approvals on a specific node host

Options:
  --agent <name>      approvals agent scope (default: main)
  --yes               skip interactive prompt
  --dry-run           print the OpenClaw CLI commands that would be executed, then exit 0
  --broad-paths       ALSO add broad directory globs as allowlist patterns (DANGEROUS!)

Examples:
  ./scripts/apply-approvals.sh --local --dry-run
  ./scripts/apply-approvals.sh --gateway --yes
  ./scripts/apply-approvals.sh --node mac-1 --yes
  ./scripts/apply-approvals.sh --local --yes --broad-paths

Notes:
  - Requires OpenClaw CLI: `openclaw approvals set|allowlist add`
  - Allowlist patterns are case-insensitive glob matches and should resolve to binary paths.
    Basename-only entries are ignored.
EOF
}

TARGET_ARGS=()
NODE=""
AGENT="main"
YES=0
DRY=0
BROAD=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --local) TARGET_ARGS=(); shift ;;
    --gateway) TARGET_ARGS=(--gateway); shift ;;
    --node) NODE="${2:-}"; [[ -z "$NODE" ]] && { echo "Missing node id/name/ip" >&2; exit 2; }; TARGET_ARGS=(--node "$NODE"); shift 2 ;;
    --agent) AGENT="${2:-main}"; shift 2 ;;
    -y|--yes) YES=1; shift ;;
    --dry-run) DRY=1; shift ;;
    --broad-paths) BROAD=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown arg: $1" >&2; usage; exit 2 ;;
  esac
done

need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }
need openclaw

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
TEMPLATE="$ROOT/openclaw/exec-approvals.template.json"
OCSAFE="$ROOT/scripts/oc-safe.sh"

[[ -f "$TEMPLATE" ]] || { echo "ERROR: Missing template: $TEMPLATE" >&2; exit 1; }
[[ -f "$OCSAFE" ]] || { echo "ERROR: Missing oc-safe wrapper: $OCSAFE" >&2; exit 1; }

os_name="$(uname -s | tr '[:upper:]' '[:lower:]' || true)"

echo "== OpenClaw approvals apply (final boss) =="
echo "Target: ${TARGET_ARGS[*]:-(local)}"
echo "Agent:  $AGENT"
echo "Repo:   $ROOT"
echo "OS:     $os_name"
echo "Dry:    $DRY"
echo "Broad:  $BROAD"
echo

if [[ "$DRY" -eq 1 ]]; then
  YES=1
fi

if [[ "$YES" -ne 1 ]]; then
  echo "This will overwrite approvals using:"
  echo "  $TEMPLATE"
  echo "and then add allowlist entries for:"
  echo "  $OCSAFE"
  echo
  echo "Optional (dangerous): --broad-paths adds globs like /opt/homebrew/bin/* and /usr/bin/*."
  echo
  read -r -p "Proceed? [y/N] " ans
  case "${ans:-}" in
    y|Y|yes|YES) ;;
    *) echo "Aborted."; exit 0 ;;
  esac
fi

run() {
  if [[ "$DRY" -eq 1 ]]; then
    printf '+ %q ' "$@"; echo
    return 0
  fi
  "$@"
}

# 1) Replace approvals from file
run openclaw approvals set "${TARGET_ARGS[@]}" --file "$TEMPLATE"

# 2) Allowlist repo-specific oc-safe (exact path)
run openclaw approvals allowlist add "${TARGET_ARGS[@]}" --agent "$AGENT" "$OCSAFE"

# 3) Add resolved binary paths for common deps (if present)
maybe_add_bin() {
  local bin="$1"
  local path=""
  path="$(command -v "$bin" 2>/dev/null || true)"
  if [[ -n "$path" ]]; then
    run openclaw approvals allowlist add "${TARGET_ARGS[@]}" --agent "$AGENT" "$path" >/dev/null 2>&1 || true
    echo "OK allowlisted: $path"
  fi
}

echo
echo "== Adding common binaries (resolved paths, if found) =="
for b in docker docker-compose colima curl git python3 node npm npx; do
  maybe_add_bin "$b" || true
done

# 4) OS-aware common location patterns (safe-ish: targeted, not "everything")
# These patterns help when PATH differs between interactive shell and daemon.
echo
echo "== Adding OS-aware path patterns (safe-ish) =="
# Always add the repo pattern too (portable across machines)
run openclaw approvals allowlist add "${TARGET_ARGS[@]}" --agent "$AGENT" "~/Projects/**/cardano-agent-skills/scripts/oc-safe.sh" >/dev/null 2>&1 || true
echo "OK allowlisted: ~/Projects/**/cardano-agent-skills/scripts/oc-safe.sh"

if [[ "$os_name" == "darwin" ]]; then
  # Homebrew Intel + Apple Silicon common locations (for specific bins)
  for p in \
    "/opt/homebrew/bin/docker" \
    "/opt/homebrew/bin/docker-compose" \
    "/opt/homebrew/bin/colima" \
    "/opt/homebrew/bin/curl" \
    "/opt/homebrew/bin/git" \
    "/usr/local/bin/docker" \
    "/usr/local/bin/docker-compose" \
    "/usr/local/bin/colima" \
    "/usr/bin/curl" \
    "/usr/bin/git" \
    "/usr/bin/python3" \
  ; do
    run openclaw approvals allowlist add "${TARGET_ARGS[@]}" --agent "$AGENT" "$p" >/dev/null 2>&1 || true
    echo "OK allowlisted: $p"
  done
else
  # Linux common locations (for specific bins)
  for p in \
    "/usr/bin/docker" \
    "/usr/bin/docker-compose" \
    "/usr/bin/curl" \
    "/usr/bin/git" \
    "/usr/bin/python3" \
    "/usr/local/bin/docker" \
    "/usr/local/bin/docker-compose" \
    "/usr/local/bin/curl" \
    "/usr/local/bin/git" \
  ; do
    run openclaw approvals allowlist add "${TARGET_ARGS[@]}" --agent "$AGENT" "$p" >/dev/null 2>&1 || true
    echo "OK allowlisted: $p"
  done
fi

# 5) OPTIONAL broad patterns (requested) — dangerous: effectively "allow many binaries"
if [[ "$BROAD" -eq 1 ]]; then
  echo
  echo "== Adding BROAD directory globs (DANGEROUS) =="
  if [[ "$os_name" == "darwin" ]]; then
    for pat in "/opt/homebrew/bin/*" "/usr/local/bin/*" "/usr/bin/*"; do
      run openclaw approvals allowlist add "${TARGET_ARGS[@]}" --agent "$AGENT" "$pat" >/dev/null 2>&1 || true
      echo "WARNING allowlisted: $pat"
    done
  else
    for pat in "/usr/local/bin/*" "/usr/bin/*"; do
      run openclaw approvals allowlist add "${TARGET_ARGS[@]}" --agent "$AGENT" "$pat" >/dev/null 2>&1 || true
      echo "WARNING allowlisted: $pat"
    done
  fi
  echo "WARNING Broad globs reduce safety. Prefer allowlisting oc-safe + specific binaries."
fi

echo
echo "Done. Recommended session defaults inside OpenClaw:"
echo "  /exec host=gateway security=allowlist ask=on-miss"
</file>

<file path="scripts/install.ps1">
Param(
  [ValidateSet("project","global")]
  [string]$Scope = "project",
  [switch]$Yes,
  [string]$Repo = "Flux-Point-Studios/cardano-agent-skills"
)

$ErrorActionPreference = "Stop"

function Need($cmd) {
  if (-not (Get-Command $cmd -ErrorAction SilentlyContinue)) {
    throw "Missing dependency: $cmd"
  }
}

Need node
Need npm
Need npx

Write-Host "== Installing Cardano Agent Skills =="
Write-Host "Repo:   $Repo"
Write-Host "Scope:  $Scope"
Write-Host "Agents: claude-code + openclaw"
Write-Host ""

$npmyes = @()
$cliyes = @()
if ($Yes) { $npmyes = @("-y"); $cliyes = @("-y") }

$scopeFlag = @()
if ($Scope -eq "global") { $scopeFlag = @("-g") }

& npx @npmyes skills add $Repo --skill '*' -a claude-code -a openclaw @scopeFlag @cliyes

Write-Host ""
Write-Host "== Post-install sanity =="

if ($Scope -eq "project") {
  if (Test-Path ".claude/skills") { Write-Host "OK Claude Code skills present: .claude/skills/" }
  else { Write-Host "WARN Claude Code skills not found at .claude/skills" }

  if (Test-Path "skills") { Write-Host "OK OpenClaw workspace skills present: ./skills/" }
  else { Write-Host "WARN OpenClaw workspace skills not found at ./skills" }
}

if ($Scope -eq "global") {
  $home = $HOME
  $moltbot = Join-Path $home ".moltbot/skills"
  $openclaw = Join-Path $home ".openclaw/skills"

  if (Test-Path (Join-Path $home ".claude/skills")) { Write-Host "OK Claude Code global skills present: ~/.claude/skills/" }
  else { Write-Host "WARN Claude Code global skills not found at ~/.claude/skills" }

  if (Test-Path $moltbot) { Write-Host "OK OpenClaw (skills CLI) global skills present: ~/.moltbot/skills/" }
  else { Write-Host "WARN OpenClaw (skills CLI) global skills not found at ~/.moltbot/skills" }

  if (-not (Test-Path $openclaw) -and (Test-Path $moltbot)) {
    New-Item -ItemType Directory -Force (Split-Path $openclaw) | Out-Null
    try {
      cmd /c "mklink /D `"$openclaw`" `"$moltbot`"" | Out-Null
      if (Test-Path $openclaw) { Write-Host "OK Linked ~/.openclaw/skills -> ~/.moltbot/skills (compat)" }
    } catch {
      Write-Host "WARN Could not create symlink ~/.openclaw/skills. Alternative:"
      Write-Host "    Add skills.load.extraDirs: [`"$moltbot`"] in ~/.openclaw/openclaw.json"
    }
  }
}

Write-Host ""
Write-Host "Done."
</file>

<file path="scripts/install.sh">
#!/usr/bin/env bash
set -euo pipefail

REPO="${REPO:-Flux-Point-Studios/cardano-agent-skills}"
SCOPE="project" # project|global
YES=0

usage() {
  cat <<'EOF'
Usage: scripts/install.sh [--project|--global] [--yes]

Installs Flux Point Studios' Cardano Agent Skills for BOTH:
  - Claude Code (agent: claude-code)  -> .claude/skills/ or ~/.claude/skills
  - OpenClaw   (agent: openclaw)      -> ./skills/ or ~/.moltbot/skills (as installed by the skills CLI)

Notes:
  - OpenClaw loads workspace skills from <workspace>/skills and managed skills from ~/.openclaw/skills.
  - The skills CLI currently installs OpenClaw globally to ~/.moltbot/skills; this script bridges that by symlinking
    ~/.openclaw/skills -> ~/.moltbot/skills when possible, or prints the extraDirs fallback.

Examples:
  ./scripts/install.sh --project --yes
  ./scripts/install.sh --global --yes

Env overrides:
  REPO=owner/repo  (default Flux-Point-Studios/cardano-agent-skills)
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --project) SCOPE="project"; shift ;;
    --global)  SCOPE="global"; shift ;;
    -y|--yes)  YES=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) echo "Unknown arg: $1" >&2; usage; exit 2 ;;
  esac
done

need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }
need node
need npm
need npx

NPM_YES=()
CLI_YES=()
if [[ "$YES" -eq 1 ]]; then
  NPM_YES=(-y)
  CLI_YES=(-y)
fi

SCOPE_FLAG=()
if [[ "$SCOPE" == "global" ]]; then
  SCOPE_FLAG=(-g)
fi

echo "== Installing Cardano Agent Skills =="
echo "Repo:   $REPO"
echo "Scope:  $SCOPE"
echo "Agents: claude-code + openclaw"
echo

npx "${NPM_YES[@]}" skills add "$REPO" --skill '*' -a claude-code -a openclaw "${SCOPE_FLAG[@]}" "${CLI_YES[@]}"

echo
echo "== Post-install sanity =="

if [[ "$SCOPE" == "project" ]]; then
  [[ -d ".claude/skills" ]] && echo "OK Claude Code skills present: .claude/skills/" || echo "WARN Claude Code skills not found at .claude/skills"
  [[ -d "skills" ]] && echo "OK OpenClaw workspace skills present: ./skills/" || echo "WARN OpenClaw workspace skills not found at ./skills"
fi

if [[ "$SCOPE" == "global" ]]; then
  MOLTBOT_SKILLS="${HOME}/.moltbot/skills"
  OPENCLAW_SKILLS="${HOME}/.openclaw/skills"

  [[ -d "${HOME}/.claude/skills" ]] && echo "OK Claude Code global skills present: ~/.claude/skills/" || echo "WARN Claude Code global skills not found at ~/.claude/skills"
  [[ -d "$MOLTBOT_SKILLS" ]] && echo "OK OpenClaw (skills CLI) global skills present: ~/.moltbot/skills/" || echo "WARN OpenClaw (skills CLI) global skills not found at ~/.moltbot/skills"

  if [[ ! -e "$OPENCLAW_SKILLS" && -d "$MOLTBOT_SKILLS" ]]; then
    mkdir -p "$(dirname "$OPENCLAW_SKILLS")"
    ln -s "$MOLTBOT_SKILLS" "$OPENCLAW_SKILLS" 2>/dev/null || true
    if [[ -L "$OPENCLAW_SKILLS" ]]; then
      echo "OK Linked ~/.openclaw/skills -> ~/.moltbot/skills (compat)"
    else
      echo "WARN Could not symlink ~/.openclaw/skills. Alternative:"
      echo "    Add skills.load.extraDirs: [\"$MOLTBOT_SKILLS\"] in ~/.openclaw/openclaw.json"
    fi
  fi
fi

echo
echo "Done."
</file>

<file path="scripts/oc-safe.sh">
#!/usr/bin/env bash
set -euo pipefail

# oc-safe.sh — allowlist-friendly command wrapper
#
# Purpose:
# - Provide a single, easy-to-allowlist entrypoint for OpenClaw Exec allowlist mode.
# - Avoid shell features (pipes/redirects/chaining) by NOT accepting them and by dispatching to fixed wrappers.
#
# Usage:
#   ./scripts/oc-safe.sh cardano version
#   ./scripts/oc-safe.sh cardano query tip --mainnet
#   ./scripts/oc-safe.sh hydra --help
#   ./scripts/oc-safe.sh hydra gen-hydra-key --output-file hydra
#   ./scripts/oc-safe.sh hydra-api 4001 head
#
# Notes:
# - This script refuses common shell metacharacters in arguments.
# - It dispatches only to known wrapper scripts in this repo.
#
# You should allowlist THIS script path (not bash) in exec approvals.

die() { echo "ERROR: $*" >&2; exit 2; }

if [[ $# -lt 1 ]]; then
  die "Usage: oc-safe.sh <cardano|hydra|hydra-api> [args...]"
fi

# Reject metacharacters (defense-in-depth; Exec allowlist also rejects many)
for a in "$@"; do
  case "$a" in
    *"|"*|*";"*|*"&&"*|*"||"*|*">"*|*"<"*|*"$("*|*"\`"*)
      die "Refusing shell metacharacters in args: $a"
      ;;
  esac
done

verb="$1"; shift

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

case "$verb" in
  cardano)
    exec "$ROOT/skills/cardano-cli-operator/scripts/cardano-cli.sh" "$@"
    ;;
  hydra)
    exec "$ROOT/skills/hydra-head-operator/scripts/hydra-node.sh" "$@"
    ;;
  hydra-api)
    # expects: <port> [head|health|metrics]
    exec "$ROOT/skills/hydra-head-operator/scripts/hydra-api.sh" "$@"
    ;;
  *)
    die "Unknown verb: $verb (use cardano|hydra|hydra-api)"
    ;;
esac
</file>

<file path="shared/PRINCIPLES.md">
# Cardano Engineering Principles (Skill Pack Shared Notes)

- **Never assume CLI syntax**: run `cardano-cli --help` and `cardano-cli <era> --help` to confirm flags.
- **Never hardcode protocol params**: fetch params from the target network right before building transactions.
- **Prefer `transaction build` (online)** for convenience; use `build-raw` + offline signing for cold-key ops.
- **Treat signing keys as radioactive**: keep payment.skey / stake.skey off internet boxes when possible.
- **Test on Preprod/Preview first** before Mainnet, especially script spends.
- **Keep outputs deterministic**: always record tx body, witness set, scripts, datum/redeemer, and pparams used.
</file>

<file path="skills/aiken-dex-security-audit/references/audit-framework.md">
# Deep Research / Audit Framework Prompt (Plutus V3 + Aiken DEX)

You are a senior smart-contract security auditor specializing in Cardano eUTxO DeFi, Plutus V3, and Aiken.
Your job: produce a comprehensive, adversarial security audit of a DEX's on-chain Aiken (Plutus V3) contracts and any critical off-chain transaction-building code in scope.

Hard rules
- No hallucinations. If something is unknown, say "unknown" and list exactly what evidence is missing.
- Cite sources for every factual claim about protocol behavior, Plutus V3 semantics, and known vulnerability classes (use official docs/CIPs first).
- Be attacker-minded: assume a malicious user can craft arbitrary transactions, datums, redeemers, and UTxOs, and can combine multiple script interactions in one tx.
- Output must be reproducible: include steps, minimal failing tx shapes, and test cases.

Inputs (I will provide / you must request if missing)
1) Repo URL or code snapshot + commit SHA / tag
2) Which scripts exist and their purposes (spend/mint/reward/certify; plus any governance-related if used)
3) Datum + redeemer schemas (types + encoding)
4) Deployment parameters, policy IDs, script hashes (or how they are derived)
5) Off-chain tx builder(s): language, modules, and which endpoints create DEX transactions
6) Threat model assumptions: admin keys? upgradeability? emergency controls? oracle dependencies?
7) Target network + constraints: mainnet/testnet, max tx size assumptions, execution units budgets, reference scripts usage, inline datums usage

Context you must account for
- Plutus V3: all scripts take a single argument (script context), datum/redeemer live inside context; datum may be absent; success requires returning BuiltinUnit. Identify any logic that breaks due to these semantics. (Cite.)
- eUTxO: state is represented as UTxOs; concurrency, multi-input transactions, and "compose many actions in one tx" are default attacker tools. (Cite.)
- Use Cardano's published vulnerability categories as a checklist baseline (e.g., double satisfaction, missing UTxO authentication, time handling, token security, unbounded datum/value, etc.). (Cite.)
- Follow CIP-52-style audit rigor: enumerate artefacts examined, assumptions, and evidence produced. (Cite.)

Audit objectives
A) Safety: no theft, mint/burn exploits, unauthorized state transitions, stuck funds, or bypasses
B) Correctness: matches the intended AMM/orderbook math, fees, and accounting invariants
C) Liveness/DoS resistance: protocol cannot be trivially stalled or made unspendable via datum/value growth, dust, UTxO poisoning, or execution budget griefing
D) Parameter & deployment integrity: script instances, policy IDs, and config invariants are sound

Required workflow (do ALL of this)
1) System model (1–2 pages)
   - Map every script, datum, redeemer, and state UTxO.
   - Draw the "state machine" transitions as: (inputs, outputs, minted/burned, required signers, validity interval constraints).

2) Invariants (must be explicit and testable)
   - List hard invariants for each script/state:
     * conservation of value (no value created except via intended mint policy)
     * LP token supply rules / pool share accounting
     * fee calculation bounds and rounding safety
     * authorization/authentication rules (who can create/consume state UTxOs)
     * "exactly-one" vs "at-least-one" state UTxO constraints
     * datum size/value size boundedness over time
   - For each invariant: define how an attacker would try to violate it.

3) Threat model & attack surface
   - Enumerate attacker capabilities in Cardano eUTxO.
   - Identify trusted roles (if any), admin keys, parameterization, oracles, and upgrade paths.
   - List "economic attacks" (price manipulation, sandwich/MEV-adjacent, stale oracle, griefing) relevant to this DEX design.

4) Manual code review (on-chain)
   - Review Aiken validators/policies line-by-line.
   - Confirm every branch checks the right UTxOs, outputs, minted assets, datum correctness, redeemer correctness, signers, and validity interval logic.
   - Specifically hunt for:
     * double satisfaction / multi-UTxO composition issues
     * missing UTxO authentication (fake state UTxOs at script address)
     * time interval boundary mistakes (inclusive/exclusive, upper/lower bound misuse)
     * token security mistakes (policy checks, asset class mismatches, dust/poisoning)
     * unbounded datum/value growth paths leading to unspendable outputs
     * integer overflow/underflow, rounding, division-by-zero, negative amounts
     * incorrect "exactly one input/output" enforcement
     * failure to validate inline datum vs datum hash expectations
     * reference script/reference input pitfalls (if used)
   - For each suspected issue: provide the exact condition, why it's exploitable, and the minimal tx shape.

5) Manual review (off-chain tx building) — if in scope
   - Verify the builder cannot construct "valid but unsafe" transactions.
   - Ensure it enforces same invariants as on-chain (esp. output ordering, datum placement, mint fields, fee outputs).
   - Confirm it cannot be tricked into signing a malicious tx (wallet prompts, metadata confusion, address substitution).

6) Testing & evidence (Aiken-first)
   - Create/extend Aiken unit tests AND property-based tests covering:
     * valid transitions for each redeemer path
     * adversarial inputs fuzzing (randomized datums/redeemers/values)
     * multi-action in one tx scenarios (compose swaps + liquidity + withdrawals)
     * boundary testing for time intervals, min-ADA, minUTxO, fee rounding, and large token bundles
   - Provide commands to run tests (e.g., aiken check) and expected results.
   - Include "attack regression tests": one test per finding that fails before fix and passes after.

7) Execution budget & size analysis
   - Identify hotspots and paths likely to exceed CPU/mem units or tx size.
   - Recommend refactors to reduce cost without weakening security.
   - Flag any logic that can be forced into high-cost evaluation by attackers (griefing).

8) Findings & remediation
   - Produce a table: ID | Title | Severity (Critical/High/Med/Low/Info) | Likelihood | Impact | Affected files/lines | Exploit sketch | Recommended fix | Test added
   - Provide concrete patches (diff-style) when possible.
   - For design-level risks: propose safer redesign patterns.

Deliverables (final output format)
- Executive summary (non-technical, 10–15 bullets)
- Architecture & state machine overview
- Threat model + assumptions
- Invariants list (testable statements)
- Findings table + detailed writeups
- Recommended patches + test suite additions
- Deployment checklist (parameter validation, script hash verification, monitoring hooks)
- "Known-unknowns": what you could not verify and why

Stop conditions
- Do not declare "secure." Instead: "No issues found in reviewed scope given stated assumptions," and list residual risk.
</file>

<file path="skills/aiken-dex-security-audit/references/findings-severity-guide.md">
# Severity Guide (DEX / DeFi)

## Critical
- Direct theft of user funds or pool reserves
- Infinite mint / arbitrary burn of valuable assets
- Permanent loss / irrecoverable stuck funds
- Bypass of core auth leading to catastrophic state transitions

## High
- Theft possible with additional assumptions or timing
- Major protocol DoS that blocks swaps/liquidity reliably
- Significant accounting break that enables unfair extraction

## Medium
- DoS or griefing that is real but costs attacker meaningfully
- Edge-case accounting errors with limited impact
- Misconfiguration risk that could lead to loss if deployed wrong

## Low / Info
- Best-practice gaps, readability, missing checks that don't appear exploitable
- Minor inefficiencies or non-critical validations
</file>

<file path="skills/aiken-dex-security-audit/templates/audit-report.md">
# Security Audit Report — <DEX NAME> (Aiken / Plutus V3)

## Scope
- Repo: <url/path>
- Commit: <sha>
- In-scope scripts:
  - <script> — <purpose>
- Out-of-scope:
  - <stuff>

## Assumptions
- <explicit assumptions>
- Trusted roles / keys: <none | describe>
- Oracles: <none | describe>

## System Model
### Assets
- <policy.asset> — <role>

### State UTxOs
- <state utxo name> — address: <...>, datum: <...>, value: <...>

### State Machine (Transitions)
- <transition name>
  - Inputs:
  - Outputs:
  - Mint/Burn:
  - Required signers:
  - Validity interval:

## Invariants (Testable)
- INV-001: <statement>
  - How attacker tries to break it:
  - Evidence/tests:

## Threat Model
- Attacker capabilities (eUTxO):
- Attack surfaces:
- Economic / griefing vectors:

## Findings Summary Table
| ID | Title | Severity | Likelihood | Impact | Affected | Exploit Sketch | Fix | Test Added |
|---:|-------|----------|------------|--------|----------|---------------|-----|-----------|
| F-001 | <title> | <Critical/High/Med/Low/Info> | <High/Med/Low> | <...> | <files:lines> | <tx shape ref> | <patch> | <test> |

## Detailed Findings
### F-001 — <title>
- Severity: <...>
- Root cause:
- Exploitability:
- Minimal exploit tx shape:
  - See: `templates/tx-shapes.md` filled as `F-001`
- Recommended fix:
- Regression test:

## Execution Budget / DoS Review
- Hot paths:
- Griefing vectors:
- Recommendations:

## Deployment Checklist
- Script hash verification:
- Parameter locking strategy:
- Monitoring hooks:
- Emergency procedures:

## Known-Unknowns / Gaps
- <what couldn't be verified and why>
</file>

<file path="skills/aiken-dex-security-audit/templates/invariants-checklist.md">
# Invariants Checklist — Aiken DEX (Plutus V3)

## Value & Accounting
- [ ] Conservation of value (no unexpected value creation)
- [ ] Mint/burn only via intended policy, with correct asset class checks
- [ ] Fees are bounded, non-negative, and rounding is safe
- [ ] No division-by-zero, no negative amounts, no overflow/underflow

## State Authentication
- [ ] State UTxO(s) cannot be spoofed (authenticity checks exist)
- [ ] Exactly-one vs at-least-one state UTxO is enforced correctly
- [ ] Datum format validated (inline vs hash expectations consistent)
- [ ] Redeemer paths are mutually exclusive or safely composable

## Composability / eUTxO Multi-Action Safety
- [ ] "Double satisfaction" (multi-UTxO satisfaction) not possible
- [ ] Multi-action txs cannot bypass checks (swap+deposit+withdraw combos)
- [ ] Reference inputs/scripts do not allow bypasses

## Time / Validity Interval
- [ ] Lower/upper bound logic correct (inclusive/exclusive as intended)
- [ ] No "forever-valid" griefing path; time constraints match design

## Boundedness / Liveness
- [ ] Datum cannot grow unbounded over time
- [ ] Token bundle size cannot be weaponized (dust / UTxO poisoning)
- [ ] Script remains spendable under adversarial deposits

## Access Control / Admin Features (if any)
- [ ] Admin keys strictly scoped to intended actions
- [ ] Upgrades/migrations cannot steal user funds
- [ ] Emergency controls cannot be abused

## Evidence
- [ ] Unit tests for each valid transition path
- [ ] Property tests for invariants
- [ ] Regression test per finding (fails before fix, passes after)
</file>

<file path="skills/aiken-dex-security-audit/templates/tx-shapes.md">
# Minimal Exploit Transaction Shapes (Template)

Purpose: standardize how we describe "the smallest transaction that breaks the invariant."
Fill one of these per finding (F-###).

---

## Finding ID: F-###
### Title
<short title>

### Goal
What the attacker wants (steal funds, mint infinite, bypass fee, brick pool, etc.)

### Preconditions
- Existing UTxOs required:
  - UTxO-A: <address> <value> <datum?>
  - UTxO-B: ...
- Parameters assumed:
  - <policy id / script hash / config>

### Transaction Skeleton

#### Inputs (consumed)
1) Input: <tx#ix>
   - Address: <pubkey | script>
   - Value: <assets>
   - Datum: <inline | hash | none>
   - Script? <yes/no> — if yes: which validator
   - Redeemer: <redeemer variant + key fields>

2) ...

#### Reference Inputs (read-only)
- Ref-1: <tx#ix> — used for <ref script | datum | config>

#### Mint / Burn
- Minted:
  - + <policy.asset> : <amount>
- Burned:
  - - <policy.asset> : <amount>
- Redeemer for mint policy: <...>

#### Outputs (created)
1) Output:
   - Address: <pubkey | script>
   - Value: <assets>
   - Datum: <inline | hash | none>

2) ...

#### Required Signers
- <key hash list> (or "none")

#### Validity Interval
- lower bound: <slot/time> (or none)
- upper bound: <slot/time> (or none)

#### Withdrawals / Certificates (if relevant)
- Withdrawals: <stake address -> amount>
- Certificates: <...>

#### Fees / Collateral (if relevant)
- Fee: <lovelace>
- Collateral inputs: <...>

### Why this passes today (root cause)
Explain precisely which check(s) are missing/incorrect and how the tx structure exploits it.

### What invariant it violates
Reference the invariant ID from `invariants-checklist.md` or your report.

### Expected outcome
What the chain state looks like after (who gained what, what got bricked, etc.)

### Regression Test Plan (Aiken)
- Test name: `test_f_###_<short>`
- Setup:
- Assertion:
- Failure mode before fix:
</file>

<file path="skills/aiken-dex-security-audit/SKILL.md">
---
name: aiken-dex-security-audit
description: Adversarial security audit playbook for Plutus V3 Aiken DEX contracts (threat model, invariants, findings, tests, tx repro shapes).
metadata:
  domain: cardano
  language: aiken
  category: security-audit
---

# aiken-dex-security-audit

## When to use
- Auditing Plutus V3 Aiken contracts for a DEX (validators + minting policies)
- You need a rigorous report: threat model, invariants, findings, and reproducible exploit tx shapes

## Non-negotiable rules
- No hallucinations. If something isn't in the repo or inputs, say **unknown** and list exactly what's missing.
- Assume a hostile attacker can craft arbitrary transactions: multi-input, multi-action, weird datums, weird token bundles.
- Never ask for or handle seed phrases / private keys.
- Prefer evidence over vibes: minimal tx shape + failing test + fix + passing test.

## Required inputs (ask for anything missing)
1) Script list + purpose (spend/mint/reward/cert) and which are critical path for swaps/liquidity
2) Datum/redeemer schemas (Aiken types + encoding expectations)
3) Parameters/config: policy IDs, script hashes, upgrade/admin controls, oracle deps (if any)
4) Off-chain tx builder(s) in scope (where swaps/liquidity txs are constructed)
5) Network assumptions (mainnet/preprod) + constraints (tx size, exunits, reference scripts, inline datums)

## Audit workflow (do ALL)
1) Build a system model
   - Map state UTxOs, assets, script addresses, and transitions (inputs/outputs/mint/burn/signees/time).
2) Extract explicit invariants (testable)
   - Value conservation, LP supply rules, fee bounds/rounding, auth rules, "exactly-one state UTxO", bounded datum/value growth.
3) Threat model & attack surface
   - Attacker capabilities in eUTxO; trusted roles; upgrade/emergency keys; oracles; economic/griefing vectors.
4) Manual on-chain review
   - For each validator/policy branch: what must be true about inputs/outputs/minted/signers/time?
   - Hunt: double satisfaction, fake-state UTxOs, asset-class mismatches, optional datum gotchas, unbounded growth, time-range bugs, division/rounding/negative amounts, "exactly one" enforcement bugs.
   - For each issue: minimal exploitable tx shape + why it works (use tx-shapes template).
5) Off-chain review (if in scope)
   - Ensure builder cannot construct valid-but-unsafe txs or mis-hash datums or mis-handle mint fields.
6) Evidence suite (Aiken-first)
   - Add unit tests + property tests for each invariant + each exploit regression test.
7) Budget & DoS analysis
   - Identify evaluation hotspots and griefing paths; recommend safe refactors.
8) Report
   - Use `templates/audit-report.md` and include: scope, assumptions, invariants, findings table, patches, tests, deployment checklist.

## Files to use
- Full framework prompt: `references/audit-framework.md`
- Report template: `templates/audit-report.md`
- Invariants checklist: `templates/invariants-checklist.md`
- Minimal exploit tx shapes: `templates/tx-shapes.md`
</file>

<file path="skills/aiken-dex-security-audit-operator/SKILL.md">
---
name: aiken-dex-security-audit-operator
description: "Operator skill: run local Aiken build/test commands and capture evidence for the audit. Manual invoke only."
metadata:
  manual: "true"
---

# aiken-dex-security-audit-operator

## Rule
This is for "hands-on-keyboard" runs (aiken check/build) and collecting logs. Only run commands the user explicitly requests.

## Procedure
1) Confirm repo path + commit
   - `git rev-parse --short HEAD`
2) Record tool versions
   - `aiken --version`
3) Run checks
   - `aiken check`
   - `aiken build`
4) If tests fail: capture failing test/property name, file/line, and minimal repro info.
5) Feed outputs into the audit report evidence section.
</file>

<file path="skills/aiken-smart-contracts/reference/aiken-workflow.md">
# Aiken workflow (practical)

```bash
aiken --version
aiken build
```

Common artifact flow:
- Build the project
- Generate a blueprint (if your project uses one)
- Convert blueprint to a script format the CLI can consume

```bash
# Example (verify subcommands in your Aiken version)
aiken blueprint convert <your-blueprint.json> -o validator.plutus
```

Then use `validator.plutus` with `cardano-cli` script transaction commands.
</file>

<file path="skills/aiken-smart-contracts/SKILL.md">
---
name: aiken-smart-contracts
description: "Aiken workflows: validators, building, blueprints, .plutus generation. Safe guidance for smart contract development."
allowed-tools:
  - Bash(aiken:*)
  - Bash(cardano-cli:*)
  - Read
  - Write
context:
  - "!aiken --version 2>&1 | head -3"
  - "!aiken --help 2>&1 | head -20"
metadata: {"openclaw":{"emoji":"\ud83e\uddf0","requires":{"anyBins":["cardano-cli","docker"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# aiken-smart-contracts

## When to use
- Writing or auditing Aiken validators
- Building and testing smart contracts
- Generating .plutus artifacts for CLI/MeshJS

## Operating rules (must follow)
- Confirm Aiken version before generating code
- Verify script hashes after every rebuild
- Test on preprod/preview before mainnet
- Treat datum/redeemer schemas as versioned APIs

## Workflow

### 1. Initialize project
```bash
aiken new my-project
cd my-project
```

### 2. Project structure
```
my-project/
├── aiken.toml           # Project config
├── lib/                 # Reusable modules
├── validators/          # Validator entry points
│   └── my_validator.ak
└── plutus.json          # Generated blueprint
```

### 3. Write validator
```aiken
// validators/my_validator.ak
use aiken/transaction.{ScriptContext}

validator {
  fn spend(datum: Data, redeemer: Data, ctx: ScriptContext) -> Bool {
    // Your validation logic
    True
  }
}
```

### 4. Build and test
```bash
# Build all validators
aiken build

# Run tests
aiken check

# Format code
aiken fmt
```

### 5. Generate artifacts
```bash
# Blueprint is auto-generated at plutus.json
# Extract .plutus for cardano-cli:
aiken blueprint convert > my_validator.plutus

# Get script hash
cardano-cli conway transaction policyid \
  --script-file my_validator.plutus
```

### 6. Derive script address
```bash
cardano-cli conway address build \
  --payment-script-file my_validator.plutus \
  --testnet-magic 1 \
  --out-file script.addr
```

## Examples

### Example: Simple spending validator
**User request:** "Create a validator that only allows spending by a specific pubkey"

**Response:**
```aiken
// validators/pubkey_lock.ak
use aiken/hash.{Blake2b_224, Hash}
use aiken/transaction.{ScriptContext, Spend}
use aiken/transaction/credential.{VerificationKey}

type Datum {
  owner: Hash<Blake2b_224, VerificationKey>
}

type Redeemer {
  // Could be unit if no redeemer data needed
}

validator {
  fn spend(datum: Datum, _redeemer: Redeemer, ctx: ScriptContext) -> Bool {
    let ScriptContext { transaction, purpose } = ctx
    expect Spend(_) = purpose

    // Check if owner signed the transaction
    list.has(transaction.extra_signatories, datum.owner)
  }
}
```

```bash
# Build
aiken build

# Test
aiken check

# Generate .plutus
aiken blueprint convert > pubkey_lock.plutus
```

### Example: Parameterized validator
**User request:** "Create a time-locked validator"

**Response:**
```aiken
// validators/time_lock.ak
use aiken/interval.{Finite, Interval, IntervalBound}
use aiken/transaction.{ScriptContext, ValidityRange}

type Datum {
  lock_until: Int  // POSIX time in milliseconds
}

validator {
  fn spend(datum: Datum, _redeemer: Data, ctx: ScriptContext) -> Bool {
    let valid_range: ValidityRange = ctx.transaction.validity_range

    // Check if current time is past lock_until
    when valid_range.lower_bound.bound_type is {
      Finite(tx_earliest_time) -> tx_earliest_time > datum.lock_until
      _ -> False
    }
  }
}
```

## V3 considerations (Conway)
- Single unified context argument
- Datum may be optional for some patterns
- Governance script purposes available
- Use `aiken build --plutus-version v3` if targeting V3

## Safety / key handling
- Datum/redeemer are on-chain visible—no secrets
- Version your datum schemas (breaking changes break funds)
- Verify script hash matches after any rebuild
- Always test with small amounts first

## References
- `shared/PRINCIPLES.md`
- [Aiken documentation](https://aiken-lang.org)
- `cardano-cli-plutus-scripts` (for deployment)
</file>

<file path="skills/cardano-cli-doctor/reference/docker-fallback.md">
# Docker fallback (cardano-cli)

This skill includes `scripts/cardano-cli.sh`, which runs `cardano-cli` either:
- directly from your PATH, or
- inside Docker using `ghcr.io/intersectmbo/cardano-node`.

Basic usage:
```bash
chmod +x scripts/cardano-cli.sh
scripts/cardano-cli.sh version
```

If you have a node socket locally:
```bash
export CARDANO_NODE_SOCKET_PATH=/path/to/node.socket
scripts/cardano-cli.sh query tip --mainnet
```

Override container tag:
```bash
CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:10.6.1 scripts/cardano-cli.sh version
```
</file>

<file path="skills/cardano-cli-doctor/reference/doctor.md">
# cardano-cli-doctor reference

## Quick diagnostic commands (copy/paste)
```bash
cardano-cli version
cardano-cli --help | sed -n '1,60p'
cardano-cli conway --help | sed -n '1,40p' || true
cardano-cli latest --help | sed -n '1,40p' || true
cardano-cli transaction build --help | sed -n '1,120p'
```

## What to look for
- Era-prefixed support: `cardano-cli conway ...` exists and returns help without error.
- Legacy era flags: `--babbage-era` / `--alonzo-era` appear under `transaction build --help` or similar.

## Recommended styles
**Era-prefixed (preferred when available):**
```bash
cardano-cli conway query protocol-parameters --mainnet --out-file pparams.json
cardano-cli conway transaction build --mainnet ... --out-file tx.body
```

**Legacy flags (fallback):**
```bash
cardano-cli query protocol-parameters --mainnet --out-file pparams.json
cardano-cli transaction build --babbage-era --mainnet ... --out-file tx.body
```
</file>

<file path="skills/cardano-cli-doctor/scripts/cardano-cli-doctor.sh">
#!/usr/bin/env bash
set -euo pipefail

echo "== cardano-cli-doctor =="
echo

if ! command -v cardano-cli >/dev/null 2>&1; then
  echo "ERROR: cardano-cli not found in PATH"
  exit 1
fi

echo "-- version --"
cardano-cli version || true
echo

echo "-- top help --"
cardano-cli --help | sed -n '1,60p' || true
echo

echo "-- era-prefixed probes --"
for era in latest conway babbage alonzo mary allegra shelley byron; do
  if cardano-cli "$era" --help >/dev/null 2>&1; then
    echo "SUPPORTED era prefix: $era"
  fi
done
echo

echo "-- legacy era flag probe (transaction build help excerpt) --"
cardano-cli transaction build --help | sed -n '1,140p' || true
echo

echo "== done =="
</file>

<file path="skills/cardano-cli-doctor/scripts/cardano-cli.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${CARDANO_DOCKER_IMAGE:-ghcr.io/intersectmbo/cardano-node:latest}"

if command -v cardano-cli >/dev/null 2>&1; then
  exec cardano-cli "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: cardano-cli not found and docker not installed. Install cardano-cli or docker." >&2
  exit 1
fi

# Mount current working directory for inputs/outputs (datum, pparams, tx.body, etc.)
ARGS=(docker run --rm -i -v "$PWD":/work -w /work)

# If a node socket is available, mount it and forward env var.
if [[ "${CARDANO_NODE_SOCKET_PATH:-}" != "" ]]; then
  SOCK_DIR="$(cd "$(dirname "$CARDANO_NODE_SOCKET_PATH")" && pwd)"
  SOCK_NAME="$(basename "$CARDANO_NODE_SOCKET_PATH")"
  ARGS+=(-v "$SOCK_DIR":/ipc -e "CARDANO_NODE_SOCKET_PATH=/ipc/$SOCK_NAME")
fi

# Run cardano-cli inside the official-ish node container image.
ARGS+=("$IMAGE" cardano-cli)

exec "${ARGS[@]}" "$@"
</file>

<file path="skills/cardano-cli-doctor/SKILL.md">
---
name: cardano-cli-doctor
description: "Diagnose cardano-cli: version, era-prefixed vs legacy syntax, network flags. Produces compatibility report."
allowed-tools:
  - Bash(cardano-cli:*)
  - Bash(which:*)
  - Read
context:
  - "!cardano-cli version 2>&1 | head -10"
  - "!cardano-cli --help 2>&1 | head -40"
  - "!cardano-cli conway --help 2>&1 | head -20"
  - "!cardano-cli latest --help 2>&1 | head -10"
  - "!cardano-cli transaction build --help 2>&1 | head -30"
metadata: {"openclaw":{"emoji":"\ud83e\uddf0","requires":{"anyBins":["cardano-cli","docker"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# cardano-cli-doctor

## When to use
- Before generating CLI workflows to detect correct command style (era-prefixed vs legacy)
- When debugging CLI flag errors or version mismatches
- When setting up a new environment

## Operating rules (must follow)
- Never ask for or log secret key contents
- Prefer **read-only** diagnostics (`--help`, `version`, `query tip`)
- If air-gapped machine, avoid network commands unless explicitly requested
- Output a **Compat Report** with recommended command style

## Docker fallback mode
If `cardano-cli` is not installed locally, use the wrapper script in this skill folder to run **cardano-cli inside Docker** (the Cardano node container images include the CLI).

```bash
chmod +x {baseDir}/scripts/cardano-cli.sh
{baseDir}/scripts/cardano-cli.sh version
```

Notes:
- The wrapper mounts your current directory into the container as `/work` so files like `pparams.json`, `tx.body`, `datum.json` work normally.
- If you have a local node socket, set `CARDANO_NODE_SOCKET_PATH` before running so `query` commands work.
- Override the image with `CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:<tag>`.

## Workflow
1) Collect environment facts (auto-injected via context)
   - CLI version
   - Available era-prefixed commands (conway, latest)
   - Legacy flag presence (--babbage-era, etc.)

2) Decide command style
   - `cardano-cli conway --help` works → **era-prefixed supported**
   - `--babbage-era` in help → **legacy flags supported**
   - Both exist → prefer **era-prefixed** (newer)

3) Network sanity (optional, if socket available)
   - `cardano-cli query tip --mainnet` or `--testnet-magic <N>`
   - Detect: missing socket, wrong magic, sync status

4) Produce Compat Report
   ```
   CLI Version: X.Y.Z
   Era-prefixed: ✓ conway, latest
   Legacy flags: ✓ --babbage-era
   Recommended: era-prefixed (cardano-cli conway ...)
   Network: --testnet-magic 1 (preprod)
   ```

## Examples

### Example 1: Modern CLI (era-prefixed)
**Input:** User has cardano-cli 10.1.0

**Output:**
```
=== Cardano CLI Compatibility Report ===

CLI Version: 10.1.0.0
Git Rev: abc123

Supported Commands:
  ✓ cardano-cli conway --help (recommended)
  ✓ cardano-cli latest --help
  ✓ cardano-cli babbage --help

Recommended Style: ERA-PREFIXED
  cardano-cli conway transaction build ...
  cardano-cli conway query utxo ...

Network Flags:
  Mainnet: --mainnet
  Preprod: --testnet-magic 1
  Preview: --testnet-magic 2
```

### Example 2: Legacy CLI
**Input:** User has cardano-cli 8.x

**Output:**
```
=== Cardano CLI Compatibility Report ===

CLI Version: 8.24.0.0

Supported Commands:
  ✗ Era-prefixed not available

Legacy Flags Detected:
  ✓ --babbage-era
  ✓ --alonzo-era

Recommended Style: LEGACY FLAGS
  cardano-cli transaction build --babbage-era ...
```

## Safety / key handling
- Avoid commands that print or touch `.skey` files
- Recommend `chmod 600 *.skey` for real funds
- Prefer offline keygen for mainnet

## References
- `shared/PRINCIPLES.md` (repo)
- [Cardano CLI documentation](https://github.com/IntersectMBO/cardano-cli)
</file>

<file path="skills/cardano-cli-operator/reference/operator.md">
# Operator notes

This operator uses OpenClaw's **command-dispatch: tool** mode to route the slash command directly to the **Exec Tool** (no model).

Recommended OpenClaw session defaults:
- `/exec host=gateway security=allowlist ask=on-miss`

This helps ensure approval-gated execution (depending on your exec approvals policy) and blocks shell chaining/redirection in allowlist mode.
</file>

<file path="skills/cardano-cli-operator/scripts/cardano-cli.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${CARDANO_DOCKER_IMAGE:-ghcr.io/intersectmbo/cardano-node:latest}"

if command -v cardano-cli >/dev/null 2>&1; then
  exec cardano-cli "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: cardano-cli not found and docker not installed. Install cardano-cli or docker." >&2
  exit 1
fi

ARGS=(docker run --rm -i -v "$PWD":/work -w /work)

if [[ "${CARDANO_NODE_SOCKET_PATH:-}" != "" ]]; then
  SOCK_DIR="$(cd "$(dirname "$CARDANO_NODE_SOCKET_PATH")" && pwd)"
  SOCK_NAME="$(basename "$CARDANO_NODE_SOCKET_PATH")"
  ARGS+=(-v "$SOCK_DIR":/ipc -e "CARDANO_NODE_SOCKET_PATH=/ipc/$SOCK_NAME")
fi

ARGS+=("$IMAGE" cardano-cli)
exec "${ARGS[@]}" "$@"
</file>

<file path="skills/cardano-cli-operator/SKILL.md">
---
name: cardano-cli-operator
description: "Manual-only operator command for Cardano CLI: dispatches directly to OpenClaw Exec Tool (no model) so you can run deterministic, approval-gated cardano-cli commands (native or Docker fallback)."
argument-hint: "<shell command>"
disable-model-invocation: true
command-dispatch: tool
command-tool: exec
command-arg-mode: raw
metadata: {"openclaw":{"emoji":"\u2699\ufe0f","requires":{"anyBins":["cardano-cli","docker"],"bins":["curl"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}],"homepage":"https://docs.openclaw.ai/tools/exec"}}
---

# cardano-cli-operator (manual-only)

This skill is a **deterministic exec gateway**: when you run the slash command, OpenClaw **bypasses the model** and forwards your arguments straight to the **Exec Tool** (`command-dispatch: tool`).

## Safety first: force approvals + allowlist mode
Before using this operator, set Exec defaults for the session:

- `/exec host=gateway security=allowlist ask=on-miss`

## Allowlist-safe shortcut (recommended)
If your Exec allowlist is strict, allowlist **one** entrypoint and route everything through it:

- Allowlist: `~/Projects/**/cardano-agent-skills/scripts/oc-safe.sh` (adjust glob)
- Run:
  - `/cardano_cli_operator ./scripts/oc-safe.sh cardano version`
  - `/cardano_cli_operator ./scripts/oc-safe.sh cardano query tip --mainnet`

## Use it (copy/paste)
Run `cardano-cli` via the included wrapper (native `cardano-cli` if installed, otherwise Docker fallback):

- Version
  - `/cardano_cli_operator ./skills/cardano-cli-operator/scripts/cardano-cli.sh version`

- Query tip (requires socket / correct network)
  - `/cardano_cli_operator ./skills/cardano-cli-operator/scripts/cardano-cli.sh query tip --mainnet`

- Dump protocol params (example)
  - `/cardano_cli_operator ./skills/cardano-cli-operator/scripts/cardano-cli.sh query protocol-parameters --mainnet --out-file pparams.json`

## Socket note (Docker fallback)
If you have a local node socket and you're using Docker fallback, set:
- `CARDANO_NODE_SOCKET_PATH=/path/to/node.socket`

## Notes
- This operator does **not** decide what to run; it runs what you type deterministically.
- Use the non-operator skills for guidance and safe templates.
</file>

<file path="skills/cardano-cli-plutus-scripts/reference/docker-fallback.md">
# Docker fallback (cardano-cli)

This skill includes `scripts/cardano-cli.sh`, which runs `cardano-cli` either:
- directly from your PATH, or
- inside Docker using `ghcr.io/intersectmbo/cardano-node`.

Basic usage:
```bash
chmod +x scripts/cardano-cli.sh
scripts/cardano-cli.sh version
```

If you have a node socket locally:
```bash
export CARDANO_NODE_SOCKET_PATH=/path/to/node.socket
scripts/cardano-cli.sh query tip --mainnet
```

Override container tag:
```bash
CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:10.6.1 scripts/cardano-cli.sh version
```
</file>

<file path="skills/cardano-cli-plutus-scripts/reference/script-spend-template.md">
# Script spend template (CLI)

> Verify flags with your installed `cardano-cli`. Script spend syntax differs slightly between versions.

```bash
export MAGIC=<MAGIC>
export CHANGE_ADDR=$(cat wallets/alice/base.addr)
export SCRIPT_UTXO=<SCRIPT_TXHASH#IX>
export COLLATERAL_UTXO=<COLLATERAL_TXHASH#IX>

cardano-cli query protocol-parameters --testnet-magic $MAGIC --out-file pparams.json

cardano-cli transaction build       --testnet-magic $MAGIC       --tx-in "$SCRIPT_UTXO"       --tx-in-script-file validator.plutus       --tx-in-inline-datum-present       --tx-in-redeemer-file redeemer.json       --tx-in-collateral "$COLLATERAL_UTXO"       --change-address "$CHANGE_ADDR"       --tx-out "<RECIPIENT_ADDR>+<LOVELACE>"       --out-file tx.body

cardano-cli transaction sign       --testnet-magic $MAGIC       --tx-body-file tx.body       --signing-key-file wallets/alice/payment.skey       --out-file tx.signed

cardano-cli transaction submit       --testnet-magic $MAGIC       --tx-file tx.signed
```
</file>

<file path="skills/cardano-cli-plutus-scripts/scripts/cardano-cli.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${CARDANO_DOCKER_IMAGE:-ghcr.io/intersectmbo/cardano-node:latest}"

if command -v cardano-cli >/dev/null 2>&1; then
  exec cardano-cli "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: cardano-cli not found and docker not installed. Install cardano-cli or docker." >&2
  exit 1
fi

# Mount current working directory for inputs/outputs (datum, pparams, tx.body, etc.)
ARGS=(docker run --rm -i -v "$PWD":/work -w /work)

# If a node socket is available, mount it and forward env var.
if [[ "${CARDANO_NODE_SOCKET_PATH:-}" != "" ]]; then
  SOCK_DIR="$(cd "$(dirname "$CARDANO_NODE_SOCKET_PATH")" && pwd)"
  SOCK_NAME="$(basename "$CARDANO_NODE_SOCKET_PATH")"
  ARGS+=(-v "$SOCK_DIR":/ipc -e "CARDANO_NODE_SOCKET_PATH=/ipc/$SOCK_NAME")
fi

# Run cardano-cli inside the official-ish node container image.
ARGS+=("$IMAGE" cardano-cli)

exec "${ARGS[@]}" "$@"
</file>

<file path="skills/cardano-cli-plutus-scripts/SKILL.md">
---
name: cardano-cli-plutus-scripts
description: "Plutus script guidance: datums, redeemers, collateral, reference scripts. Templates only—use operator to execute."
allowed-tools:
  - Read
user-invocable: true
metadata: {"openclaw":{"emoji":"\ud83e\uddf0","requires":{"anyBins":["cardano-cli","docker"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# cardano-cli-plutus-scripts

> **This is a guidance skill.** Provides templates and explanations. For execution, use `cardano-cli-plutus-scripts-operator`.

## When to use
- Learning Plutus script transaction patterns
- Understanding datums, redeemers, collateral
- Getting templates for script interactions

## Operating rules (must follow)
- Confirm network and script version (V2/V3)
- Never execute—only provide templates
- Always include collateral handling
- Use fresh protocol parameters

## Docker fallback mode
If `cardano-cli` is not installed locally, use the wrapper script in this skill folder to run **cardano-cli inside Docker** (the Cardano node container images include the CLI).

```bash
chmod +x {baseDir}/scripts/cardano-cli.sh
{baseDir}/scripts/cardano-cli.sh version
```

Notes:
- The wrapper mounts your current directory into the container as `/work` so files like `pparams.json`, `tx.body`, `datum.json` work normally.
- If you have a local node socket, set `CARDANO_NODE_SOCKET_PATH` before running so `query` commands work.
- Override the image with `CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:<tag>`.

## Key concepts

### Script versions
- **V1** (Alonzo): Legacy, limited features
- **V2** (Babbage): Reference scripts, inline datums
- **V3** (Conway): Governance, simplified interface

### Datum handling
- **Inline datum**: Stored on-chain with UTxO
- **Datum hash**: Only hash on-chain, provide full datum when spending
- **No datum**: For some V3 scripts

### Collateral
- Required for all Plutus script transactions
- Must be ADA-only UTxO
- Forfeit if script fails unexpectedly
- Typically 1-5 ADA sufficient

## Workflow templates

### Lock funds at script address
```bash
# 1. Derive script address
cardano-cli conway address build \
  --payment-script-file script.plutus \
  --testnet-magic 1 \
  --out-file script.addr

# 2. Create datum file
echo '{"constructor": 0, "fields": []}' > datum.json

# 3. Lock with inline datum
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --tx-out "$(cat script.addr)+5000000" \
  --tx-out-inline-datum-file datum.json \
  --change-address <payment-addr> \
  --out-file tx.unsigned

# Sign and submit
```

### Spend from script
```bash
# 1. Create redeemer
echo '{"constructor": 0, "fields": []}' > redeemer.json

# 2. Build script spend
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <script-utxo>#<index> \
  --tx-in-script-file script.plutus \
  --tx-in-inline-datum-present \
  --tx-in-redeemer-file redeemer.json \
  --tx-in-collateral <collateral-utxo>#<index> \
  --tx-out <recipient>+<amount> \
  --change-address <payment-addr> \
  --out-file tx.unsigned

# Sign (with collateral key) and submit
```

### With reference script
```bash
# Script already on-chain at reference UTxO
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <script-utxo>#<index> \
  --spending-tx-in-reference <ref-script-utxo>#<index> \
  --spending-plutus-script-v2 \
  --spending-reference-tx-in-inline-datum-present \
  --spending-reference-tx-in-redeemer-file redeemer.json \
  --tx-in-collateral <collateral>#<index> \
  --tx-out <recipient>+<amount> \
  --change-address <payment-addr> \
  --out-file tx.unsigned
```

## Examples

### Example: Simple validator spend
**User request:** "Spend from my always-succeeds script"

**Response:**
```bash
# === Spend from Always-Succeeds Script ===

SCRIPT_ADDR=$(cat script.addr)
PAYMENT_ADDR=$(cat base.addr)

# 1. Query script UTxO
cardano-cli conway query utxo \
  --address $SCRIPT_ADDR \
  --testnet-magic 1
# Note the UTxO hash and index

# 2. Query payment UTxOs (for collateral)
cardano-cli conway query utxo \
  --address $PAYMENT_ADDR \
  --testnet-magic 1
# Select ADA-only UTxO for collateral

# 3. Create redeemer (for always-succeeds, can be unit)
echo '{"constructor": 0, "fields": []}' > redeemer.json

# 4. Build transaction
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <script-utxo>#0 \
  --tx-in-script-file always-succeeds.plutus \
  --tx-in-inline-datum-present \
  --tx-in-redeemer-file redeemer.json \
  --tx-in-collateral <collateral-utxo>#0 \
  --tx-out "$PAYMENT_ADDR+4500000" \
  --change-address $PAYMENT_ADDR \
  --out-file tx.unsigned

# 5. Sign and submit (use operator skill)
```

## Debugging

### Calculate execution costs
```bash
cardano-cli conway transaction build \
  ... \
  --calculate-plutus-script-cost costs.json

cat costs.json | jq .
```

### Common failures
- **ExUnitsTooBig**: Script exceeds execution budget
- **CollateralNotFound**: Missing or invalid collateral
- **DatumMismatch**: Provided datum doesn't match hash
- **ScriptFailure**: Validator returned False

## Safety / key handling
- Test scripts on preprod/preview first
- Use minimal collateral
- Datum/redeemer are public—no secrets
- Verify script hash after rebuilds

## References
- `shared/PRINCIPLES.md`
- `cardano-cli-plutus-scripts-operator` (for execution)
- `aiken-smart-contracts` (for writing validators)
</file>

<file path="skills/cardano-cli-plutus-scripts-operator/SKILL.md">
---
name: cardano-cli-plutus-scripts-operator
description: "Execute Plutus script transactions: script spends, datum/redeemer submission. Manual invoke only."
allowed-tools:
  - Bash(cardano-cli:*)
  - Bash(cat:*)
  - Bash(jq:*)
  - Read
  - Write
disable-model-invocation: true
user-invocable: true
context:
  - "!cardano-cli version 2>&1 | head -5"
---

# cardano-cli-plutus-scripts-operator

> **OPERATOR SKILL**: Executes Plutus script transactions. Requires explicit human invocation due to collateral risk.

## When to use
- When ready to spend from a script address
- After reviewing guidance from `cardano-cli-plutus-scripts`

## Operating rules (must follow)
- **ALWAYS verify collateral UTxO is ADA-only**
- Confirm script hash matches expected
- Validate datum/redeemer JSON before use
- **REQUIRE explicit confirmation before submit**
- Test on preprod/preview before mainnet

## Pre-flight checklist
```
[ ] Network: ___________
[ ] Script file (.plutus) verified
[ ] Script hash matches on-chain
[ ] Datum JSON validated
[ ] Redeemer JSON validated
[ ] Collateral UTxO selected (ADA-only!)
[ ] Protocol parameters fresh
```

## Execution workflow

### Step 1: Verify script
```bash
# Get script hash
cardano-cli conway transaction policyid \
  --script-file script.plutus

# Derive script address
cardano-cli conway address build \
  --payment-script-file script.plutus \
  --testnet-magic 1 \
  --out-file script.addr
```

### Step 2: Query script UTxO
```bash
cardano-cli conway query utxo \
  --address $(cat script.addr) \
  --testnet-magic 1
```

### Step 3: Prepare collateral
```bash
# Must be ADA-only UTxO at your payment address
cardano-cli conway query utxo \
  --address <payment-addr> \
  --testnet-magic 1

# Select one with only ADA (no tokens)
```

### Step 4: Build script spend
```bash
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <script-utxo>#<index> \
  --tx-in-script-file script.plutus \
  --tx-in-inline-datum-present \
  --tx-in-redeemer-file redeemer.json \
  --tx-in-collateral <collateral-utxo>#<index> \
  --tx-out <recipient>+<amount> \
  --change-address <payment-addr> \
  --out-file tx.unsigned
```

### Step 5: Sign and submit
```bash
# Sign (collateral signer required)
cardano-cli conway transaction sign \
  --tx-file tx.unsigned \
  --signing-key-file payment.skey \
  --testnet-magic 1 \
  --out-file tx.signed

# ⚠️ CONFIRM before submit
echo "=== SCRIPT SPEND CONFIRMATION ==="
echo "Script: $(cat script.addr | head -c 20)..."
echo "Spending UTxO: <script-utxo>"
echo "Collateral: <collateral-utxo>"
echo "Output to: <recipient>"

cardano-cli conway transaction submit \
  --testnet-magic 1 \
  --tx-file tx.signed
```

## Debugging failed scripts
```bash
# If script fails, check execution units
cardano-cli conway transaction build \
  ... \
  --calculate-plutus-script-cost cost.json

# Review cost.json for budget issues
cat cost.json | jq .
```

## Safety / key handling
- Collateral is at risk if script fails unexpectedly
- Use minimal collateral (1-5 ADA typically sufficient)
- Keep datum/redeemer free of secrets
- Verify script logic on testnet first

## References
- `cardano-cli-plutus-scripts` (guidance skill)
- `shared/PRINCIPLES.md`
</file>

<file path="skills/cardano-cli-staking/reference/docker-fallback.md">
# Docker fallback (cardano-cli)

This skill includes `scripts/cardano-cli.sh`, which runs `cardano-cli` either:
- directly from your PATH, or
- inside Docker using `ghcr.io/intersectmbo/cardano-node`.

Basic usage:
```bash
chmod +x scripts/cardano-cli.sh
scripts/cardano-cli.sh version
```

If you have a node socket locally:
```bash
export CARDANO_NODE_SOCKET_PATH=/path/to/node.socket
scripts/cardano-cli.sh query tip --mainnet
```

Override container tag:
```bash
CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:10.6.1 scripts/cardano-cli.sh version
```
</file>

<file path="skills/cardano-cli-staking/reference/staking.md">
# Staking templates (high level)

## Build stake address
```bash
cardano-cli stake-address build       --stake-verification-key-file stake.vkey       --out-file stake.addr       --testnet-magic <MAGIC>
```

## Query stake address info
```bash
cardano-cli query stake-address-info       --address $(cat stake.addr)       --testnet-magic <MAGIC>
```

## Create certificates
```bash
# Register
cardano-cli stake-address registration-certificate       --stake-verification-key-file stake.vkey       --out-file stake.reg.cert

# Delegate
cardano-cli stake-address delegation-certificate       --stake-verification-key-file stake.vkey       --stake-pool-id <POOL_ID>       --out-file stake.deleg.cert
```

> Transactions that include certificates are built/signed/submitted like standard txs, but add `--certificate-file ...`.
</file>

<file path="skills/cardano-cli-staking/scripts/cardano-cli.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${CARDANO_DOCKER_IMAGE:-ghcr.io/intersectmbo/cardano-node:latest}"

if command -v cardano-cli >/dev/null 2>&1; then
  exec cardano-cli "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: cardano-cli not found and docker not installed. Install cardano-cli or docker." >&2
  exit 1
fi

# Mount current working directory for inputs/outputs (datum, pparams, tx.body, etc.)
ARGS=(docker run --rm -i -v "$PWD":/work -w /work)

# If a node socket is available, mount it and forward env var.
if [[ "${CARDANO_NODE_SOCKET_PATH:-}" != "" ]]; then
  SOCK_DIR="$(cd "$(dirname "$CARDANO_NODE_SOCKET_PATH")" && pwd)"
  SOCK_NAME="$(basename "$CARDANO_NODE_SOCKET_PATH")"
  ARGS+=(-v "$SOCK_DIR":/ipc -e "CARDANO_NODE_SOCKET_PATH=/ipc/$SOCK_NAME")
fi

# Run cardano-cli inside the official-ish node container image.
ARGS+=("$IMAGE" cardano-cli)

exec "${ARGS[@]}" "$@"
</file>

<file path="skills/cardano-cli-staking/SKILL.md">
---
name: cardano-cli-staking
description: "Staking guidance: registration, delegation, rewards. Provides templates (no execution). Use operator skill to execute."
allowed-tools:
  - Read
user-invocable: true
metadata: {"openclaw":{"emoji":"\ud83e\uddf0","requires":{"anyBins":["cardano-cli","docker"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# cardano-cli-staking

> **This is a guidance skill.** Provides templates and explanations. For execution, use `cardano-cli-staking-operator`.

## When to use
- Learning stake key registration and delegation
- Understanding rewards withdrawal
- Getting command templates for staking operations

## Operating rules (must follow)
- Confirm network before providing commands
- Never execute—only provide templates
- Include deposit/fee information
- Verify pool ID from multiple sources

## Docker fallback mode
If `cardano-cli` is not installed locally, use the wrapper script in this skill folder to run **cardano-cli inside Docker** (the Cardano node container images include the CLI).

```bash
chmod +x {baseDir}/scripts/cardano-cli.sh
{baseDir}/scripts/cardano-cli.sh version
```

Notes:
- The wrapper mounts your current directory into the container as `/work` so files like `pparams.json`, `tx.body`, `datum.json` work normally.
- If you have a local node socket, set `CARDANO_NODE_SOCKET_PATH` before running so `query` commands work.
- Override the image with `CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:<tag>`.

## Key concepts

### Stake addresses vs payment addresses
- **Payment address**: Holds funds, used for spending
- **Stake address**: Controls delegation, receives rewards
- **Base address**: Combines both (most common)

### Deposits
- Stake key registration: ~2 ADA deposit (refundable)
- Pool registration: ~500 ADA deposit (refundable)

## Workflow templates

### Check stake status
```bash
# Derive stake address
cardano-cli conway stake-address build \
  --stake-verification-key-file stake.vkey \
  --testnet-magic 1 \
  --out-file stake.addr

# Query status
cardano-cli conway query stake-address-info \
  --testnet-magic 1 \
  --address $(cat stake.addr)
```

### Register stake key
```bash
# 1. Create registration certificate
cardano-cli conway stake-address registration-certificate \
  --stake-verification-key-file stake.vkey \
  --out-file stake-reg.cert

# 2. Build transaction with certificate
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --change-address <payment-addr> \
  --certificate-file stake-reg.cert \
  --out-file tx.unsigned

# 3. Sign with BOTH keys
cardano-cli conway transaction sign \
  --tx-file tx.unsigned \
  --signing-key-file payment.skey \
  --signing-key-file stake.skey \
  --testnet-magic 1 \
  --out-file tx.signed

# 4. Submit
cardano-cli conway transaction submit \
  --testnet-magic 1 \
  --tx-file tx.signed
```

### Delegate to pool
```bash
# 1. Create delegation certificate
cardano-cli conway stake-address stake-delegation-certificate \
  --stake-verification-key-file stake.vkey \
  --stake-pool-id pool1... \
  --out-file delegation.cert

# 2. Build, sign (both keys), submit
# Same pattern as registration
```

### Withdraw rewards
```bash
# 1. Check rewards balance
cardano-cli conway query stake-address-info \
  --testnet-magic 1 \
  --address $(cat stake.addr)

# 2. Build withdrawal tx
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --withdrawal $(cat stake.addr)+<reward-lovelace> \
  --change-address <payment-addr> \
  --out-file tx.unsigned

# 3. Sign with BOTH keys, submit
```

### De-register stake key (get deposit back)
```bash
cardano-cli conway stake-address deregistration-certificate \
  --stake-verification-key-file stake.vkey \
  --out-file stake-dereg.cert

# Build tx with certificate, sign, submit
```

## Examples

### Example: Delegate to a pool
**User request:** "Delegate my stake to pool1abc..."

**Response:**
```bash
# === Delegate to Pool ===

POOL_ID="pool1abc..."
STAKE_VKEY="stake.vkey"
PAYMENT_ADDR=$(cat base.addr)

# 1. Verify pool exists
cardano-cli conway query stake-pools --testnet-magic 1 | grep $POOL_ID

# 2. Create delegation certificate
cardano-cli conway stake-address stake-delegation-certificate \
  --stake-verification-key-file $STAKE_VKEY \
  --stake-pool-id $POOL_ID \
  --out-file delegation.cert

# 3. Build transaction
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <your-utxo>#0 \
  --change-address $PAYMENT_ADDR \
  --certificate-file delegation.cert \
  --out-file tx.unsigned

# 4. Sign with both keys
cardano-cli conway transaction sign \
  --tx-file tx.unsigned \
  --signing-key-file payment.skey \
  --signing-key-file stake.skey \
  --testnet-magic 1 \
  --out-file tx.signed

# 5. Submit (use operator skill)
# Delegation takes effect at next epoch boundary
```

## Safety / key handling
- Verify pool ID from multiple sources (adapools, cexplorer)
- Staking never risks your principal
- Delegation can be changed anytime
- Rewards accumulate until withdrawn

## References
- `shared/PRINCIPLES.md`
- `cardano-cli-staking-operator` (for execution)
</file>

<file path="skills/cardano-cli-staking-operator/SKILL.md">
---
name: cardano-cli-staking-operator
description: "Execute staking operations: registration, delegation, rewards withdrawal. Manual invoke only."
allowed-tools:
  - Bash(cardano-cli:*)
  - Bash(cat:*)
  - Read
  - Write
disable-model-invocation: true
user-invocable: true
context:
  - "!cardano-cli version 2>&1 | head -5"
---

# cardano-cli-staking-operator

> **OPERATOR SKILL**: Executes staking operations that modify on-chain state. Requires explicit human invocation.

## When to use
- When ready to register stake key, delegate, or withdraw rewards
- After reviewing guidance from `cardano-cli-staking`

## Operating rules (must follow)
- Confirm network and pool ID before delegation
- Verify stake key registration status before operations
- **REQUIRE explicit confirmation before any certificate submission**
- Show deposit/fee costs before proceeding

## Pre-flight checklist
```
[ ] Network: ___________
[ ] Stake key files exist and are correct
[ ] Payment key for fees available
[ ] Pool ID verified (for delegation)
[ ] Current rewards balance checked
```

## Execution workflow

### Check stake status first
```bash
cardano-cli conway query stake-address-info \
  --testnet-magic 1 \
  --address $(cat stake.addr)
```

### Register stake key (if not registered)
```bash
# Create registration certificate
cardano-cli conway stake-address registration-certificate \
  --stake-verification-key-file stake.vkey \
  --out-file stake-reg.cert

# Build tx with certificate
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --change-address <payment-addr> \
  --certificate-file stake-reg.cert \
  --out-file tx.unsigned

# Sign with BOTH payment and stake keys
cardano-cli conway transaction sign \
  --tx-file tx.unsigned \
  --signing-key-file payment.skey \
  --signing-key-file stake.skey \
  --testnet-magic 1 \
  --out-file tx.signed

# Submit (CONFIRM FIRST)
cardano-cli conway transaction submit \
  --testnet-magic 1 \
  --tx-file tx.signed
```

### Delegate to pool
```bash
# Create delegation certificate
cardano-cli conway stake-address stake-delegation-certificate \
  --stake-verification-key-file stake.vkey \
  --stake-pool-id <pool-id-bech32> \
  --out-file delegation.cert

# Build, sign (payment + stake), submit
# ... same pattern as registration
```

### Withdraw rewards
```bash
# Check rewards balance first
cardano-cli conway query stake-address-info \
  --testnet-magic 1 \
  --address $(cat stake.addr)

# Build withdrawal tx
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --withdrawal $(cat stake.addr)+<reward-amount> \
  --change-address <payment-addr> \
  --out-file tx.unsigned

# Sign with BOTH keys and submit
```

## Safety / key handling
- Verify pool ID from multiple sources before delegating
- Double-check reward withdrawal amounts
- Keep certificates for records
- Registration deposit is refundable on de-registration

## References
- `cardano-cli-staking` (guidance skill)
- `shared/PRINCIPLES.md`
</file>

<file path="skills/cardano-cli-transactions/reference/docker-fallback.md">
# Docker fallback (cardano-cli)

This skill includes `scripts/cardano-cli.sh`, which runs `cardano-cli` either:
- directly from your PATH, or
- inside Docker using `ghcr.io/intersectmbo/cardano-node`.

Basic usage:
```bash
chmod +x scripts/cardano-cli.sh
scripts/cardano-cli.sh version
```

If you have a node socket locally:
```bash
export CARDANO_NODE_SOCKET_PATH=/path/to/node.socket
scripts/cardano-cli.sh query tip --mainnet
```

Override container tag:
```bash
CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:10.6.1 scripts/cardano-cli.sh version
```
</file>

<file path="skills/cardano-cli-transactions/reference/tx-send-ada.md">
# Send ADA (standard tx) — template

> This is a template. Verify syntax with your installed `cardano-cli`.

## Online build flow (`transaction build`)
```bash
export MAGIC=<MAGIC>
export FROM_ADDR=$(cat wallets/alice/base.addr)
export TO_ADDR=<RECIPIENT_ADDR>
export AMOUNT=2000000   # 2 ADA in lovelace

cardano-cli query utxo --address "$FROM_ADDR" --testnet-magic $MAGIC

cardano-cli query protocol-parameters --testnet-magic $MAGIC --out-file pparams.json

cardano-cli transaction build       --testnet-magic $MAGIC       --change-address "$FROM_ADDR"       --tx-in <TXHASH#IX>       --tx-out "$TO_ADDR+$AMOUNT"       --out-file tx.body

cardano-cli transaction sign       --testnet-magic $MAGIC       --tx-body-file tx.body       --signing-key-file wallets/alice/payment.skey       --out-file tx.signed

cardano-cli transaction submit       --testnet-magic $MAGIC       --tx-file tx.signed
```
</file>

<file path="skills/cardano-cli-transactions/scripts/cardano-cli.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${CARDANO_DOCKER_IMAGE:-ghcr.io/intersectmbo/cardano-node:latest}"

if command -v cardano-cli >/dev/null 2>&1; then
  exec cardano-cli "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: cardano-cli not found and docker not installed. Install cardano-cli or docker." >&2
  exit 1
fi

# Mount current working directory for inputs/outputs (datum, pparams, tx.body, etc.)
ARGS=(docker run --rm -i -v "$PWD":/work -w /work)

# If a node socket is available, mount it and forward env var.
if [[ "${CARDANO_NODE_SOCKET_PATH:-}" != "" ]]; then
  SOCK_DIR="$(cd "$(dirname "$CARDANO_NODE_SOCKET_PATH")" && pwd)"
  SOCK_NAME="$(basename "$CARDANO_NODE_SOCKET_PATH")"
  ARGS+=(-v "$SOCK_DIR":/ipc -e "CARDANO_NODE_SOCKET_PATH=/ipc/$SOCK_NAME")
fi

# Run cardano-cli inside the official-ish node container image.
ARGS+=("$IMAGE" cardano-cli)

exec "${ARGS[@]}" "$@"
</file>

<file path="skills/cardano-cli-transactions/SKILL.md">
---
name: cardano-cli-transactions
description: "Transaction guidance: build, sign, submit patterns. Provides templates (no execution). Use operator skill to execute."
allowed-tools:
  - Read
user-invocable: true
context:
  - "!cardano-cli version 2>&1 | head -5"
metadata: {"openclaw":{"emoji":"\ud83e\uddf0","requires":{"anyBins":["cardano-cli","docker"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# cardano-cli-transactions

> **This is a guidance skill.** Provides templates and explanations. For execution, use `cardano-cli-transactions-operator`.

## When to use
- Learning transaction building patterns
- Understanding UTxO selection and change
- Getting command templates for various tx types

## Operating rules (must follow)
- Confirm network (mainnet/preprod/preview) before providing commands
- Never execute—only provide templates
- Always include fee handling and change
- Include verification steps

## Docker fallback mode
If `cardano-cli` is not installed locally, use the wrapper script in this skill folder to run **cardano-cli inside Docker** (the Cardano node container images include the CLI).

```bash
chmod +x {baseDir}/scripts/cardano-cli.sh
{baseDir}/scripts/cardano-cli.sh version
```

Notes:
- The wrapper mounts your current directory into the container as `/work` so files like `pparams.json`, `tx.body`, `datum.json` work normally.
- If you have a local node socket, set `CARDANO_NODE_SOCKET_PATH` before running so `query` commands work.
- Override the image with `CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:<tag>`.

## Workflow templates

### Simple ADA transfer
```bash
# 1. Query sender UTxOs
cardano-cli conway query utxo \
  --address <sender-addr> \
  --testnet-magic 1

# 2. Get protocol parameters
cardano-cli conway query protocol-parameters \
  --testnet-magic 1 \
  --out-file pparams.json

# 3. Build transaction
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo-hash>#<index> \
  --tx-out <recipient>+<amount-lovelace> \
  --change-address <sender-addr> \
  --out-file tx.unsigned

# 4. Sign
cardano-cli conway transaction sign \
  --tx-file tx.unsigned \
  --signing-key-file payment.skey \
  --testnet-magic 1 \
  --out-file tx.signed

# 5. Submit
cardano-cli conway transaction submit \
  --testnet-magic 1 \
  --tx-file tx.signed

# 6. Verify
cardano-cli conway transaction txid --tx-file tx.signed
```

### Multi-output transaction
```bash
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --tx-out <addr1>+<amount1> \
  --tx-out <addr2>+<amount2> \
  --tx-out <addr3>+<amount3> \
  --change-address <sender> \
  --out-file tx.unsigned
```

### With native tokens
```bash
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --tx-out "<recipient>+<lovelace>+<amount> <policy-id>.<asset-name>" \
  --change-address <sender> \
  --out-file tx.unsigned
```

### With metadata
```bash
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --tx-out <recipient>+<amount> \
  --change-address <sender> \
  --metadata-json-file metadata.json \
  --out-file tx.unsigned
```

## Examples

### Example: Send 10 ADA on preprod
**User request:** "Send 10 ADA to addr_test1qz..."

**Response:**
```bash
# === Send 10 ADA on Preprod ===

# Setup
SENDER_ADDR="addr_test1..."
RECIPIENT="addr_test1qz..."
AMOUNT=10000000  # 10 ADA in lovelace

# 1. Query UTxOs
cardano-cli conway query utxo \
  --address $SENDER_ADDR \
  --testnet-magic 1

# 2. Build (using first UTxO with sufficient funds)
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <paste-utxo-here>#0 \
  --tx-out "$RECIPIENT+$AMOUNT" \
  --change-address $SENDER_ADDR \
  --out-file tx.unsigned

# 3. Sign
cardano-cli conway transaction sign \
  --tx-file tx.unsigned \
  --signing-key-file payment.skey \
  --testnet-magic 1 \
  --out-file tx.signed

# 4. Submit (use operator skill or run manually)
# cardano-cli conway transaction submit --testnet-magic 1 --tx-file tx.signed
```

## Tx bundle folder structure
```
tx-20240115-143022/
├── pparams.json       # Protocol parameters used
├── tx.unsigned        # Unsigned transaction
├── tx.signed          # Signed transaction
├── utxos.json         # Input UTxOs at build time
└── commands.log       # Commands executed
```

## Safety / key handling
- Never expose signing keys
- Verify recipient address carefully
- On mainnet: small test transfer first
- Keep tx bundle for audit trail

## References
- `shared/PRINCIPLES.md`
- `cardano-cli-transactions-operator` (for execution)
</file>

<file path="skills/cardano-cli-transactions-operator/SKILL.md">
---
name: cardano-cli-transactions-operator
description: "Execute transaction builds and submits. Manual invoke only—requires explicit confirmation before submit."
allowed-tools:
  - Bash(cardano-cli:*)
  - Bash(mkdir:*)
  - Bash(cat:*)
  - Read
  - Write
disable-model-invocation: true
user-invocable: true
context:
  - "!cardano-cli version 2>&1 | head -5"
  - "!cardano-cli conway --help 2>&1 | head -10"
---

# cardano-cli-transactions-operator

> **OPERATOR SKILL**: This skill executes commands including transaction submission. Requires explicit human invocation.

## When to use
- When ready to build and submit a transaction
- After reviewing guidance from `cardano-cli-transactions`

## Operating rules (must follow)
- Confirm network before ANY operation
- Show full transaction details before signing
- **REQUIRE explicit "yes" confirmation before submit**
- Create tx bundle folder for reproducibility
- Verify UTxO changes after submit

## Pre-flight checklist
```
[ ] Network confirmed: ___________
[ ] Sender address verified
[ ] Recipient address verified (check first/last 8 chars)
[ ] Amount confirmed: ___________ lovelace
[ ] Signing key path confirmed
[ ] UTxO inputs selected
```

## Execution workflow

### Step 1: Setup tx bundle
```bash
TX_DIR="tx-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$TX_DIR" && cd "$TX_DIR"
```

### Step 2: Query UTxOs
```bash
cardano-cli conway query utxo \
  --address <sender-addr> \
  --testnet-magic 1 \
  --out-file utxos.json
```

### Step 3: Fetch protocol parameters
```bash
cardano-cli conway query protocol-parameters \
  --testnet-magic 1 \
  --out-file pparams.json
```

### Step 4: Build transaction
```bash
cardano-cli conway transaction build \
  --testnet-magic 1 \
  --tx-in <utxo>#<index> \
  --tx-out <recipient>+<amount> \
  --change-address <sender> \
  --out-file tx.unsigned
```

### Step 5: Sign (show what's being signed)
```bash
echo "=== SIGNING TRANSACTION ==="
echo "Inputs: <utxo>"
echo "Output: <recipient> receives <amount> lovelace"
echo "Change: returns to <sender>"

cardano-cli conway transaction sign \
  --tx-file tx.unsigned \
  --signing-key-file <payment.skey> \
  --testnet-magic 1 \
  --out-file tx.signed
```

### Step 6: Submit (REQUIRES CONFIRMATION)
```
⚠️  CONFIRM SUBMISSION ⚠️
Network: preprod
Sending: X ADA to addr_test1...
From: addr_test1...

Type 'yes' to submit:
```

```bash
cardano-cli conway transaction submit \
  --testnet-magic 1 \
  --tx-file tx.signed
```

### Step 7: Verify
```bash
# Get tx hash
cardano-cli conway transaction txid --tx-file tx.signed

# Query recipient UTxO
cardano-cli conway query utxo \
  --address <recipient> \
  --testnet-magic 1
```

## Safety / key handling
- Never submit without explicit user confirmation
- For mainnet: require double confirmation
- Keep tx bundle for audit trail
- Recommend small test tx first on mainnet

## References
- `cardano-cli-transactions` (guidance skill)
- `shared/PRINCIPLES.md`
</file>

<file path="skills/cardano-cli-wallets/reference/docker-fallback.md">
# Docker fallback (cardano-cli)

This skill includes `scripts/cardano-cli.sh`, which runs `cardano-cli` either:
- directly from your PATH, or
- inside Docker using `ghcr.io/intersectmbo/cardano-node`.

Basic usage:
```bash
chmod +x scripts/cardano-cli.sh
scripts/cardano-cli.sh version
```

If you have a node socket locally:
```bash
export CARDANO_NODE_SOCKET_PATH=/path/to/node.socket
scripts/cardano-cli.sh query tip --mainnet
```

Override container tag:
```bash
CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:10.6.1 scripts/cardano-cli.sh version
```
</file>

<file path="skills/cardano-cli-wallets/reference/wallets.md">
# Wallet creation + common commands (templates)

## Network flags
- Mainnet: `--mainnet`
- Testnet: `--testnet-magic <MAGIC>`

## Key generation (examples)
```bash
mkdir -p wallets/alice && cd wallets/alice

# Payment keys
cardano-cli address key-gen       --verification-key-file payment.vkey       --signing-key-file payment.skey

# Stake keys
cardano-cli stake-address key-gen       --verification-key-file stake.vkey       --signing-key-file stake.skey

# Base address (payment + stake)
cardano-cli address build       --payment-verification-key-file payment.vkey       --stake-verification-key-file stake.vkey       --out-file base.addr       --testnet-magic <MAGIC>

# Enterprise address (payment only)
cardano-cli address build       --payment-verification-key-file payment.vkey       --out-file enterprise.addr       --testnet-magic <MAGIC>
```

## Query UTxOs
```bash
cardano-cli query utxo       --address $(cat base.addr)       --testnet-magic <MAGIC>
```
</file>

<file path="skills/cardano-cli-wallets/scripts/cardano-cli.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${CARDANO_DOCKER_IMAGE:-ghcr.io/intersectmbo/cardano-node:latest}"

if command -v cardano-cli >/dev/null 2>&1; then
  exec cardano-cli "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: cardano-cli not found and docker not installed. Install cardano-cli or docker." >&2
  exit 1
fi

# Mount current working directory for inputs/outputs (datum, pparams, tx.body, etc.)
ARGS=(docker run --rm -i -v "$PWD":/work -w /work)

# If a node socket is available, mount it and forward env var.
if [[ "${CARDANO_NODE_SOCKET_PATH:-}" != "" ]]; then
  SOCK_DIR="$(cd "$(dirname "$CARDANO_NODE_SOCKET_PATH")" && pwd)"
  SOCK_NAME="$(basename "$CARDANO_NODE_SOCKET_PATH")"
  ARGS+=(-v "$SOCK_DIR":/ipc -e "CARDANO_NODE_SOCKET_PATH=/ipc/$SOCK_NAME")
fi

# Run cardano-cli inside the official-ish node container image.
ARGS+=("$IMAGE" cardano-cli)

exec "${ARGS[@]}" "$@"
</file>

<file path="skills/cardano-cli-wallets/SKILL.md">
---
name: cardano-cli-wallets
description: "Wallet guidance: key generation, address building, UTxO queries. Provides templates and explanations (no execution)."
allowed-tools:
  - Read
user-invocable: true
metadata: {"openclaw":{"emoji":"\ud83e\uddf0","requires":{"anyBins":["cardano-cli","docker"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# cardano-cli-wallets

> **This is a guidance skill.** It provides templates and explanations but does not execute commands. For execution, use `cardano-cli-wallets-operator`.

## When to use
- Learning how to create payment/stake keys and addresses
- Understanding wallet structure and UTxO model
- Getting copy-paste command templates

## Operating rules (must follow)
- Confirm network (mainnet vs preprod/preview) before providing commands
- Never execute commands—only provide templates
- Include verification steps in every template
- Keep secrets out of examples

## Docker fallback mode
If `cardano-cli` is not installed locally, use the wrapper script in this skill folder to run **cardano-cli inside Docker** (the Cardano node container images include the CLI).

```bash
chmod +x {baseDir}/scripts/cardano-cli.sh
{baseDir}/scripts/cardano-cli.sh version
```

Notes:
- The wrapper mounts your current directory into the container as `/work` so files like `pparams.json`, `tx.body`, `datum.json` work normally.
- If you have a local node socket, set `CARDANO_NODE_SOCKET_PATH` before running so `query` commands work.
- Override the image with `CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:<tag>`.

## Workflow
1) Identify network
   - Ask for **mainnet** or **preprod/preview** and magic number
   - Determine CLI style (era-prefixed vs legacy) via doctor

2) Provide key generation template
   ```bash
   # Create wallet directory
   mkdir -p wallet && cd wallet

   # Generate payment keys
   cardano-cli conway address key-gen \
     --verification-key-file payment.vkey \
     --signing-key-file payment.skey

   # Generate stake keys
   cardano-cli conway stake-address key-gen \
     --verification-key-file stake.vkey \
     --signing-key-file stake.skey

   # Secure keys
   chmod 600 *.skey
   ```

3) Provide address building template
   ```bash
   # Build base address (payment + stake)
   cardano-cli conway address build \
     --payment-verification-key-file payment.vkey \
     --stake-verification-key-file stake.vkey \
     --out-file base.addr \
     --testnet-magic 1  # or --mainnet

   # Build enterprise address (payment only)
   cardano-cli conway address build \
     --payment-verification-key-file payment.vkey \
     --out-file enterprise.addr \
     --testnet-magic 1
   ```

4) Provide UTxO query template
   ```bash
   cardano-cli conway query utxo \
     --address $(cat base.addr) \
     --testnet-magic 1
   ```

5) Wallet dossier output format
   ```
   === Wallet Dossier ===
   Network: preprod (magic 1)
   Base Address: addr_test1...
   Enterprise Address: addr_test1...
   Payment VKey Hash: abc123...
   Stake VKey Hash: def456...
   Files: payment.vkey, payment.skey, stake.vkey, stake.skey
   ```

## Examples

### Example: Create preprod wallet
**User request:** "Create a wallet for preprod testing"

**Response:**
```bash
# === Preprod Wallet Setup ===

# 1. Create directory
mkdir -p ~/cardano/preprod-wallet && cd ~/cardano/preprod-wallet

# 2. Generate payment keypair
cardano-cli conway address key-gen \
  --verification-key-file payment.vkey \
  --signing-key-file payment.skey

# 3. Generate stake keypair
cardano-cli conway stake-address key-gen \
  --verification-key-file stake.vkey \
  --signing-key-file stake.skey

# 4. Build base address
cardano-cli conway address build \
  --payment-verification-key-file payment.vkey \
  --stake-verification-key-file stake.vkey \
  --out-file base.addr \
  --testnet-magic 1

# 5. Secure keys
chmod 600 *.skey

# 6. Display address for funding
echo "Fund this address from faucet:"
cat base.addr

# 7. Verify (after funding)
cardano-cli conway query utxo \
  --address $(cat base.addr) \
  --testnet-magic 1
```

## Safety / key handling
- Never paste `.skey` contents into chat
- Prefer offline key generation for real funds
- Lock permissions: `chmod 600 *.skey`
- Avoid cloud sync for key directories

## References
- `shared/PRINCIPLES.md` (repo)
- [Cardano Docs: Keys and Addresses](https://docs.cardano.org)
</file>

<file path="skills/cardano-cli-wallets-operator/SKILL.md">
---
name: cardano-cli-wallets-operator
description: "Execute wallet operations: key generation, address building. Manual invoke only for safety."
allowed-tools:
  - Bash(cardano-cli:*)
  - Bash(mkdir:*)
  - Bash(chmod:*)
  - Bash(cat:*)
  - Read
  - Write
disable-model-invocation: true
user-invocable: true
---

# cardano-cli-wallets-operator

> **OPERATOR SKILL**: This skill executes commands. It requires explicit human invocation and cannot be auto-triggered by the model.

## When to use
- When you need to actually execute wallet creation commands
- After reviewing the guidance from `cardano-cli-wallets`

## Operating rules (must follow)
- Confirm network (mainnet/preprod/preview) before ANY execution
- Always create a dedicated directory for wallet files
- Set `chmod 600 *.skey` immediately after key generation
- Show the user what will be executed before running
- Verify each step succeeded before continuing

## Execution workflow

### Step 1: Confirm parameters
```
Network: [mainnet/preprod/preview]
Magic: [1 for preprod, 2 for preview, none for mainnet]
Wallet directory: [path]
```

### Step 2: Create directory
```bash
mkdir -p <wallet-dir> && cd <wallet-dir>
```

### Step 3: Generate keys (with confirmation)
```bash
# Payment keys
cardano-cli conway address key-gen \
  --verification-key-file payment.vkey \
  --signing-key-file payment.skey

# Stake keys
cardano-cli conway stake-address key-gen \
  --verification-key-file stake.vkey \
  --signing-key-file stake.skey

# Secure immediately
chmod 600 *.skey
```

### Step 4: Build addresses
```bash
# Base address
cardano-cli conway address build \
  --payment-verification-key-file payment.vkey \
  --stake-verification-key-file stake.vkey \
  --out-file base.addr \
  --testnet-magic 1  # adjust per network
```

### Step 5: Verify and report
```bash
echo "=== Wallet Created ==="
echo "Base Address: $(cat base.addr)"
ls -la *.vkey *.skey *.addr
```

## Safety / key handling
- NEVER display .skey file contents
- ALWAYS chmod 600 immediately after generation
- For mainnet: strongly recommend offline generation
- Verify directory permissions before proceeding

## References
- `cardano-cli-wallets` (guidance skill)
- `shared/PRINCIPLES.md`
</file>

<file path="skills/cardano-devnet-in-a-box/SKILL.md">
---
name: cardano-devnet-in-a-box
description: "One-command local rehearsal stack: cardano-node + hydra + ogmios + kupo. Docker-based, deterministic green/red testing."
metadata: {"openclaw":{"emoji":"\ud83d\udce6","requires":{"bins":["docker","docker-compose","git"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl git","bins":["colima","docker","docker-compose","curl","git"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl + git (brew)","os":["darwin","linux"]}]}}
---

# Cardano Devnet-in-a-Box (cardano-node + hydra + ogmios + kupo)

## What this skill is for

You are setting up a **local, end-to-end rehearsal environment** so we can:

- build/sign/submit real transactions (cardano-cli)
- run dApp infra (Ogmios + Kupo)
- open/close a Hydra Head and push L2 txs

…all **locally** before anyone even thinks about mainnet.

This skill uses **Hydra’s official demo devnet** as the base (because it’s the most “known-good” path), then bolts on **Ogmios + Kupo** as extra services.

Hydra’s docs describe this demo setup: a single fast local devnet + 3 Hydra nodes (Alice/Bob/Carol) + hydra-tui.

Kupo’s Docker image docs show the minimal container flags we reuse (`--node-socket`, `--node-config`, `--host`, `--workdir`).

Hydra publishes official Docker images at `ghcr.io/cardano-scaling/hydra-node`.

---

## Assumptions

- Docker is installed and running.
- `git` is available.
- Ports available on host:
  - 1337 (ogmios)
  - 1442 (kupo)
  - 4001-4003 (hydra API)
  - 3000 (grafana, optional)

---

## The canonical setup

### If the repo already has `devnet-in-a-box/`

Run:

```bash
cd devnet-in-a-box
chmod +x run.sh
./run.sh up
```

This will:

1. Clone `cardano-scaling/hydra` into `devnet-in-a-box/.vendor/hydra`
2. Copy our `docker-compose.override.yml` into `hydra/demo/`
3. Run the upstream demo scripts:
   - `./prepare-devnet.sh` (creates the `devnet/` folder + fresh genesis start time)
   - `./seed-devnet.sh` (publishes Hydra scripts + funds parties)
4. Start:
   - `cardano-node`
   - `hydra-node-1..3`
   - `ogmios`
   - `kupo`

### If the repo does NOT have `devnet-in-a-box/`

Create it by copying these exact files from the skill repo:

- `devnet-in-a-box/run.sh`
- `devnet-in-a-box/docker-compose.override.yml`
- `devnet-in-a-box/README.md`

(They’re designed to be dropped into any project.)

---

## Endpoints

- Ogmios (WebSocket): `ws://localhost:1337`
- Kupo (HTTP): `http://localhost:1442`
- Hydra API:
  - Alice: `http://localhost:4001`
  - Bob: `http://localhost:4002`
  - Carol: `http://localhost:4003`

---

## How to use it (agent playbook)

### 1) Bring the stack up

```bash
./devnet-in-a-box/run.sh up
```

### 2) Open a head (fastest path = TUI)

In 3 terminals:

```bash
./devnet-in-a-box/run.sh tui 1
./devnet-in-a-box/run.sh tui 2
./devnet-in-a-box/run.sh tui 3
```

Then inside the TUI:

- `[i]` init
- `[c]` commit
- once all parties commit, the head opens automatically

Hydra’s docs walk through this flow.

### 3) Validate the L1 + infra are alive

From the demo directory (the script handles paths for you), you can query the chain tip:

```bash
./devnet-in-a-box/run.sh logs cardano-node
```

Or directly:

```bash
cd devnet-in-a-box/.vendor/hydra/demo
docker compose exec -T cardano-node cardano-cli query tip --testnet-magic 42 --socket-path /devnet/node.socket
```

### 4) Use Ogmios + Kupo for app-level rehearsal

Typical dApp stack:

- **Kupo** for UTxO lookup / index queries
- **Ogmios** for chain sync + tx submission

This is the pair most “realistic” apps use for local integration tests.

---


### Deterministic rehearsal (green / red)

For a **no-vibes end-to-end check**, run:

```bash
cd devnet-in-a-box
./run.sh rehearsal
```

It will:

- run a smoke test (cardano-node + hydra APIs + optional kupo health)
- create a tiny **always-true Plutus script UTxO** on L1 (inline datum = 42, 10 ADA)
- initialize a Hydra Head
- commit: Alice (script UTxO + collateral) + Bob + Carol
- submit one L2 transaction that **spends the script UTxO inside the head**
- close → wait contestation → fanout

If everything works you get **GREEN**. Otherwise you get **RED** and the failing step.

Lightweight health check:

```bash
./run.sh smoke
```

## Troubleshooting (quick hits)

### `TraceNoLedgerView` in cardano-node logs

That’s almost always a **genesis start time** drift.

Fix: rerun prepare + restart the node.

```bash
cd devnet-in-a-box/.vendor/hydra/demo
./prepare-devnet.sh
docker compose up -d --force-recreate cardano-node
```

Hydra docs explicitly warn about waiting too long after `prepare-devnet.sh`.

### Ogmios/Kupo can’t open the node socket

Usually permissions on `devnet/node.socket`.

The `run.sh` tries to `chmod a+w` the socket from inside the container.

If it still fails:

```bash
cd devnet-in-a-box/.vendor/hydra/demo
docker compose exec -u root cardano-node chmod a+w /devnet/node.socket
```

### Kupo is “running” but returns nothing

Make sure we’re indexing something.

We default to `--match "*"` for devnet so it indexes everything.

If you change it, you can accidentally index zero addresses.

---

## Hard rule

This devnet harness is for **rehearsals**:

- never treat the demo keys as production keys
- never assume devnet settings ≈ mainnet settings
- always re-check protocol params, cost models, and script budgets when moving to preprod/mainnet
</file>

<file path="skills/cardano-protocol-params/reference/docker-fallback.md">
# Docker fallback (cardano-cli)

This skill includes `scripts/cardano-cli.sh`, which runs `cardano-cli` either:
- directly from your PATH, or
- inside Docker using `ghcr.io/intersectmbo/cardano-node`.

Basic usage:
```bash
chmod +x scripts/cardano-cli.sh
scripts/cardano-cli.sh version
```

If you have a node socket locally:
```bash
export CARDANO_NODE_SOCKET_PATH=/path/to/node.socket
scripts/cardano-cli.sh query tip --mainnet
```

Override container tag:
```bash
CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:10.6.1 scripts/cardano-cli.sh version
```
</file>

<file path="skills/cardano-protocol-params/reference/pparams.md">
# Protocol parameters cookbook

```bash
cardano-cli query protocol-parameters       --testnet-magic <MAGIC>       --out-file pparams.json
```

Keep `pparams.json` in the same folder as your tx body and witnesses.

Common debugging checklist:
- Does your CLI default to Conway? If unsure, use era-prefixed commands (e.g. `cardano-cli conway ...`) when supported.
- For Plutus scripts: confirm execution unit prices exist in params and match your network.
</file>

<file path="skills/cardano-protocol-params/scripts/cardano-cli.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${CARDANO_DOCKER_IMAGE:-ghcr.io/intersectmbo/cardano-node:latest}"

if command -v cardano-cli >/dev/null 2>&1; then
  exec cardano-cli "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: cardano-cli not found and docker not installed. Install cardano-cli or docker." >&2
  exit 1
fi

# Mount current working directory for inputs/outputs (datum, pparams, tx.body, etc.)
ARGS=(docker run --rm -i -v "$PWD":/work -w /work)

# If a node socket is available, mount it and forward env var.
if [[ "${CARDANO_NODE_SOCKET_PATH:-}" != "" ]]; then
  SOCK_DIR="$(cd "$(dirname "$CARDANO_NODE_SOCKET_PATH")" && pwd)"
  SOCK_NAME="$(basename "$CARDANO_NODE_SOCKET_PATH")"
  ARGS+=(-v "$SOCK_DIR":/ipc -e "CARDANO_NODE_SOCKET_PATH=/ipc/$SOCK_NAME")
fi

# Run cardano-cli inside the official-ish node container image.
ARGS+=("$IMAGE" cardano-cli)

exec "${ARGS[@]}" "$@"
</file>

<file path="skills/cardano-protocol-params/SKILL.md">
---
name: cardano-protocol-params
description: "Protocol parameters: fetch pparams, understand fees, min-UTxO, execution budgets. Read-only diagnostics."
allowed-tools:
  - Bash(cardano-cli:*)
  - Read
context:
  - "!cardano-cli version 2>&1 | head -5"
metadata: {"openclaw":{"emoji":"\ud83e\uddf0","requires":{"anyBins":["cardano-cli","docker"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# cardano-protocol-params

## When to use
- Fetching fresh protocol parameters
- Understanding fee calculation inputs
- Debugging min-UTxO or execution budget issues
- Comparing params across networks

## Operating rules (must follow)
- Always fetch fresh params for the target network
- Never assume mainnet params apply to testnets
- Keep pparams.json with tx artifacts for reproducibility

## Docker fallback mode
If `cardano-cli` is not installed locally, use the wrapper script in this skill folder to run **cardano-cli inside Docker** (the Cardano node container images include the CLI).

```bash
chmod +x {baseDir}/scripts/cardano-cli.sh
{baseDir}/scripts/cardano-cli.sh version
```

Notes:
- The wrapper mounts your current directory into the container as `/work` so files like `pparams.json`, `tx.body`, `datum.json` work normally.
- If you have a local node socket, set `CARDANO_NODE_SOCKET_PATH` before running so `query` commands work.
- Override the image with `CARDANO_DOCKER_IMAGE=ghcr.io/intersectmbo/cardano-node:<tag>`.

## Key parameters explained

### Fee calculation
```
minFeeA: 44           # lovelace per byte
minFeeB: 155381       # base fee in lovelace
```
Formula: `fee = minFeeA * txSize + minFeeB`

### Min UTxO
```
coinsPerUTxOByte: 4310   # lovelace per byte of UTxO
```
Minimum ADA required = size of UTxO (including datum) × coinsPerUTxOByte

### Execution units (Plutus)
```
maxTxExecutionUnits:
  steps: 10000000000     # CPU budget
  memory: 10000000       # Memory budget
executionUnitPrices:
  priceSteps: 0.0000721  # lovelace per step
  priceMemory: 0.0577    # lovelace per memory unit
```

### Reference scripts
```
minFeeRefScriptCostPerByte: 15  # Cost for using reference scripts
```

## Workflow

### Fetch parameters
```bash
# Preprod
cardano-cli conway query protocol-parameters \
  --testnet-magic 1 \
  --out-file pparams-preprod.json

# Mainnet
cardano-cli conway query protocol-parameters \
  --mainnet \
  --out-file pparams-mainnet.json
```

### Extract key values
```bash
# Using jq
cat pparams.json | jq '{
  minFeeA: .txFeePerByte,
  minFeeB: .txFeeFixed,
  coinsPerUTxOByte: .utxoCostPerByte,
  maxTxSize: .maxTxSize,
  maxValSize: .maxValueSize
}'
```

### Calculate min-UTxO for output
```bash
# Approximate: base ~160 bytes + datum size
# For simple ADA-only output: ~1 ADA minimum
# For output with tokens: varies by token count/names
```

## Examples

### Example: Debug "UTxO too small" error
**Problem:** Transaction fails with min-UTxO error

**Response:**
```bash
# 1. Fetch current params
cardano-cli conway query protocol-parameters \
  --testnet-magic 1 \
  --out-file pparams.json

# 2. Check coinsPerUTxOByte
cat pparams.json | jq .utxoCostPerByte
# Result: 4310

# 3. Estimate min-UTxO for your output
# Simple ADA output: ~160 bytes × 4310 = ~690,000 lovelace
# With inline datum: add datum size × 4310
# With tokens: add ~30 bytes per token

# 4. Solution: increase output amount above minimum
```

### Example: Estimate script execution cost
**Problem:** Need to budget for Plutus script

**Response:**
```bash
# 1. Get execution prices
cat pparams.json | jq '{
  priceSteps: .executionUnitPrices.priceSteps,
  priceMemory: .executionUnitPrices.priceMemory
}'

# 2. If script uses 1M steps and 100K memory:
# Cost = (1000000 × 0.0000721) + (100000 × 0.0577)
# Cost = 72.1 + 5770 = 5842.1 lovelace (~0.006 ADA)

# 3. Add to base tx fee for total
```

## Network magic reference
```
Mainnet:  (no flag, use --mainnet)
Preprod:  --testnet-magic 1
Preview:  --testnet-magic 2
```

## Safety / key handling
- Protocol params are public, no secrets involved
- Always verify you're querying the intended network
- Store pparams with tx artifacts for debugging

## References
- `shared/PRINCIPLES.md`
- [Cardano Protocol Parameters](https://docs.cardano.org)
</file>

<file path="skills/hydra-head/reference/docker-fallback.md">
# Docker fallback (hydra-node)

This skill includes `scripts/hydra-node.sh`, which runs `hydra-node` either:
- directly from your PATH, or
- inside Docker using `ghcr.io/cardano-scaling/hydra-node`.

Basic usage:
```bash
chmod +x scripts/hydra-node.sh
scripts/hydra-node.sh --help
scripts/hydra-node.sh gen-hydra-key --output-file hydra
```

For full multi-node demo/head operations, prefer the hydra.family Docker Compose demo.
</file>

<file path="skills/hydra-head/reference/hydra-best-practices.md">
# Hydra Head references (hydra.family-aligned)

## Minimal command probes
```bash
hydra-node --help | sed -n '1,80p'
hydra-node run --help | sed -n '1,160p' || true
```

## Key generation
**Cardano keys**
```bash
cardano-cli address key-gen       --verification-key-file cardano.vk       --signing-key-file cardano.sk
```

**Hydra keys**
```bash
hydra-node gen-hydra-key --output-file hydra
# produces hydra.sk and hydra.vk
```

## Cardano connectivity modes
**Direct to cardano-node**
```bash
hydra-node run       --testnet-magic <MAGIC>       --node-socket <PATH_TO_NODE_SOCKET>       ...
```

**Blockfrost**
```bash
hydra-node run       --blockfrost blockfrost-project.txt       ...
```
Note: when using Blockfrost, the underlying network is inferred; don't also pass `--mainnet` / `--testnet-magic`.

## Operational checklist (from docs)
- Ensure cardano-node is ready before hydra-node starts (socket open; ledger reconstructed)
- Verify scripts transaction id for preview/preprod/mainnet
- Ensure your `--cardano-signing-key` matches the verification key used in Init
- Verify peers are connected (`PeerConnected` seen) and hydra keys match expectations (`AckSn` received)
</file>

<file path="skills/hydra-head/reference/sources.md">
# Hydra Documentation Sources

This file documents the sources used to build the Hydra Head skills. Keep this updated when:
- hydra-node releases new versions with changed behavior
- hydra.family documentation is updated
- New features are added to the skills

## Primary Sources

### hydra.family Official Documentation
Base URL: https://hydra.family/head-protocol/

| Section | URL | Last Verified |
|---------|-----|---------------|
| Getting Started | https://hydra.family/head-protocol/docs/getting-started | 2024-01 |
| Configuration | https://hydra.family/head-protocol/docs/getting-started/quickstart/with-cardano | 2024-01 |
| Operating Hydra | https://hydra.family/head-protocol/docs/how-to/operating-hydra | 2024-01 |
| Troubleshooting | https://hydra.family/head-protocol/docs/how-to/operating-hydra#common-issues | 2024-01 |
| API Reference | https://hydra.family/head-protocol/docs/api-reference | 2024-01 |

### GitHub Repository
- **Main repo**: https://github.com/input-output-hk/hydra
- **Release notes**: https://github.com/input-output-hk/hydra/releases
- **Scripts tx ids**: Published in release notes for each network

## Version Compatibility

| hydra-node Version | Skills Version | Notes |
|--------------------|----------------|-------|
| 0.20.x | Current | Deposit/decommit support |
| 0.19.x | Compatible | Mirror nodes introduced |
| 0.18.x | Compatible | Basic functionality |

## Key Concepts Referenced

### From "Operating Hydra"
- Cardano vs Hydra key separation
- Contestation period configuration
- Deposit period handling
- Peer connectivity requirements
- Scripts tx id per network

### From "Common Issues"
- "No head observed" → network/scripts/key issues
- "Head doesn't progress" → peer/hydra-key issues
- "Peer out of sync" → snapshot side-loading fix
- Mirror node behavior (SnapshotAlreadySigned)

## Scripts Transaction IDs

> **Important**: Always get current scripts tx ids from the latest hydra-node release notes.

These are examples and may be outdated:
```
Preview:  (check release notes)
Preprod:  (check release notes)
Mainnet:  (check release notes)
```

## Updating This File

When hydra-node releases a new version:
1. Check release notes for breaking changes
2. Verify scripts tx ids for each network
3. Test skills against new version
4. Update version compatibility table
5. Update "Last Verified" dates

## Related Skills
- `hydra-head` - Operational best practices
- `hydra-head-operator` - Execution skill (manual invoke)
- `hydra-head-troubleshooter` - Decision tree for issues
</file>

<file path="skills/hydra-head/scripts/hydra-node.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${HYDRA_DOCKER_IMAGE:-ghcr.io/cardano-scaling/hydra-node}"

if command -v hydra-node >/dev/null 2>&1; then
  exec hydra-node "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: hydra-node not found and docker not installed. Install hydra-node or docker." >&2
  exit 1
fi

# Most useful for: --help, gen-hydra-key, tui quick checks.
# For full multi-node demo / head operations, prefer the hydra.family Docker Compose demo.
exec docker run --rm -i -v "$PWD":/work -w /work "$IMAGE" "$@"
</file>

<file path="skills/hydra-head/templates/runbook.md">
# Hydra Head runbook (fill-in)

## Network
- [ ] mainnet / preprod / preview / devnet:
- [ ] testnet magic (if applicable):
- [ ] cardano-node connection: socket / blockfrost
- [ ] scripts tx id (per network):

## Participants
- Alice:
  - cardano.vk:
  - cardano.sk path:
  - hydra.vk:
  - hydra.sk path:
  - listen host:port:
- Bob:
- Carol:

## Protocol parameters
- Contestation period (CP):
- Deposit period (DP) (if used):

## Peer mesh
- [ ] All peers listed with `--peer host:port`
- [ ] PeerConnected observed for all participants

## Head lifecycle
- [ ] Init tx observed
- [ ] Commit tx observed
- [ ] Head Open confirmed
- [ ] L2 tx submit tested
- [ ] Close initiated
- [ ] Contestation monitored
- [ ] Fanout confirmed and L1 UTxOs verified
</file>

<file path="skills/hydra-head/SKILL.md">
---
name: hydra-head
description: "Hydra Head guidance: setup, keys, peers, lifecycle. Best practices from hydra.family. Use operator skill for execution."
allowed-tools:
  - Read
user-invocable: true
context:
  - "!hydra-node --version 2>&1 | head -3"
metadata: {"openclaw":{"emoji":"\ud83d\udc09","requires":{"anyBins":["hydra-node","docker"],"bins":["curl"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# hydra-head

> **This is a guidance skill.** Provides best practices and templates. For execution, use `hydra-head-operator`.

## When to use
- Setting up or operating hydra-node
- Understanding Hydra Head lifecycle
- Debugging connectivity or configuration issues

## Operating rules (must follow)
- Confirm network (mainnet/preprod/preview/devnet)
- Use hydra.family docs as source of truth
- Never execute—only provide guidance
- Treat all `.sk` files as secrets

## Docker fallback mode
If `hydra-node` is not installed locally, use the wrapper script in this skill folder to run **hydra-node inside Docker** (Hydra upstream recommends Docker images for quickest start).

```bash
chmod +x {baseDir}/scripts/hydra-node.sh
{baseDir}/scripts/hydra-node.sh --help
{baseDir}/scripts/hydra-node.sh gen-hydra-key --output-file hydra
```

For full multi-node Head demos, prefer the hydra.family Docker Compose demo (it's the canonical "known-good" setup).

## Key concepts

### Key roles
1. **Cardano keys**: Identify participant on L1, pay tx fees
2. **Hydra keys**: Multi-sign snapshots inside the head

### Lifecycle
```
Init → Commit → Open → [L2 transactions] → Close → Contest → Fanout
```

### Important parameters
- **Contestation period**: Safety window for contesting after Close
- **Deposit period**: Window for recognizing deposits

## Setup guide

### 1. Generate keys
```bash
# Cardano payment keys
cardano-cli conway address key-gen \
  --verification-key-file cardano.vk \
  --signing-key-file cardano.sk

# Hydra keys
hydra-node gen-hydra-key --output-file hydra
# Creates hydra.sk and hydra.vk

chmod 600 *.sk
```

### 2. Exchange keys with peers
Each participant needs:
- Their own `cardano.sk` and `hydra.sk`
- All peers' `cardano.vk` and `hydra.vk`

### 3. Get scripts tx id
```bash
# From hydra-node release notes for your network
# Preview: <scripts-tx-id-preview>
# Preprod: <scripts-tx-id-preprod>
# Mainnet: <scripts-tx-id-mainnet>
```

### 4. Configure hydra-node
```bash
hydra-node run \
  --node-id "alice" \
  --persistence-dir ./hydra-data \
  \
  # Cardano connection (choose one):
  --node-socket /path/to/node.socket \
  --testnet-magic 1 \
  # OR:
  --blockfrost blockfrost.txt \
  \
  # Identity:
  --cardano-signing-key cardano.sk \
  --hydra-signing-key hydra.sk \
  \
  # Peers (repeat for each):
  --cardano-verification-key bob-cardano.vk \
  --hydra-verification-key bob-hydra.vk \
  --peer "bob.example.com:5001" \
  \
  # Protocol:
  --hydra-scripts-tx-id <scripts-tx-id> \
  --contestation-period 120s \
  \
  # API:
  --api-host 0.0.0.0 \
  --api-port 4001 \
  --host 0.0.0.0 \
  --port 5001
```

## Head operations

### Open a head
```bash
# Via hydra-tui
hydra-tui --connect localhost:4001

# Via API
curl -X POST localhost:4001/init
# Then each party commits
curl -X POST localhost:4001/commit \
  -H "Content-Type: application/json" \
  -d '{"utxo": {...}}'
```

### L2 transactions
```bash
# Submit transaction
curl -X POST localhost:4001/submit \
  -H "Content-Type: application/json" \
  -d '{"transaction": "..."}'
```

### Close and fanout
```bash
curl -X POST localhost:4001/close
# Wait for contestation period
curl -X POST localhost:4001/fanout
```

## Examples

### Example: 2-party head on preprod
**User request:** "Set up a 2-party Hydra head on preprod"

**Response:**
```bash
# === Party 1 (Alice) ===

# 1. Create directory
mkdir -p ~/hydra/alice && cd ~/hydra/alice

# 2. Generate keys
cardano-cli conway address key-gen \
  --verification-key-file cardano.vk \
  --signing-key-file cardano.sk

hydra-node gen-hydra-key --output-file hydra
chmod 600 *.sk

# 3. Get preprod scripts tx id from release notes
SCRIPTS_TX_ID="..."

# 4. Exchange keys with Bob (get bob-cardano.vk, bob-hydra.vk)

# 5. Run node
hydra-node run \
  --node-id "alice" \
  --persistence-dir ./data \
  --node-socket $CARDANO_NODE_SOCKET_PATH \
  --testnet-magic 1 \
  --cardano-signing-key cardano.sk \
  --hydra-signing-key hydra.sk \
  --cardano-verification-key bob-cardano.vk \
  --hydra-verification-key bob-hydra.vk \
  --peer "bob-host:5001" \
  --hydra-scripts-tx-id $SCRIPTS_TX_ID \
  --contestation-period 120s \
  --api-port 4001 \
  --port 5001

# === After both nodes running ===

# 6. Init head (either party)
curl -X POST localhost:4001/init

# 7. Commit funds
hydra-tui --connect localhost:4001
# Select UTxO to commit

# 8. Head opens when all commit
```

## Verification checklist
- [ ] All nodes same hydra-node version
- [ ] Scripts tx id matches network
- [ ] cardano-node fully synced and socket ready
- [ ] All peers exchanged correct vkeys
- [ ] PeerConnected messages in logs
- [ ] Network ports open between peers

## Common issues
See `hydra-head-troubleshooter` skill for:
- "No head observed"
- "Head doesn't make progress"
- "Peer out of sync"
- AckSn/PeerConnected issues

## Safety / key handling
- Never share `.sk` files
- Keep separate directories per participant
- Test on devnet/preprod first
- Back up persistence directory

## References
- `shared/PRINCIPLES.md`
- `hydra-head-operator` (for execution)
- `hydra-head-troubleshooter` (for debugging)
- See `reference/sources.md` for doc provenance
</file>

<file path="skills/hydra-head-operator/reference/operator.md">
# Operator notes

This operator uses OpenClaw's **command-dispatch: tool** mode to route the slash command directly to the **Exec Tool** (no model).

Recommended OpenClaw session defaults:
- `/exec host=gateway security=allowlist ask=on-miss`

This ensures host execution uses allowlist enforcement and approval prompting (based on your exec approvals policy).
</file>

<file path="skills/hydra-head-operator/scripts/hydra-api.sh">
#!/usr/bin/env bash
set -euo pipefail

PORT="${1:-}"
ACTION="${2:-head}"

if [[ -z "$PORT" ]]; then
  echo "Usage: hydra-api.sh <port> [head|health|metrics]" >&2
  exit 2
fi

BASE="http://127.0.0.1:${PORT}"

case "$ACTION" in
  head)    curl -fsS "$BASE/head" ;;
  health)  curl -fsS "$BASE/health" ;;
  metrics) curl -fsS "$BASE/metrics" ;;
  *) echo "Unknown action: $ACTION (use head|health|metrics)" >&2; exit 2 ;;
esac
echo
</file>

<file path="skills/hydra-head-operator/scripts/hydra-node.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${HYDRA_DOCKER_IMAGE:-ghcr.io/cardano-scaling/hydra-node}"

if command -v hydra-node >/dev/null 2>&1; then
  exec hydra-node "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: hydra-node not found and docker not installed. Install hydra-node or docker." >&2
  exit 1
fi

# Most useful for: --help, gen-hydra-key, tui quick checks.
# For full multi-node demo / head operations, prefer the hydra.family Docker Compose demo.
exec docker run --rm -i -v "$PWD":/work -w /work "$IMAGE" "$@"
</file>

<file path="skills/hydra-head-operator/SKILL.md">
---
name: hydra-head-operator
description: "Execute Hydra operations: init, commit, open, close, fanout. Manual invoke only due to L1 state changes."
argument-hint: "<shell command>"
allowed-tools:
  - Bash(hydra-node:*)
  - Bash(hydra-tui:*)
  - Bash(curl:*)
  - Bash(docker:*)
  - Bash(cat:*)
  - Read
  - Write
disable-model-invocation: true
user-invocable: true
command-dispatch: tool
command-tool: exec
command-arg-mode: raw
context:
  - "!hydra-node --version 2>&1 | head -3"
  - "!hydra-node run --help 2>&1 | head -30"
metadata: {"openclaw":{"emoji":"\ud83d\uddef","requires":{"anyBins":["hydra-node","docker"],"bins":["curl"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}],"homepage":"https://docs.openclaw.ai/tools/exec"}}
---

# hydra-head-operator

> **OPERATOR SKILL**: Executes Hydra Head operations that affect L1 state. Requires explicit human invocation.

## When to use
- When ready to start hydra-node, init head, commit funds, or close/fanout
- After reviewing guidance from `hydra-head`

## Operating rules (must follow)
- **Confirm network and scripts tx id before starting**
- Verify all peer configurations match
- **REQUIRE explicit confirmation before Init, Close, Fanout**
- Keep logs for debugging
- Test on devnet/preview before mainnet

## OpenClaw exec dispatch mode
This skill also functions as a **deterministic exec gateway** for OpenClaw: when you run the slash command, OpenClaw **bypasses the model** and forwards your arguments straight to the **Exec Tool** (`command-dispatch: tool`).

### Safety first: force approvals + allowlist mode
Before using as an operator, set Exec defaults for the session:
- `/exec host=gateway security=allowlist ask=on-miss`

### Allowlist-safe shortcut (recommended)
If your Exec allowlist is strict, allowlist **one** entrypoint and route everything through it:
- Allowlist: `~/Projects/**/cardano-agent-skills/scripts/oc-safe.sh` (adjust glob)
- Run:
  - `/hydra_head_operator ./scripts/oc-safe.sh hydra --help`
  - `/hydra_head_operator ./scripts/oc-safe.sh hydra gen-hydra-key --output-file hydra`
  - `/hydra_head_operator ./scripts/oc-safe.sh hydra-api 4001 head`

## Docker fallback mode
If `hydra-node` is not installed locally, use the wrapper script in this skill folder to run **hydra-node inside Docker**:

```bash
chmod +x {baseDir}/scripts/hydra-node.sh
{baseDir}/scripts/hydra-node.sh --help
```

Quick API probes (curl wrapper):
```bash
chmod +x {baseDir}/scripts/hydra-api.sh
{baseDir}/scripts/hydra-api.sh 4001 head
{baseDir}/scripts/hydra-api.sh 4001 metrics
```

## Pre-flight checklist
```
[ ] Network: ___________
[ ] Hydra scripts tx id for network
[ ] Cardano node accessible (socket or Blockfrost)
[ ] Cardano signing key ready
[ ] Hydra signing key generated
[ ] Peer configs exchanged (vkeys + addresses)
[ ] Contestation period agreed
```

## Execution workflow

### Step 1: Generate Hydra key (if needed)
```bash
hydra-node gen-hydra-key --output-file hydra
# Creates hydra.sk and hydra.vk
chmod 600 hydra.sk
```

### Step 2: Start hydra-node
```bash
hydra-node run \
  --node-id "participant-1" \
  --persistence-dir ./hydra-state \
  --cardano-signing-key cardano.sk \
  --hydra-signing-key hydra.sk \
  --hydra-verification-key peer1-hydra.vk \
  --hydra-verification-key peer2-hydra.vk \
  --cardano-verification-key peer1-cardano.vk \
  --cardano-verification-key peer2-cardano.vk \
  --peer "peer1-host:5001" \
  --peer "peer2-host:5001" \
  --api-host 0.0.0.0 \
  --api-port 4001 \
  --host 0.0.0.0 \
  --port 5001 \
  --testnet-magic 1 \
  --node-socket /path/to/node.socket \
  --hydra-scripts-tx-id <scripts-tx-id> \
  --contestation-period 120s \
  2>&1 | tee hydra-node.log
```

### Step 3: Verify connectivity
```bash
# Check peers connected
curl -s localhost:4001/peers | jq .

# Check head status
curl -s localhost:4001/status | jq .
```

### Step 4: Init head (REQUIRES CONFIRMATION)
```
⚠️ CONFIRM HEAD INIT ⚠️
Network: preprod
Participants: 3
Contestation period: 120s

Type 'init' to proceed:
```
```bash
# Via API
curl -X POST localhost:4001/init

# Or via hydra-tui
hydra-tui --connect localhost:4001
```

### Step 5: Commit funds
```bash
# Prepare UTxO to commit
cardano-cli conway query utxo \
  --address <your-addr> \
  --testnet-magic 1

# Commit via API
curl -X POST localhost:4001/commit \
  -H "Content-Type: application/json" \
  -d '{"utxo": {"<txid>#<index>": {...}}}'
```

### Step 6: Operate in head
```bash
# Submit L2 transactions through API
curl -X POST localhost:4001/submit \
  -H "Content-Type: application/json" \
  -d '{"transaction": "..."}'
```

### Step 7: Close head (REQUIRES CONFIRMATION)
```
⚠️ CONFIRM HEAD CLOSE ⚠️
This will begin contestation period (120s).
All parties must remain online to contest if needed.

Type 'close' to proceed:
```
```bash
curl -X POST localhost:4001/close
```

### Step 8: Fanout (after contestation)
```bash
# Wait for contestation period
# Then fanout
curl -X POST localhost:4001/fanout

# Verify L1 UTxOs
cardano-cli conway query utxo \
  --address <your-addr> \
  --testnet-magic 1
```

## Safety / key handling
- Never share hydra.sk or cardano.sk
- Keep persistence-dir backed up
- Monitor logs during contestation
- Ensure all parties can contest if needed

## References
- `hydra-head` (guidance skill)
- `hydra-head-troubleshooter` (if issues arise)
- `shared/PRINCIPLES.md`
- [hydra.family docs](https://hydra.family)
</file>

<file path="skills/hydra-head-troubleshooter/reference/docker-fallback.md">
# Docker fallback (hydra-node)

This skill includes `scripts/hydra-node.sh`, which runs `hydra-node` either:
- directly from your PATH, or
- inside Docker using `ghcr.io/cardano-scaling/hydra-node`.

Basic usage:
```bash
chmod +x scripts/hydra-node.sh
scripts/hydra-node.sh --help
scripts/hydra-node.sh gen-hydra-key --output-file hydra
```

For full multi-node demo/head operations, prefer the hydra.family Docker Compose demo.
</file>

<file path="skills/hydra-head-troubleshooter/reference/probes.md">
# Troubleshooter quick probes

## Collect facts (run on each node)
```bash
hydra-node --version || true
hydra-node --help | sed -n '1,80p'
hydra-node run --help | sed -n '1,200p' || true

# last logs (example; adjust to your service manager)
# docker: docker logs --tail=300 hydra-node
# systemd: journalctl -u hydra-node -n 300 --no-pager
```

## Log keywords to grep for
- Peer connectivity: `PeerConnected`
- Snapshot ack phase: `AckSn`
- Errors around logic: `LogicOutcome`
- Mirror nodes: `SnapshotAlreadySigned` (harmless in mirror setups)

## Metrics (if enabled)
```bash
curl http://localhost:<MONITORING_PORT>/metrics | grep -E 'hydra_head_peers_connected|hydra_head_confirmed_tx'
```
</file>

<file path="skills/hydra-head-troubleshooter/reference/sources.md">
# Hydra Troubleshooter Documentation Sources

This file documents the sources for the troubleshooting decision tree.

## Primary Source

### hydra.family "Operating Hydra" - Common Issues Section
URL: https://hydra.family/head-protocol/docs/how-to/operating-hydra#common-issues

Last verified: 2024-01

## Issue Mappings

| Skill Section | Source Section | Notes |
|---------------|----------------|-------|
| A) No head observed | Common Issues - Network/Scripts | Direct mapping |
| B) Head doesn't progress | Common Issues - Connectivity | Direct mapping |
| C) Peer out of sync | Common Issues - Snapshot side-loading | Direct mapping |
| D) Mirror nodes | Operating Hydra - HA section | SnapshotAlreadySigned handling |

## Log Patterns

Derived from:
- hydra-node JSON log output format
- hydra.family monitoring documentation
- Practical debugging experience

| Pattern | Source |
|---------|--------|
| PeerConnected | hydra-node network layer logs |
| AckSn | Hydra protocol snapshot acknowledgment |
| LogicOutcome | Head state machine transitions |
| SnapshotConfirmed | Consensus completion |

## API Endpoints Referenced

From API Reference: https://hydra.family/head-protocol/docs/api-reference

| Endpoint | Purpose |
|----------|---------|
| GET /health | Node health check |
| GET /peers | Connected peers |
| GET /status | Head status |
| GET /snapshot | Current snapshot |
| POST /snapshot | Side-load snapshot |

## Metrics Referenced

From Prometheus metrics exposed on monitoring port:
- `hydra_head_peers_connected` - Connected peer count
- Various snapshot and transaction metrics

## Updating This File

When troubleshooting patterns change:
1. Verify against latest hydra.family docs
2. Test decision tree steps with current hydra-node
3. Update log patterns if format changes
4. Add new issues as they're documented
</file>

<file path="skills/hydra-head-troubleshooter/scripts/hydra-node.sh">
#!/usr/bin/env bash
set -euo pipefail

IMAGE="${HYDRA_DOCKER_IMAGE:-ghcr.io/cardano-scaling/hydra-node}"

if command -v hydra-node >/dev/null 2>&1; then
  exec hydra-node "$@"
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "ERROR: hydra-node not found and docker not installed. Install hydra-node or docker." >&2
  exit 1
fi

# Most useful for: --help, gen-hydra-key, tui quick checks.
# For full multi-node demo / head operations, prefer the hydra.family Docker Compose demo.
exec docker run --rm -i -v "$PWD":/work -w /work "$IMAGE" "$@"
</file>

<file path="skills/hydra-head-troubleshooter/templates/incident-worksheet.md">
# Hydra incident worksheet (copy/paste into a ticket)

## Symptom
- [ ] No head observed from chain
- [ ] Head does not make progress
- [ ] Peer out of sync / stuck snapshots
- [ ] Connectivity flaps / etcd quorum issues
- [ ] Other:

## Environment
- Network: mainnet / preprod / preview / devnet
- hydra-node version:
- Cardano connectivity: node socket / blockfrost
- scripts tx id:

## Peers
- Node A advertise:
- Node B advertise:
- Node C advertise:
- Peer mesh complete? Y/N

## Evidence
- Logs A (time window):
- Logs B:
- Logs C:
- Keywords found:
  - PeerConnected: Y/N
  - AckSn: Y/N
  - LogicOutcome errors: Y/N
  - SnapshotAlreadySigned: Y/N

## Fix attempted
- [ ] corrected network flags / magic
- [ ] ensured cardano-node ready before hydra-node start
- [ ] updated scripts tx id
- [ ] corrected cardano/hydra verification keys
- [ ] snapshot side-load performed (GET /snapshot + POST /snapshot)
- [ ] adjusted mirror node counts / etcd quorum
</file>

<file path="skills/hydra-head-troubleshooter/SKILL.md">
---
name: hydra-head-troubleshooter
description: "Hydra troubleshooting: decision tree for common issues. Maps symptoms to fixes with verification steps."
allowed-tools:
  - Read
user-invocable: true
context:
  - "!hydra-node --version 2>&1 | head -3"
metadata: {"openclaw":{"emoji":"\ud83d\udc09","requires":{"anyBins":["hydra-node","docker"],"bins":["curl"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
---

# hydra-head-troubleshooter

## When to use
- Hydra Head doesn't start or no head observed
- Head exists but doesn't make progress
- Peers out of sync or disconnected
- Log messages: PeerConnected, AckSn, LogicOutcome errors

## Operating rules (must follow)
- Confirm network and hydra-node version first
- Request logs from ALL participants for same time window
- Never request key contents (file paths OK)
- Output: (1) Root cause (2) Fix steps (3) Verification

## Docker fallback mode
If `hydra-node` is not installed locally, use the wrapper script in this skill folder to run **hydra-node inside Docker** (Hydra upstream recommends Docker images for quickest start).

```bash
chmod +x {baseDir}/scripts/hydra-node.sh
{baseDir}/scripts/hydra-node.sh --help
{baseDir}/scripts/hydra-node.sh gen-hydra-key --output-file hydra
```

For full multi-node Head demos, prefer the hydra.family Docker Compose demo (it's the canonical "known-good" setup).

## Quick diagnostic commands
```bash
# Check hydra-node version
hydra-node --version

# Check API health
curl -s localhost:4001/health

# Check peers
curl -s localhost:4001/peers

# Check head status
curl -s localhost:4001/status

# Check metrics (if enabled)
curl -s localhost:6001/metrics | grep hydra
```

## Decision tree

### A) "No head is observed from the chain"

**Symptoms:**
- Head never appears in logs
- No Init/Commit/Open progression
- Client shows no head state

**Check 1: Cardano connection**
```bash
# Verify cardano-node is ready
cardano-cli query tip --testnet-magic 1
# Should show current slot, not error

# Check socket exists
ls -la $CARDANO_NODE_SOCKET_PATH
```

**Fix:** Wait for cardano-node sync, verify socket path and network magic

**Check 2: Scripts tx id**
```bash
# Verify you're using correct scripts tx id for network
# Get from hydra-node release notes

# In hydra-node logs, look for:
grep -i "script" hydra-node.log | head -20
```

**Fix:** Use correct `--hydra-scripts-tx-id` for your network

**Check 3: Key mismatch**
```bash
# Verify cardano.sk matches what peers have as your vkey
cardano-cli key verification-key \
  --signing-key-file cardano.sk \
  --verification-key-file check.vkey

# Compare check.vkey with what you distributed
```

**Fix:** Re-exchange verification keys with all peers

---

### B) "Head does not make progress"

**Symptoms:**
- Head exists but stuck at Init or Commit
- Snapshots not confirmed
- Commands hang or timeout

**Check 1: Peer connectivity**
```bash
# In logs, look for PeerConnected
grep "PeerConnected" hydra-node.log

# Check metrics
curl -s localhost:6001/metrics | grep peers_connected
```

**Fix:** Verify `--peer host:port` is correct and ports are reachable

**Check 2: Hydra key mismatch**
```bash
# Look for AckSn issues
grep -E "AckSn|LogicOutcome" hydra-node.log

# Verify hydra keys match
hydra-node verify-keys \
  --hydra-signing-key hydra.sk \
  --hydra-verification-key peer-hydra.vk
```

**Fix:** Re-exchange hydra verification keys

**Check 3: Version mismatch**
```bash
# All nodes must run compatible versions
hydra-node --version
# Compare across all participants
```

**Fix:** Align hydra-node versions

---

### C) "Head stuck: peer out of sync"

**Symptoms:**
- One node accepts txs, others reject
- Snapshots stop being signed
- Ledger state diverged

**Cause:** Different ledger views due to config drift or missed txs

**Fix: Snapshot side-loading**
```bash
# 1. Get latest snapshot from healthy node
curl -s http://healthy-node:4001/snapshot > snapshot.json

# 2. Post to out-of-sync node
curl -X POST http://out-of-sync-node:4001/snapshot \
  -H "Content-Type: application/json" \
  -d @snapshot.json
```

**Verify:** Snapshots resume, all parties sign again

---

### D) Mirror nodes / HA issues

**Symptoms:**
- `SnapshotAlreadySigned` in logs
- etcd quorum issues

**Reality:**
- `SnapshotAlreadySigned` is transient and harmless with mirrors
- Keep mirror count < floor(n/2) for quorum stability

**Fix:** Reduce mirror count or accept transient warnings

---

## Log patterns to grep

| Pattern | Meaning |
|---------|---------|
| `PeerConnected` | Peer connected successfully |
| `PeerDisconnected` | Peer lost connection |
| `AckSn` | Snapshot acknowledgment |
| `LogicOutcome` | Head logic result (check for errors) |
| `SnapshotConfirmed` | Snapshot finalized |
| `HeadIsOpen` | Head successfully opened |
| `HeadIsClosed` | Head closed, contestation started |

## Verification checklist

After any fix:
- [ ] All nodes same hydra-node version
- [ ] Scripts tx id correct for network
- [ ] cardano-node ready (query tip works)
- [ ] PeerConnected for all peers
- [ ] AckSn messages flowing
- [ ] No LogicOutcome errors

## Examples

### Example: Diagnose stuck head
**User request:** "My Hydra head won't open—stuck at commit"

**Response:**
```bash
# 1. Check all peers connected
grep "PeerConnected" hydra-node.log | tail -10
# Should see PeerConnected for each peer

# 2. If missing peers, check network
nc -zv peer-host 5001
# Should show "Connection succeeded"

# 3. Check all parties committed
curl -s localhost:4001/status | jq .
# Look for parties and their commit status

# 4. Check for key issues
grep -E "InvalidSignature|WrongParty" hydra-node.log

# Common fix: restart with correct peer addresses
# Verify --peer host:port matches actual peer locations
```

## References
- `hydra-head` (operational guidance)
- `hydra-head-operator` (execution)
- `reference/sources.md` (doc provenance)
- [hydra.family troubleshooting](https://hydra.family/head-protocol/docs/how-to/operating-hydra)
</file>

<file path="skills/meshjs-cardano/reference/meshjs-patterns.md">
# MeshJS patterns (high level)

- Prefer explicit UTxO selection for deterministic behavior.
- Keep datum/redeemer JSON schemas versioned and validated at runtime.
- Always surface tx hash and provide a link to an explorer per network.
</file>

<file path="skills/meshjs-cardano/SKILL.md">
---
name: meshjs-cardano
description: "MeshJS patterns: tx building, wallet connectors, script interactions. TypeScript/JavaScript Cardano development."
allowed-tools:
  - Read
  - Write
user-invocable: true
---

# meshjs-cardano

## When to use
- Building Cardano dApps with MeshJS (TypeScript/JavaScript)
- Integrating CIP-30 wallet connectors
- Transaction building in browser or Node.js

## Operating rules (must follow)
- Confirm MeshJS version and environment (Next.js, Vite, Node)
- Never request seed phrases or private keys
- Handle wallet disconnects gracefully
- Test on preprod before mainnet

## Setup

### Installation
```bash
npm install @meshsdk/core @meshsdk/react
# or
yarn add @meshsdk/core @meshsdk/react
```

### Provider setup
```typescript
import { BlockfrostProvider } from '@meshsdk/core';

const provider = new BlockfrostProvider('<PROJECT_ID>');
// or for preprod:
const provider = new BlockfrostProvider('<PROJECT_ID>', 'preprod');
```

## Wallet connection (React)

```tsx
import { CardanoWallet, useWallet } from '@meshsdk/react';

function App() {
  const { connected, wallet } = useWallet();

  return (
    <div>
      <CardanoWallet />
      {connected && <p>Connected!</p>}
    </div>
  );
}
```

## Transaction building

### Simple ADA transfer
```typescript
import { Transaction } from '@meshsdk/core';

const tx = new Transaction({ initiator: wallet })
  .sendLovelace(
    'addr_test1qz...',
    '5000000'  // 5 ADA
  );

const unsignedTx = await tx.build();
const signedTx = await wallet.signTx(unsignedTx);
const txHash = await wallet.submitTx(signedTx);
```

### With native tokens
```typescript
const tx = new Transaction({ initiator: wallet })
  .sendAssets(
    'addr_test1qz...',
    [
      { unit: 'lovelace', quantity: '2000000' },
      { unit: '<policy_id><asset_name_hex>', quantity: '1' }
    ]
  );
```

### With metadata
```typescript
const tx = new Transaction({ initiator: wallet })
  .sendLovelace('addr_test1qz...', '1000000')
  .setMetadata(674, { msg: ['Hello from MeshJS'] });
```

## Script interactions

### Lock funds at script
```typescript
import { Data } from '@meshsdk/core';

const datum: Data = {
  alternative: 0,
  fields: [wallet.getPaymentAddress()]
};

const tx = new Transaction({ initiator: wallet })
  .sendLovelace(
    {
      address: scriptAddress,
      datum: { inline: datum }
    },
    '5000000'
  );
```

### Spend from script
```typescript
const tx = new Transaction({ initiator: wallet })
  .redeemValue({
    value: scriptUtxo,
    script: plutusScript,
    datum: datum,
    redeemer: { data: { alternative: 0, fields: [] } }
  })
  .sendLovelace(recipientAddress, '4500000')
  .setCollateral([collateralUtxo]);
```

## Examples

### Example: NFT minting
**User request:** "Mint an NFT with MeshJS"

**Response:**
```typescript
import { ForgeScript, Transaction } from '@meshsdk/core';

// Create minting script (time-locked)
const { pubKeyHash } = wallet.getPaymentAddress();
const forgingScript = ForgeScript.withOneSignature(pubKeyHash);

const assetMetadata = {
  name: 'My NFT',
  image: 'ipfs://...',
  mediaType: 'image/png'
};

const tx = new Transaction({ initiator: wallet })
  .mintAsset(
    forgingScript,
    {
      assetName: 'MyNFT',
      assetQuantity: '1',
      metadata: assetMetadata,
      label: '721',
      recipient: wallet.getPaymentAddress()
    }
  );

const unsignedTx = await tx.build();
const signedTx = await wallet.signTx(unsignedTx);
const txHash = await wallet.submitTx(signedTx);
console.log('Minted:', txHash);
```

### Example: Query UTxOs
```typescript
import { BlockfrostProvider } from '@meshsdk/core';

const provider = new BlockfrostProvider('<PROJECT_ID>');

// Get UTxOs for address
const utxos = await provider.fetchAddressUTxOs(address);

// Get UTxOs at script address
const scriptUtxos = await provider.fetchAddressUTxOs(scriptAddress);

// Filter by asset
const nftUtxos = utxos.filter(utxo =>
  utxo.output.amount.some(a => a.unit.includes(policyId))
);
```

## Common patterns

### Error handling
```typescript
try {
  const txHash = await wallet.submitTx(signedTx);
  console.log('Success:', txHash);
} catch (error) {
  if (error.message.includes('UTxO')) {
    console.log('UTxO issue - refresh and retry');
  } else if (error.message.includes('collateral')) {
    console.log('Need ADA-only UTxO for collateral');
  }
}
```

### Wallet state management
```typescript
const { connected, connecting, disconnect, wallet, name } = useWallet();

// Check connection before operations
if (!connected) {
  throw new Error('Wallet not connected');
}

// Get network
const network = await wallet.getNetworkId();
// 0 = testnet, 1 = mainnet
```

## Safety / key handling
- Never request seed phrases
- Validate CIP-30 API availability
- Handle disconnects gracefully
- Show confirmation before signing

## References
- `shared/PRINCIPLES.md`
- [MeshJS documentation](https://meshjs.dev)
- [CIP-30 Wallet API](https://cips.cardano.org/cips/cip30/)
</file>

<file path="skills/plutus-v3-conway/reference/v3-notes.md">
# Plutus V3 + Conway notes

Focus areas:
- V3 introduces new script purposes beyond spending/minting (governance).
- Context packing differs from V2; ensure your validator extracts the right data.
- Reference scripts can change fee dynamics; record pparams with every tx build.
</file>

<file path="skills/plutus-v3-conway/SKILL.md">
---
name: plutus-v3-conway
description: "Plutus V3 under Conway: unified context, governance scripts, V2→V3 migration. Conceptual and practical guidance."
allowed-tools:
  - Read
user-invocable: true
---

# plutus-v3-conway

## When to use
- Migrating from Plutus V2 to V3
- Writing governance scripts (voting, proposing)
- Understanding Conway-era script changes

## Operating rules (must follow)
- Confirm target network supports Conway
- Test all governance scripts extensively on testnet
- Don't mix V2 and V3 mental models

## Key V3 changes

### 1. Unified context argument
```
V2: validator(datum, redeemer, context) → Bool
V3: validator(context) → ()  // datum/redeemer inside context
```

### 2. Datum is now optional
- For spending: datum can be Nothing if not needed
- Access via `ScriptContext.scriptInfo`

### 3. New script purposes
```
Spending      - spending UTxOs (existing)
Minting       - minting/burning tokens (existing)
Rewarding     - withdrawing rewards (existing)
Certifying    - stake certificates (existing)
Voting        - governance voting (NEW in V3)
Proposing     - governance proposals (NEW in V3)
```

### 4. Return type changes
- V2: Returns `Bool` (True/False)
- V3: Returns `()` (unit) - failure via error/trace

## V3 interface (Aiken)

### Spending validator
```aiken
validator my_validator {
  spend(
    datum: Option<MyDatum>,
    redeemer: MyRedeemer,
    _own_ref: OutputReference,
    tx: Transaction,
  ) {
    // Return () on success
    // Use expect/fail! for failure
    expect Some(d) = datum
    d.owner == get_signer(tx)
  }
}
```

### Governance validator
```aiken
validator governance {
  vote(
    redeemer: VoteRedeemer,
    voter: Voter,
    tx: Transaction,
  ) {
    // Validate voting logic
    True
  }

  propose(
    redeemer: ProposeRedeemer,
    tx: Transaction,
  ) {
    // Validate proposal logic
    True
  }
}
```

## Migration checklist (V2 → V3)

### 1. Update validator signature
```
// V2
fn spend(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool

// V3
fn spend(datum: Option<Datum>, redeemer: Redeemer, own_ref: OutputReference, tx: Transaction) -> ()
```

### 2. Handle optional datum
```aiken
// V3 - datum may be None
spend(datum: Option<Datum>, ...) {
  expect Some(d) = datum  // Fail if None when you need it
  // or
  when datum is {
    Some(d) -> handle_datum(d)
    None -> handle_no_datum()
  }
}
```

### 3. Update return logic
```aiken
// V2 - return Bool
if condition { True } else { False }

// V3 - return () or fail
if condition { () } else { fail @"Condition not met" }
// or use expect
expect condition
```

### 4. Script hash changes
- V3 scripts have different hashes than V2 equivalents
- Recalculate all script addresses
- Update any hardcoded references

## Examples

### Example: Simple V3 spending validator
```aiken
use aiken/collection/list
use cardano/transaction.{Transaction, OutputReference}

type Datum {
  owner: ByteArray,
}

type Redeemer {
  // empty
}

validator simple_lock {
  spend(
    datum: Option<Datum>,
    _redeemer: Redeemer,
    _own_ref: OutputReference,
    tx: Transaction,
  ) {
    expect Some(d) = datum
    list.has(tx.extra_signatories, d.owner)
  }
}
```

### Example: Governance voting script
```aiken
use cardano/transaction.{Transaction}
use cardano/governance.{Voter, ProposalProcedure}

validator dao_governance {
  vote(
    redeemer: Data,
    voter: Voter,
    tx: Transaction,
  ) {
    // Check voter is authorized
    // Check voting rules are followed
    True
  }

  propose(
    redeemer: Data,
    proposal: ProposalProcedure,
    tx: Transaction,
  ) {
    // Check proposer has required stake
    // Check proposal format
    True
  }
}
```

## Conway governance context

### DRep (Delegated Representative)
- Users can delegate voting power to DReps
- Scripts can act as DReps

### Constitutional Committee
- Multi-sig governance for protocol changes
- Scripts can be committee members

### Governance actions
- Parameter changes
- Hard fork initiation
- Treasury withdrawals
- Constitutional changes

## CLI flags for V3

```bash
# Build V3 script with Aiken
aiken build --plutus-version v3

# CLI transaction with V3 script
cardano-cli conway transaction build \
  --tx-in-script-file my_script_v3.plutus \
  ...
```

## Safety / key handling
- Governance scripts are high-stakes—test extensively
- V3 governance affects protocol parameters
- Verify all script hashes after migration
- Use preprod for testing governance flows

## References
- `shared/PRINCIPLES.md`
- [Plutus V3 CIP](https://cips.cardano.org)
- [Conway governance](https://docs.cardano.org)
- `aiken-smart-contracts` (for writing V3 validators)
</file>

<file path=".gitignore">
node_modules/*
.claude/settings.local.json
</file>

<file path="CHANGELOG.md">
# Changelog

All notable changes to Cardano Agent Skills are documented here.

## [v5] — 2026-02-05

**OpenClaw operators, Docker fallback, and exec approval infrastructure**

### Added
- **OpenClaw operator infrastructure** — `openclaw/` directory with exec-approvals template and documentation
- **Install & approval scripts** — `scripts/install.sh`, `scripts/install.ps1`, `scripts/apply-approvals.sh`, `scripts/apply-approvals.ps1`
- **`oc-safe.sh`** — single allowlisted entrypoint for OpenClaw exec dispatch; rejects shell metacharacters
- **`cardano-cli-operator` skill** — consolidated manual-only operator with OpenClaw exec dispatch frontmatter
- **Docker fallback wrappers** — `cardano-cli.sh` added to 7 cardano-cli skills; `hydra-node.sh` added to 3 hydra skills; `hydra-api.sh` added to hydra-head-operator
- **`docker-fallback.md`** reference doc added to 9 skills
- **`OPENCLAW_METADATA_SNIPPETS.md`** — reference doc for OpenClaw metadata format
- OpenClaw `metadata` line added to frontmatter of 12 SKILL.md files
- Docker fallback mode section added to body of 12 SKILL.md files

### Changed
- README.md rewritten with OpenClaw sections, architecture diagram, and updated skill count (20)
- `validate-skills.js` regex fixed for Windows CRLF line endings (`\r?\n`)

### Stats
- 44 files changed, 1424 insertions, 7 deletions
- Total skills: **20** (12 guidance + 8 operator)

---

## [v4] — 2026-02-04

**Devnet-in-a-box with deterministic rehearsal stack**

### Added
- **`cardano-devnet-in-a-box` skill** — full local devnet orchestrator
- **`devnet-in-a-box/` directory** with:
  - `run.sh` — main orchestrator (212 lines)
  - `scripts/rehearsal.sh` — deterministic rehearsal flow (488 lines)
  - `scripts/hydra_ws.py` — WebSocket test harness for Hydra (296 lines)
  - `scripts/smoke.sh` — quick smoke tests (46 lines)
  - `docker-compose.override.yml` — Hydra overlay config
  - `assets/always-true.plutus` and `assets/datum.json` — test fixtures

### Stats
- 10 files changed, 1421 insertions
- Total skills: **19**

---

## [v3.1] — 2026-01-27

**Aiken DEX security audit skill**

### Added
- **`aiken-dex-security-audit` skill** — guidance skill for auditing Aiken-based DEX validators
  - `references/audit-framework.md` — comprehensive audit methodology
  - `references/findings-severity-guide.md` — severity classification guide
  - `templates/audit-report.md` — structured audit report template
  - `templates/invariants-checklist.md` — validator invariants checklist
  - `templates/tx-shapes.md` — transaction shape analysis template
- **`aiken-dex-security-audit-operator` skill** — matching operator skill

### Fixed
- YAML frontmatter formatting in `aiken-dex-security-audit-operator` (85d241d)

### Stats
- 7 files changed, 384 insertions

---

## [v3] — 2026-01-25

**Major upgrade: self-calibrating, safe-by-design skill pack**

### Added
- **CI validation pipeline** — `.github/workflows/validate-skills.yml` + `validate-skills.js`
- **Operator skills** (manual-only, `disable-model-invocation: true`):
  - `cardano-cli-plutus-scripts-operator`
  - `cardano-cli-staking-operator`
  - `cardano-cli-transactions-operator`
  - `cardano-cli-wallets-operator`
  - `hydra-head-operator`
- **Source reference docs** — `reference/sources.md` for hydra-head and hydra-head-troubleshooter

### Changed
- All 10 existing guidance skills rewritten with:
  - Structured YAML frontmatter (`allowed-tools`, `context`, `user-invocable`)
  - Self-calibrating operating rules and safety disclaimers
  - Expanded templates, examples, and reference material
- README expanded with skill matrix, architecture notes, and installation instructions

### Stats
- 21 files changed, 2776 insertions, 391 deletions
- Total skills: **16** (11 guidance + 5 operator)

---

## [v2] — 2026-01-24

**Hydra and diagnostics skills**

### Added
- **`hydra-head` skill** — guidance for Hydra Head protocol operations
  - `reference/hydra-best-practices.md`
  - `templates/runbook.md`
- **`hydra-head-troubleshooter` skill** — Hydra diagnostics and incident response
  - `reference/probes.md`
  - `templates/incident-worksheet.md`
- **`cardano-cli-doctor` skill** — node health checks and environment diagnostics
  - `reference/doctor.md`
  - `scripts/cardano-cli-doctor.sh`

### Stats
- 9 files changed, 419 insertions
- Total skills: **10**

---

## [v1] — 2026-01-23

**Initial release: core Cardano CLI skills**

### Added
- **7 core skills**:
  - `aiken-smart-contracts` — Aiken project structure, validators, blueprints
  - `cardano-cli-plutus-scripts` — Plutus script transactions via CLI
  - `cardano-cli-staking` — stake key registration, delegation, rewards
  - `cardano-cli-transactions` — standard transaction building and submission
  - `cardano-cli-wallets` — key generation, addresses, UTxO management
  - `cardano-protocol-params` — protocol parameter queries and fee analysis
  - `meshjs-cardano` — MeshJS transaction building and wallet connectors
  - `plutus-v3-conway` — Plutus V3 / Conway era notes and migration guide
- **`shared/PRINCIPLES.md`** — cross-skill safety and design principles
- LICENSE and README

### Stats
- 19 files changed, 512 insertions
- Total skills: **7** (guidance only, listed as 8 including shared principles)
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2026 Flux Point Studios

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="OPENCLAW_METADATA_SNIPPETS.md">
# OpenClaw gating + install snippets

OpenClaw expects `metadata` to be a **single-line JSON object** in SKILL frontmatter. It uses `metadata.openclaw.requires.*` to gate skills and `metadata.openclaw.install` for one-click installs in the macOS UI.

See: https://docs.openclaw.ai/tools/skills

## Docker-first gating (recommended for this pack)
- For Cardano CLI skills: require `cardano-cli` OR `docker`
- For Hydra skills: require `hydra-node` OR `docker`
- For Aiken: require `aiken`

## Example installer spec (brew)
```yaml
metadata: {"openclaw":{"emoji":"...","requires":{"anyBins":["docker","cardano-cli"]},"install":[{"id":"brew","kind":"brew","formula":"colima docker docker-compose curl","bins":["colima","docker","docker-compose","curl"],"label":"Install Docker runtime (Colima) + Docker CLI + Compose + curl (brew)","os":["darwin","linux"]}]}}
```
</file>

<file path="README.md">
# Cardano Agent Skills

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Skills](https://img.shields.io/badge/skills-20-green.svg)](#available-skills)

A comprehensive set of **small, focused Agent Skills** for Cardano development. Self-calibrating, safe by design, and built for Claude Code, OpenClaw, Codex, Cursor, and other AI coding assistants.

## Features

- **Self-calibrating**: Skills detect your installed CLI version and adapt commands automatically
- **Safe by design**: Risky operations require explicit human invocation
- **Least privilege**: Each skill has restricted tool access appropriate to its function
- **Token-efficient**: Compact frontmatter with progressive detail loading
- **Docker fallback**: Every CLI skill includes a wrapper that falls back to Docker if the binary isn't installed locally
- **OpenClaw compatible**: Skills include OpenClaw metadata for gating, install, and deterministic exec dispatch

## Quick Install

### Option A: Vercel Skills CLI
```bash
npx skills add Flux-Point-Studios/cardano-agent-skills
```

### Option B: add-skill (supports skill selection)
```bash
# Install all skills
npx add-skill Flux-Point-Studios/cardano-agent-skills -a claude-code

# Install specific skills only
npx add-skill Flux-Point-Studios/cardano-agent-skills --skill cardano-cli-wallets --skill cardano-cli-transactions -a claude-code
```

### Option C: Install for both Claude Code + OpenClaw

```bash
# Project scope (recommended)
./scripts/install.sh --project --yes

# Global scope
./scripts/install.sh --global --yes
```

PowerShell:
```powershell
.\scripts\install.ps1 -Scope project -Yes
```

## Available Skills

### Core CLI Operations

| Skill | Description | Risk Level |
|-------|-------------|------------|
| `cardano-cli-doctor` | Diagnose CLI version, detect era-prefixed vs legacy syntax, produce compatibility report | Safe (read-only) |
| `cardano-cli-wallets` | Create/manage keys, addresses, UTxO checks, wallet dossier output | Safe (guidance) |
| `cardano-cli-wallets-operator` | Execute wallet operations (key generation, address building) | Manual invoke |
| `cardano-cli-transactions` | Build, sign, submit standard transactions (guidance + templates) | Safe (guidance) |
| `cardano-cli-transactions-operator` | Execute transaction builds and submits | Manual invoke |
| `cardano-cli-staking` | Stake key registration, delegation, rewards withdrawal (guidance) | Safe (guidance) |
| `cardano-cli-staking-operator` | Execute staking operations | Manual invoke |
| `cardano-cli-plutus-scripts` | Plutus script transactions: datums, redeemers, collateral (guidance) | Safe (guidance) |
| `cardano-cli-plutus-scripts-operator` | Execute script spends and submits | Manual invoke |
| `cardano-protocol-params` | Fetch and validate protocol parameters | Safe |

### Operator Skills (deterministic exec dispatch)

| Skill | Description | Risk Level |
|-------|-------------|------------|
| `cardano-cli-operator` | Consolidated manual-only operator for all Cardano CLI commands (OpenClaw exec dispatch) | Manual invoke |
| `hydra-head-operator` | Execute Hydra operations (init, commit, close) with OpenClaw exec dispatch | Manual invoke |

### Smart Contracts

| Skill | Description | Risk Level |
|-------|-------------|------------|
| `aiken-smart-contracts` | Aiken workflows: validators, building, blueprints, .plutus generation | Safe |
| `aiken-dex-security-audit` | Security audit playbook for Plutus V3 Aiken DEX contracts (guidance) | Safe (guidance) |
| `aiken-dex-security-audit-operator` | Execute security audit operations (findings, tests, reports) | Manual invoke |
| `plutus-v3-conway` | Plutus V3 under Conway: contexts, governance, V2->V3 migration | Safe |
| `meshjs-cardano` | MeshJS patterns: tx building, UTxO selection, wallet connectors | Safe |

### Hydra L2

| Skill | Description | Risk Level |
|-------|-------------|------------|
| `hydra-head` | Hydra Head best practices: setup, keys, peers, lifecycle (guidance) | Safe (guidance) |
| `hydra-head-troubleshooter` | Decision tree for Hydra issues: symptoms -> fixes -> verification | Safe |

### Local Development

| Skill | Description | Risk Level |
|-------|-------------|------------|
| `cardano-devnet-in-a-box` | One-command local rehearsal stack: cardano-node + hydra + ogmios + kupo | Safe (local only) |

## Architecture

```
cardano-agent-skills/
├── shared/
│   └── PRINCIPLES.md          # Common safety rules across all skills
├── skills/
│   ├── <skill-name>/
│   │   ├── SKILL.md           # Skill definition (frontmatter + instructions)
│   │   ├── reference/         # Deep-dive docs, patterns, examples
│   │   ├── scripts/           # Docker fallback wrappers
│   │   ├── templates/         # Copy-paste templates, worksheets
│   │   └── examples/          # Expected output samples
│   └── ...
├── openclaw/
│   ├── exec-approvals.template.json  # OpenClaw exec allowlist template
│   └── EXEC_APPROVALS.md            # How to apply approvals
├── scripts/
│   ├── oc-safe.sh             # Single allowlisted entrypoint for OpenClaw
│   ├── apply-approvals.sh     # Apply exec approvals (bash)
│   ├── apply-approvals.ps1    # Apply exec approvals (PowerShell)
│   ├── install.sh             # Install for claude-code + openclaw (bash)
│   └── install.ps1            # Install for claude-code + openclaw (PowerShell)
├── devnet-in-a-box/
│   ├── run.sh                 # Orchestration (up/down/smoke/rehearsal)
│   ├── docker-compose.override.yml  # Ogmios + Kupo services
│   ├── scripts/               # rehearsal.sh, smoke.sh, hydra_ws.py
│   └── assets/                # always-true.plutus, datum.json
├── .github/
│   └── workflows/
│       └── validate-skills.yml  # CI validation
└── README.md
```

## Skill Design Principles

### 1. Self-Calibrating (Dynamic Context)

Skills that interact with CLI tools use dynamic context injection to adapt to your installed version:

```yaml
---
name: cardano-cli-doctor
context:
  - "!cardano-cli version"
  - "!cardano-cli --help | head -40"
  - "!cardano-cli conway --help 2>&1 | head -20"
---
```

This means the skill reads your actual CLI output before giving advice--no more hallucinated flags.

### 2. Safe by Design (Playbook + Operator Split)

Risky operations are split into two skills:

- **Playbook** (`cardano-cli-transactions`): Auto-discoverable, provides guidance, templates, and explanations. Cannot execute commands.
- **Operator** (`cardano-cli-transactions-operator`): Manual invoke only (`disable-model-invocation: true`). Can execute commands with explicit confirmation.

### 3. Least Privilege (Tool Restrictions)

Each skill declares exactly which tools it can use:

```yaml
---
name: cardano-cli-doctor
allowed-tools:
  - Bash(cardano-cli:*)
  - Bash(which:*)
  - Read
---
```

### 4. Token Efficiency

- Frontmatter `description` is always loaded (keep it tight)
- SKILL.md body loads when relevant
- Reference files load on demand
- Target: SKILL.md under 500 lines

### 5. Docker Fallback

Every CLI skill includes a `scripts/cardano-cli.sh` or `scripts/hydra-node.sh` wrapper that:
- Uses the native binary if installed
- Falls back to the official Docker image otherwise
- Mounts the working directory and node socket automatically

## OpenClaw Operator Skills

### Deterministic Exec Dispatch

Operator skills (`cardano-cli-operator`, `hydra-head-operator`) use OpenClaw's **command-dispatch: tool** mode to route commands directly to the **Exec Tool** without model invocation. This means:

- You type the command, it runs exactly what you typed
- No model hallucination of flags or parameters
- Gated by OpenClaw's exec approvals system

### Allowlist-Safe Wrapper

Use `scripts/oc-safe.sh` as a single allowlisted entrypoint in `security=allowlist` mode:

```bash
# Cardano CLI via oc-safe
./scripts/oc-safe.sh cardano version
./scripts/oc-safe.sh cardano query tip --mainnet

# Hydra via oc-safe
./scripts/oc-safe.sh hydra --help
./scripts/oc-safe.sh hydra-api 4001 head
```

### OpenClaw Fast-Secure Setup

```bash
# Apply exec approvals template
./scripts/apply-approvals.sh --local

# Preview changes without applying
./scripts/apply-approvals.sh --local --dry-run
```

Then in OpenClaw chat:

```text
/exec host=gateway security=allowlist ask=on-miss
```

See `openclaw/EXEC_APPROVALS.md` for full details.

## Devnet-in-a-Box (Local Cardano + Hydra + Ogmios + Kupo)

Folder: `devnet-in-a-box/`

Run deterministic green/red rehearsal:

```bash
cd devnet-in-a-box
./run.sh rehearsal
```

See `devnet-in-a-box/README.md` for full setup guide.

## Version Compatibility

Skills are tested against:
- `cardano-cli` 10.x+ (Conway era, era-prefixed commands)
- `cardano-node` 10.x+
- `hydra-node` 0.20.x+
- `aiken` 1.1.x+

The `cardano-cli-doctor` skill will detect your version and recommend the appropriate command style.

## Contributing

1. Fork the repo
2. Add/modify skills following the structure above
3. Ensure SKILL.md has valid frontmatter
4. Run validation: `npm run validate` (if available) or check CI
5. Submit PR

### Skill Naming Rules

- Lowercase with hyphens only
- Max 64 characters
- No reserved words (`claude`, `anthropic`, `skill`)
- Unique across the repo

## License

MIT - See [LICENSE](LICENSE)

## Links

- [Skills.sh](https://skills.sh) - Skill discovery and leaderboard
- [Claude Code Skills Docs](https://code.claude.com/docs/en/skills)
- [hydra.family](https://hydra.family) - Hydra Head documentation
- [Cardano Docs](https://docs.cardano.org)

---

Built by [Flux Point Studios](https://fluxpointstudios.com)
</file>

</files>
