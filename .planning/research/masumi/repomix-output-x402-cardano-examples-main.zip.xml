This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.
URL: https://github.com/masumi-network/x402-cardano-examples

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
x402-cardano-examples-main/
  facilitator_server/
    app.py
    requirements.txt
  resource_server/
    static/
      app.js
      styles.css
    templates/
      index.html
    app.py
    requirements.txt
  .env.example
  .gitignore
  README.md
  requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="x402-cardano-examples-main/facilitator_server/app.py">
from __future__ import annotations

import base64
import hashlib
import json
import os
import time
from typing import Any, Dict, Tuple

import requests
from flask import Flask, jsonify, request


def load_env_from_file(path: str = ".env"):
    try:
        if not os.path.exists(path):
            return
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" in line:
                    k, v = line.split("=", 1)
                    os.environ.setdefault(k.strip(), v.strip())
    except Exception:
        pass


load_env_from_file()

app = Flask(__name__)


BLOCKFROST_PROJECT_ID = os.environ.get("BLOCKFROST_PROJECT_ID")
NETWORK = os.environ.get("NETWORK", "cardano-mainnet")
BF_BASE = (
    "https://cardano-mainnet.blockfrost.io/api/v0"
    if NETWORK == "cardano-mainnet"
    else "https://cardano-preprod.blockfrost.io/api/v0"
)


def decode_x_payment_b64(x_payment_b64: str) -> Dict[str, Any]:
    raw = base64.b64decode(x_payment_b64)
    return json.loads(raw.decode("utf-8"))


def submit_tx_blockfrost(raw_cbor: bytes) -> Tuple[bool, str | None, str | None]:
    if not BLOCKFROST_PROJECT_ID:
        return False, None, "BLOCKFROST_PROJECT_ID not set"
    url = f"{BF_BASE}/tx/submit"
    headers = {"project_id": BLOCKFROST_PROJECT_ID, "Content-Type": "application/cbor"}
    r = requests.post(url, headers=headers, data=raw_cbor, timeout=30)
    if r.ok:
        return True, r.text.strip().strip('"'), None
    try:
        err = r.json()
    except Exception:
        err = {"status": r.status_code, "body": r.text}
    # Map to x402 error code
    return False, None, "invalid_transaction_state"


def check_tx_output(tx_hash: str, pay_to: str, unit: str, min_amount: int, wait_seconds: int = 20) -> bool:
    if not BLOCKFROST_PROJECT_ID:
        return False
    headers = {"project_id": BLOCKFROST_PROJECT_ID}
    # Poll for UTxOs becoming available
    deadline = time.time() + wait_seconds
    while time.time() < deadline:
        utx_url = f"{BF_BASE}/txs/{tx_hash}/utxos"
        r = requests.get(utx_url, headers=headers, timeout=15)
        if r.status_code == 404:
            time.sleep(1.0)
            continue
        if not r.ok:
            time.sleep(1.0)
            continue
        data = r.json()
        for out in data.get("outputs", []):
            if out.get("address") != pay_to:
                continue
            # amounts is a list of {unit, quantity}
            for amt in out.get("amount", []):
                if amt.get("unit") == unit and int(amt.get("quantity", 0)) >= int(min_amount):
                    return True
        time.sleep(1.0)
    return False


@app.post("/verify")
def verify():
    body = request.get_json(silent=True) or {}
    x_payment_b64 = body.get("x_payment_b64")
    reqs = body.get("payment_requirements") or {}
    try:
        print("[/verify] body keys=", list((body or {}).keys()))
    except Exception:
        pass
    try:
        x_payment = decode_x_payment_b64(x_payment_b64)
    except Exception as e:
        try:
            print("[/verify] decode error:", e)
        except Exception:
            pass
        return jsonify({"isValid": False, "invalidReason": "invalid_payload"}), 200

    # Basic checks
    if x_payment.get("x402Version") != 1:
        return jsonify({"isValid": False, "invalidReason": "invalid_x402_version"}), 200
    if x_payment.get("scheme") != "exact":
        return jsonify({"isValid": False, "invalidReason": "invalid_scheme"}), 200
    net = x_payment.get("network")
    if net not in {"cardano", "cardano-mainnet"}:
        return jsonify({"isValid": False, "invalidReason": "invalid_network"}), 200

    payload = x_payment.get("payload") or {}
    tx_b64 = payload.get("transaction")
    if not isinstance(tx_b64, str) or not tx_b64.strip():
        return jsonify({"isValid": False, "invalidReason": "invalid_payload"}), 200

    # Decode base64 to ensure it is valid CBOR payload; parsing of outputs happens post-submit.
    try:
        base64.b64decode(tx_b64)
    except Exception:
        try:
            print("[/verify] tx base64 invalid")
        except Exception:
            pass
        return jsonify({"isValid": False, "invalidReason": "invalid_payload"}), 200
    except Exception:
        try:
            print("[/verify] unexpected verify error")
        except Exception:
            pass
        return jsonify({"isValid": False, "invalidReason": "unexpected_verify_error"}), 200

    return jsonify({"isValid": True}), 200


SUBMITTED: dict[str, str] = {}


@app.post("/settle")
def settle():
    body = request.get_json(silent=True) or {}
    x_payment_b64 = body.get("x_payment_b64")
    reqs = body.get("payment_requirements") or {}
    try:
        print("[/settle] body keys=", list((body or {}).keys()))
    except Exception:
        pass

    try:
        accepts = (reqs.get("accepts") or [])[:1]
    except Exception:
        accepts = []
    if not accepts:
        return jsonify({"success": False, "errorReason": "invalid_payment_requirements", "transaction": ""}), 200
    acc = accepts[0]
    pay_to = acc.get("payTo")
    policy = (acc.get("asset") or "").lower()
    name_hex = ((acc.get("extra") or {}).get("assetNameHex") or "").lower()
    unit = (policy + name_hex)
    min_amt = int(acc.get("maxAmountRequired") or 0)

    try:
        x_payment = decode_x_payment_b64(x_payment_b64)
        tx_b64 = (x_payment.get("payload") or {}).get("transaction")
        raw_cbor = base64.b64decode(tx_b64)
    except Exception:
        try:
            print("[/settle] decode error")
        except Exception:
            pass
        return jsonify({"success": False, "errorReason": "invalid_payload", "transaction": ""}), 200

    # Compute a stable key for idempotency on repeated /settle calls
    key = hashlib.sha256(raw_cbor).hexdigest()

    # If we've seen this exact tx before, don't resubmit — just report current status quickly
    if key in SUBMITTED:
        tx_hash = SUBMITTED[key]
        ok_now = check_tx_output(tx_hash, pay_to, unit, min_amt, wait_seconds=1)
        if ok_now:
            return jsonify({"success": True, "transaction": tx_hash, "network": NETWORK}), 200
        return jsonify({"success": False, "errorReason": "invalid_transaction_state", "transaction": tx_hash, "pending": True}), 202

    # First time: submit only and return pending quickly (let client poll /status)
    ok, tx_hash, err = submit_tx_blockfrost(raw_cbor)
    if not ok:
        try:
            print("[/settle] submit failed: ", err)
        except Exception:
            pass
        return jsonify({"success": False, "errorReason": err or "invalid_transaction_state", "transaction": ""}), 200
    SUBMITTED[key] = tx_hash
    return jsonify({"success": False, "errorReason": "invalid_transaction_state", "transaction": tx_hash, "pending": True}), 202


@app.get("/supported")
def supported():
    return jsonify({"kinds": [{"x402Version": 1, "scheme": "exact", "network": NETWORK}]})


@app.post("/status")
def status():
    body = request.get_json(silent=True) or {}
    tx = body.get("transaction")
    reqs = body.get("payment_requirements") or {}
    accepts = (reqs.get("accepts") or [])[:1]
    if not tx or not accepts:
        return jsonify({"success": False, "errorReason": "invalid_payment_requirements", "transaction": tx or ""}), 200
    acc = accepts[0]
    pay_to = acc.get("payTo")
    policy = (acc.get("asset") or "").lower()
    name_hex = ((acc.get("extra") or {}).get("assetNameHex") or "").lower()
    unit = (policy + name_hex)
    min_amt = int(acc.get("maxAmountRequired") or 0)
    try:
        ok = check_tx_output(tx, pay_to, unit, min_amt, wait_seconds=1)
        if ok:
            return jsonify({"success": True, "transaction": tx, "network": NETWORK}), 200
        return jsonify({"success": False, "errorReason": "invalid_transaction_state", "transaction": tx, "pending": True}), 202
    except Exception:
        return jsonify({"success": False, "errorReason": "unexpected_settle_error", "transaction": tx}), 200


@app.get("/health")
def health():
    return jsonify({"ok": True}), 200


if __name__ == "__main__":
    port = int(os.environ.get("PORT", "5051"))
    app.run(host="0.0.0.0", port=port, debug=True)
</file>

<file path="x402-cardano-examples-main/facilitator_server/requirements.txt">
Flask>=3.0,<4
requests>=2.31
cbor2>=5.6
</file>

<file path="x402-cardano-examples-main/resource_server/static/app.js">
// Minimal front-end for x402 demo

const statusEl = document.getElementById('status');
const contentEl = document.getElementById('content');
const connectBtn = document.getElementById('connectBtn');
const payBtn = document.getElementById('payBtn');
const walletSelect = document.getElementById('walletSelect');
const rescanBtn = document.getElementById('rescanBtn');
const reqSummaryEl = document.getElementById('reqSummary');
const addrBox = document.getElementById('addrBox');
const payProgress = document.getElementById('payProgress');
const payProgressInner = payProgress ? payProgress.querySelector('div') : null;
const progressLabel = document.getElementById('progressLabel');
// Step elements
const stepIntro = document.getElementById('stepIntro');
const stepReqs = document.getElementById('stepReqs');
const stepConnect = document.getElementById('stepConnect');
const stepPay = document.getElementById('stepPay');
const stepPending = document.getElementById('stepPending');
const stepSuccess = document.getElementById('stepSuccess');
const waitProgress = document.getElementById('waitProgress');
const waitProgressInner = waitProgress ? waitProgress.querySelector('div') : null;
const waitLabel = document.getElementById('waitLabel');
const txBox = document.getElementById('txBox');
const checkNowBtn = document.getElementById('checkNowBtn');
const txExplorerLink = document.getElementById('txExplorerLink');
const successExplorerLink = document.getElementById('successExplorerLink');
const introNextBtn = document.getElementById('introNextBtn');
const reqBackBtn = document.getElementById('reqBackBtn');
const reqNextBtn = document.getElementById('reqNextBtn');
const connectBackBtn = document.getElementById('connectBackBtn');
const connectNextBtn = document.getElementById('connectNextBtn');

let connected = false;
let walletId = null; // CIP-30 provider key (e.g., 'nami', 'eternl')
let walletApi = null; // CIP-30 enabled API instance

let debugLines = [];
function appendDebug(msg) {
  try {
    debugLines.push(String(msg));
    if (debugLines.length > 200) debugLines.shift();
  } catch (_) {}
}

const LABELS = {
  nami: 'Nami',
  eternl: 'Eternl',
  lace: 'Lace',
  gerowallet: 'Gero',
  flint: 'Flint',
  yoroi: 'Yoroi',
  vespr: 'Vespr',
  typhoncip30: 'Typhon',
  begin: 'Begin',
};

function listWalletProviders() {
  const providers = [];
  if (window.cardano && typeof window.cardano === 'object') {
    for (const [key, val] of Object.entries(window.cardano)) {
      if (val && typeof val.enable === 'function') {
        const label = (val.name && String(val.name)) || LABELS[key] || key;
        providers.push({ id: key, label });
      }
    }
  }
  // Deterministic order by label
  providers.sort((a, b) => a.label.localeCompare(b.label));
  return providers;
}

function populateWalletSelect() {
  const providers = listWalletProviders();
  walletSelect.innerHTML = '';
  if (providers.length === 0) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.disabled = true;
    opt.selected = true;
    opt.textContent = 'No wallets detected';
    walletSelect.appendChild(opt);
    hide(connectBtn);
    hide(payBtn);
    return;
  }

  const saved = localStorage.getItem('x402.walletId');
  providers.forEach((p, idx) => {
    const opt = document.createElement('option');
    opt.value = p.id;
    opt.textContent = p.label;
    if (saved ? p.id === saved : idx === 0) opt.selected = true;
    walletSelect.appendChild(opt);
  });

  connectBtn.textContent = 'Connect Cardano Wallet';
  show(connectBtn);
}

// Example base64 Cardano transaction (from prompt)
const EXAMPLE_TX_B64 =
  "AAAIAQDi1HwjSnS6M+WGvD73iEyUY2FRKNj0MlRp7+3SHZM3xCvMdB0AAAAAIFRgPKOstGBLCnbcyGoOXugUYAWwVzNrpMjPCzXK4KQWAQCMoE29VLGwftex8rhIlOuFLFNfxLIJlHqGXoXA8hx6l+LMdB0AAAAAIHbPucTRIEWgO6lzqukswPZ6i72IHEKK5LyM1l9HJNZNAQBthSeHDVK8Xr5/zp3JMZPLtG5uAoVgedTA4pEnp+h8qUlUzRwAAAAAIACH0swYW/QfGCFczGnjAVPHPqZrQE5vfvJr36i6KVEFAQAC7W4K5vCwB+nprjxcNlLiOQ7SIIfyCZjmj2qSis2iTsCuzBwAAAAAIAkSUkXOoeq52GNdhwpbs+jZqqrqPdmiN3oPw5EzDIanAQAIyFNGWD6OxiFIyXSxrNEcFG0npm+nImk6InUssXb1EZgx1hwAAAAAILhsjmMKyM0n75Cd7z6ufH2LNhOMibFOGhNlLgV5RFuEAQC+Mh4kGkLwrw/11729oUQnt3xOmOreE6PcnuN6M68ZBcCuzBwAAAAAIO2PQhSSqSAawCbRr005lfjBgFOqIHo4zb2GcQ/WCxAlAAgA+QKVAAAAAAAgjiAHD0X4HNSdVPpJtf2E6W2uRc8kbvCHYkgEQ1B+w1MDAwEAAAUBAQABAgABAwABBAABBQACAQAAAQEGAAEBAgEAAQcAHrfFfj8r0Pxsudz/0UPqlX5NmPgFw1hzP3be4GZ/4LEB5XXrONxGw0qOUsq3yNKeUhOCOgCIwaa4pswKaer66EKqPGwdAAAAACBrOIN4poutFUmHfB6FbFJu8GgXoPPTGQWREqFpPfvO1B63xX4/K9D8bLnc/9FD6pV+TZj4BcNYcz923uBmf+Cx7gIAAAAAAABg4xYAAAAAAAA=";

function setStatus(text) {
  statusEl.textContent = text;
}

function show(element) {
  element.style.display = '';
}

function hide(element) {
  element.style.display = 'none';
}

let lastRequirements = null;
let pendingTxId = null;
let pendingTimer = null;
let lastEncodedPaymentHeader = null;

function showStep(which) {
  stepIntro.style.display = which === 'intro' ? '' : 'none';
  stepReqs.style.display = which === 'reqs' ? '' : 'none';
  stepConnect.style.display = which === 'connect' ? '' : 'none';
  stepPay.style.display = which === 'pay' ? '' : 'none';
  if (typeof stepPending !== 'undefined' && stepPending) {
    stepPending.style.display = which === 'pending' ? '' : 'none';
  }
  stepSuccess.style.display = which === 'success' ? '' : 'none';
  if (which === 'pay') {
    show(payBtn);
  } else {
    hide(payBtn);
  }
}

function updateProgress(pct, label) {
  try {
    if (payProgress) payProgress.style.display = '';
    if (payProgressInner) payProgressInner.style.width = `${Math.max(0, Math.min(100, pct))}%`;
    if (progressLabel) {
      progressLabel.style.display = '';
      if (label) progressLabel.textContent = label;
    }
  } catch (_) {}
}

function hideProgress() {
  try {
    if (payProgress) payProgress.style.display = 'none';
    if (progressLabel) progressLabel.style.display = 'none';
    if (payProgressInner) payProgressInner.style.width = '0%';
  } catch (_) {}
}

function formatQty(units, decimals) {
  try {
    const u = BigInt(units);
    const d = Number(decimals || 0);
    if (d === 0) return u.toString();
    const s = u.toString().padStart(d + 1, '0');
    const head = s.slice(0, -d);
    const tail = s.slice(-d).replace(/0+$/, '');
    return tail ? `${head}.${tail}` : head;
  } catch (_) {
    return units.toString();
  }
}

function updateReqSummary() {
  if (!lastRequirements || !lastRequirements.accepts || !lastRequirements.accepts.length) return;
  const acc = lastRequirements.accepts[0];
  const payTo = acc.payTo;
  const policyId = (acc.asset || '').slice(0, 8) + '…';
  const decimals = (acc.extra && acc.extra.decimals) || 0;
  const qtyUnits = BigInt(acc.maxAmountRequired || '0');
  const qtyHuman = formatQty(qtyUnits, decimals);
  if (reqSummaryEl) {
    reqSummaryEl.textContent = `Now the 402 Status Message of this Website has given us the following instructions: Pay ${qtyHuman} USDM to ${payTo} on Cardano Mainnet). In the next step we will now construct this transction for you.`;
  }
  try { if (contentEl) contentEl.textContent = JSON.stringify(lastRequirements, null, 2); } catch (_) {}
}

function explorerUrlFor(network, tx) {
  try {
    const n = (network || '').toLowerCase();
    if (n.includes('preprod')) return `https://preprod.cardanoscan.io/transaction/${tx}`;
    return `https://cardanoscan.io/transaction/${tx}`;
  } catch (_) {
    return `https://cardanoscan.io/transaction/${tx}`;
  }
}

async function fetchResource(withPayment = false, xPaymentB64 = null) {
  setStatus('Requesting resource...');
  contentEl.textContent = '';

  const headers = {};
  if (withPayment) {
    if (!xPaymentB64) {
      setStatus('Payment payload missing.');
      return;
    }
    headers['X-PAYMENT'] = xPaymentB64;
    if (addrBox && addrBox.value) headers['X-PAYER-ADDRESS'] = addrBox.value;
    lastEncodedPaymentHeader = xPaymentB64;
  }

  const res = await fetch('/', {
    method: 'GET',
    headers,
  });

  if (res.ok && res.status === 200) {
    const data = await res.json();
    setStatus('Access granted.');
    hide(connectBtn);
    hide(payBtn);
    contentEl.textContent = JSON.stringify(data, null, 2);
    showStep('success');

    const payRespHeader = res.headers.get('X-PAYMENT-RESPONSE');
    if (payRespHeader) {
      try {
        const decoded = JSON.parse(decodeURIComponent(escape(atob(payRespHeader))));
        contentEl.textContent += '\n\nX-PAYMENT-RESPONSE: ' + JSON.stringify(decoded, null, 2);
        const txHash = decoded && decoded.transaction;
        const url = explorerUrlFor((lastRequirements && lastRequirements.accepts && lastRequirements.accepts[0] && lastRequirements.accepts[0].network) || 'cardano-mainnet', txHash);
        if (successExplorerLink && txHash) {
          successExplorerLink.href = url;
          successExplorerLink.style.display = '';
        }
      } catch (_) {
        // ignore
      }
    }
    return;
  }

  // Pending settlement
  if (res.status === 202) {
    try {
      const info = await res.json();
      pendingTxId = info.transaction || null;
      updateProgress(60, 'Waiting for on-chain settlement…');
      setStatus('Pending settlement…');
      if (pendingTimer) clearInterval(pendingTimer);
      const retry = Math.max(5, Number(info.retryAfterSeconds || 10));
      // Switch to visual pending step
      showStep('pending');
      if (txBox) txBox.value = pendingTxId || '';
      let tick = 0;
      if (waitProgressInner) waitProgressInner.style.width = '0%';
      function updateWait() {
        tick = (tick + 1) % retry;
        const pct = Math.floor((tick / retry) * 100);
        if (waitProgressInner) waitProgressInner.style.width = `${pct}%`;
        if (waitLabel) waitLabel.textContent = `Checking in ${retry - tick}s…`;
      }
      updateWait();
      const uiTimer = setInterval(updateWait, 1000);
      pendingTimer = setInterval(async () => {
        try {
          if (!pendingTxId) return;
          const s = await fetch(`/?tx=${encodeURIComponent(pendingTxId)}`, {
            headers: addrBox && addrBox.value ? { 'X-PAYER-ADDRESS': addrBox.value } : {},
          });
          if (s.status === 200) {
            clearInterval(pendingTimer);
            pendingTimer = null;
            clearInterval(uiTimer);
            const data = await s.json();
            setStatus('Access granted.');
            hide(connectBtn);
            hide(payBtn);
            contentEl.textContent = JSON.stringify(data, null, 2);
            showStep('success');
          } else if (s.status === 202) {
            updateProgress(75, 'Still pending…');
          }
        } catch (_) {}
      }, retry * 1000);
      if (checkNowBtn) {
        checkNowBtn.onclick = async () => {
          try {
            if (!pendingTxId) return;
            const s = await fetch(`/?tx=${encodeURIComponent(pendingTxId)}`, {
              headers: addrBox && addrBox.value ? { 'X-PAYER-ADDRESS': addrBox.value } : {},
            });
            if (s.status === 200) {
              clearInterval(pendingTimer);
              pendingTimer = null;
              const data = await s.json();
              setStatus('Access granted.');
              contentEl.textContent = JSON.stringify(data, null, 2);
              showStep('success');
            }
          } catch (_) {}
        };
      }
    } catch (_) {}
    return;
  }

  if (res.status === 402) {
    let info = null;
    try {
      info = await res.clone().json();
    } catch (_) {
      // If server returned HTML page with embedded requirements
      if (window.__x402Requirements) info = window.__x402Requirements;
    }
    lastRequirements = info || lastRequirements || null;
    const err = res.headers.get('X-PAYMENT-ERROR');
    setStatus('Payment required' + (err ? `: ${err}` : '.'));
    show(connectBtn);
    if (info) updateReqSummary();
    return;
  }

  setStatus(`Error: ${res.status}`);
  try {
    const txt = await res.text();
    contentEl.textContent = txt;
  } catch (_) {}
}

async function tryConnectWallet() {
  const selected = walletSelect.value;
  const providers = listWalletProviders();
  const hasSelected = providers.some((p) => p.id === selected);

  if (hasSelected) {
    try {
      walletApi = await window.cardano[selected].enable();
      connected = true;
      walletId = selected;
      localStorage.setItem('x402.walletId', walletId);
      const label = providers.find((p) => p.id === selected)?.label || selected;
      setStatus(`Connected: ${label}`);
      // Show connected address and enable next step
      try {
        const lib = await getLucidLib();
        const C = lib.C;
        const changeHex = await walletApi.getChangeAddress();
        const bech = C.Address.from_bytes(hexToBytes(changeHex)).to_bech32(undefined);
        if (addrBox) addrBox.value = bech;
        if (connectNextBtn) connectNextBtn.disabled = false;
      } catch (_) {}
    } catch (e) {
      connected = false;
      setStatus('Failed to connect.');
      hide(payBtn);
    }
  }
}

connectBtn.addEventListener('click', tryConnectWallet);
rescanBtn.addEventListener('click', () => {
  statusEl.textContent = 'Scanning for wallets...';
  rescanWallets();
});
// Step navigation
document.getElementById('introNextBtn')?.addEventListener('click', () => showStep('reqs'));
document.getElementById('reqBackBtn')?.addEventListener('click', () => showStep('intro'));
document.getElementById('reqNextBtn')?.addEventListener('click', () => showStep('connect'));
document.getElementById('connectBackBtn')?.addEventListener('click', () => showStep('reqs'));
document.getElementById('connectNextBtn')?.addEventListener('click', () => showStep('pay'));

// Initial setup
populateWalletSelect();
// Try again shortly in case wallets inject late
setTimeout(populateWalletSelect, 300);
setTimeout(populateWalletSelect, 1200);
if (window.__x402Requirements) {
  lastRequirements = window.__x402Requirements;
  setStatus('Payment required.');
  updateReqSummary();
  show(connectBtn);
} else {
  // Fallback: try fetching the resource to get requirements
  fetchResource();
}
showStep('intro');

// Mobile notice: if narrow viewport, show the banner (CSS also triggers it).
try {
  if (window.innerWidth < 768) {
    const mw = document.getElementById('mobileWarning');
    if (mw) mw.style.display = 'flex';
  }
} catch (_) {}

// ------------- Build a real tx using Lucid + CIP-30 -------------

function hexToBytes(hex) {
  if (hex.startsWith('0x')) hex = hex.slice(2);
  const out = new Uint8Array(hex.length / 2);
  for (let i = 0; i < out.length; i++) {
    out[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return out;
}

function bytesToBase64(bytes) {
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}

// Try to load lucid-evolution first; fall back to lucid-cardano web bundle if unavailable.
let __lucidLib = null;
async function loadLucidModule() {
  const urls = [
    'https://cdn.jsdelivr.net/npm/@lucid-evolution/lucid/web/mod.js?module',
    'https://unpkg.com/@lucid-evolution/lucid/web/mod.js?module',
    'https://esm.sh/@lucid-evolution/lucid?target=es2020',
    'https://unpkg.com/lucid-cardano/web/mod.js?module',
  ];
  for (const u of urls) {
    try {
      const m = await import(u);
      if (m && (m.Lucid || (m.default && m.default.Lucid))) return m;
    } catch (_) {}
  }
  throw new Error('Failed to load Lucid library');
}

async function getLucidLib() {
  if (__lucidLib) return __lucidLib;
  const mod = await loadLucidModule();
  __lucidLib = {
    Lucid: mod.Lucid || (mod.default && mod.default.Lucid),
    Blockfrost: mod.Blockfrost || (mod.default && mod.default.Blockfrost),
    C: (mod.C || mod.CSL || (mod.default && (mod.default.C || mod.default.CSL))),
  };
  return __lucidLib;
}

async function buildPaymentTxB64() {
  if (!lastRequirements || !lastRequirements.accepts || !lastRequirements.accepts.length) {
    throw new Error('No payment requirements available');
  }

  const acc = lastRequirements.accepts[0];
  const payTo = acc.payTo;
  const policyId = (acc.asset || '').toLowerCase(); // policy id
  const assetNameHex = ((acc.extra && acc.extra.assetNameHex) || '0014df105553444d').toLowerCase();
  let unit = (policyId + assetNameHex).toLowerCase();
  const qtyStr = acc.maxAmountRequired || '5000000000';
  const qty = BigInt(qtyStr);

  setStatus('Preparing transaction (Lucid + Blockfrost)...');
  updateProgress(10, 'Initializing…');
  appendDebug(`policyId=${policyId}`);
  appendDebug(`assetNameHex=${assetNameHex}`);
  appendDebug(`target unit=${unit}`);
  appendDebug(`required qty=${qtyStr}`);

  // Dynamically import Lucid (web bundle includes Blockfrost provider and CSL as export `C`)
  const { Lucid, Blockfrost, C } = await getLucidLib();
  const network = 'Mainnet';
  updateProgress(20, 'Loading libraries…');

  const bfKey = (window.__BF_PROJECT_ID || '').trim();
  if (!bfKey) throw new Error('Blockfrost API key missing (server config).');
  const bf = new Blockfrost('https://cardano-mainnet.blockfrost.io/api/v0', bfKey);
  const lucid = await Lucid.new(bf, network);
  updateProgress(30, 'Setting wallet…');

  const providers = listWalletProviders();
  const chosen = providers.find((p) => p.id === walletSelect.value);
  if (!chosen) {
    throw new Error('No wallet selected');
  }

  // Let Lucid use the enabled CIP-30 API
  if (!walletApi) {
    walletApi = await window.cardano[chosen.id].enable();
  }
  lucid.selectWallet(walletApi);

  // Guard network at wallet level to Mainnet (1)
  if (!walletApi) {
    // Ensure we have an enabled API instance for network check
    walletApi = await window.cardano[chosen.id].enable();
  }
  const nwId = await walletApi.getNetworkId();
  if (nwId !== 1) throw new Error('Switch wallet to Mainnet');
  updateProgress(40, 'Gathering UTxOs…');

  // Aggregate UTxOs across all wallet addresses to avoid InputsExhausted
  async function getWalletBech32Addresses() {
    const addrs = new Set();
    const used = await walletApi.getUsedAddresses();
    const unused = await walletApi.getUnusedAddresses();
    const change = await walletApi.getChangeAddress();
    const all = [...(used || []), ...(unused || []), ...(change ? [change] : [])];
    const C_ = C || CSL;
    for (const hex of all) {
      try {
        const bech = C_.Address.from_bytes(hexToBytes(hex)).to_bech32(undefined);
        addrs.add(bech);
      } catch (_) {}
    }
    return Array.from(addrs);
  }

  const addresses = await getWalletBech32Addresses();
  if (addresses.length === 0) throw new Error('No wallet addresses');
  appendDebug(`addresses[${addresses.length}]:`);
  addresses.slice(0, 5).forEach((a, i) => appendDebug(` addr[${i}]=${a}`));

  let allUtxos = [];
  for (const a of addresses) {
    const utx = await lucid.utxosAt(a);
    allUtxos.push(...utx);
  }
  if (!allUtxos.length) throw new Error('No UTxOs found for wallet');
  appendDebug(`utxos found=${allUtxos.length}`);
  updateProgress(55, 'Selecting inputs…');

  // Tally assets by unit and highlight those under the target policy
  const policyUnits = new Map(); // unit -> { total, utxos }
  for (const u of allUtxos) {
    for (const [k, v] of Object.entries(u.assets || {})) {
      if (k === 'lovelace') continue;
      const key = String(k).toLowerCase();
      const val = typeof v === 'bigint' ? v : BigInt(v);
      const rec = policyUnits.get(key) || { total: 0n, utxos: 0 };
      rec.total += val;
      rec.utxos += 1;
      policyUnits.set(key, rec);
    }
  }
  const byPolicy = [...policyUnits.entries()].filter(([k]) => k.startsWith(policyId));
  byPolicy.sort((a, b) => Number(b[1].total - a[1].total));
  appendDebug(`assets under policy (${byPolicy.length} units)`);
  byPolicy.slice(0, 10).forEach(([k, { total, utxos }], i) => {
    appendDebug(` unit[${i}]=${k.slice(policyId.length)} total=${total.toString()} utxos=${utxos}`);
  });

  const tokenUtxos = allUtxos
    .filter((u) => BigInt((u.assets && u.assets[unit]) || 0) > 0n)
    .sort((a, b) => Number(BigInt(((b.assets || {})[unit]) || 0) - BigInt(((a.assets || {})[unit]) || 0)));

  let tokenSelected = [];
  let tokenSum = 0n;
  for (const u of tokenUtxos) {
    if (tokenSum >= qty) break;
    tokenSelected.push(u);
    tokenSum += BigInt((u.assets && u.assets[unit]) || 0);
  }
  if (tokenSum < qty) {
    // Fallback: attempt best unit under this policy by total amount
    if (byPolicy.length > 0) {
      const bestUnit = byPolicy[0][0];
      if (bestUnit !== unit) {
        appendDebug(`fallback: trying discovered unit ${bestUnit}`);
        const alt = allUtxos
          .filter((u) => BigInt(((u.assets || {})[bestUnit]) || 0) > 0n)
          .sort((a, b) => Number(BigInt(((b.assets || {})[bestUnit]) || 0) - BigInt(((a.assets || {})[bestUnit]) || 0)));
        let altSel = [];
        let altSum = 0n;
        for (const u of alt) {
          if (altSum >= qty) break;
          altSel.push(u);
          altSum += BigInt(((u.assets || {})[bestUnit]) || 0);
        }
        appendDebug(`fallback sum for ${bestUnit} = ${altSum.toString()}`);
        if (altSum >= qty) {
          unit = bestUnit;
          tokenSelected = altSel;
          tokenSum = altSum;
        }
      }
    }
  }
  updateProgress(70, 'Building transaction…');
  if (tokenSum < qty) {
    appendDebug(`final tokenSum=${tokenSum.toString()} required=${qty.toString()}`);
    throw new Error('Wallet lacks required USDM on accessible addresses');
  }

  const seen = new Set(tokenSelected.map((u) => `${u.txHash}#${u.outputIndex}`));
  const adaCandidates = allUtxos
    .filter((u) => !seen.has(`${u.txHash}#${u.outputIndex}`))
    .sort((a, b) => Number(BigInt(b.assets.lovelace || 0n) - BigInt(a.assets.lovelace || 0n)));

  let selected = [...tokenSelected];
  let idx = 0;
  let lastErr = null;
  for (; idx <= adaCandidates.length; idx++) {
    try {
      const tx = await lucid
        .newTx()
        .collectFrom(selected)
        .payToAddress(payTo, { [unit]: qty, lovelace: 2_000_000n })
        .complete();
      updateProgress(85, 'Signing…');
      const signed = await tx.sign().complete();
      const cborHex = signed.toString();
      const b64 = bytesToBase64(hexToBytes(cborHex));
      updateProgress(95, 'Submitting…');
      return b64;
    } catch (e) {
      lastErr = e;
      const msg = (e && e.message) || String(e || '');
      if (!/InputsExhausted/i.test(msg)) throw e;
      if (idx < adaCandidates.length) {
        selected.push(adaCandidates[idx]);
        continue; // add more ADA and retry
      }
      throw e;
    }
  }
  throw lastErr || new Error('Failed to build transaction');
}

async function accessWithPayment() {
  try {
    setStatus('Building and signing transaction...');
    updateProgress(5, 'Starting…');
    const txB64 = await buildPaymentTxB64();
    const headerObj = {
      x402Version: 1,
      scheme: 'exact',
      network: 'cardano',
      payload: { transaction: txB64 },
    };
    const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(headerObj))));
    await fetchResource(true, encoded);
    hideProgress();
  } catch (e) {
    setStatus('Payment failed: ' + (e?.message || e));
    try {
      const dbg = debugLines.join('\n');
      contentEl.textContent = (contentEl.textContent || '') + '\n\n[debug]\n' + dbg;
    } catch (_) {}
    updateProgress(100, 'Failed');
  }
}

payBtn.addEventListener('click', accessWithPayment);

// Rescan helper: poll briefly for wallet providers
async function rescanWallets() {
  const deadline = Date.now() + 2500;
  while (Date.now() < deadline) {
    populateWalletSelect();
    if (listWalletProviders().length > 0) {
      setStatus('Wallets detected.');
      return;
    }
    await new Promise((r) => setTimeout(r, 250));
  }
  populateWalletSelect();
  if (listWalletProviders().length === 0) {
    setStatus('No wallets detected. Install/enable a CIP-30 wallet (Nami, Eternl, Lace, Flint, Gero).');
  }
}

// No Blockfrost key UI; key is set in code above.
  // Using known asset name hex from server; no remote lookup.
</file>

<file path="x402-cardano-examples-main/resource_server/static/styles.css">
* { box-sizing: border-box; }
html, body { height: 100%; }
body { font-size: 18px; background: #008080; }
main {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 12px;
  max-width: 1100px;
  margin: 0 auto;
  padding: 12px 10px;
}
.sub { margin: 0 0 8px; color: #333; }
.content { max-height: 40vh; overflow: auto; font-size: 13px; }
.hidden { display: none !important; }
.hint.small { color: #555; }
.ascii-coin { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 13px; line-height: 1.1; }
.ascii-banner { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; line-height: 1.1; margin: 0 0 6px 0; }
.footer-note { margin: 10px auto; text-align: center; color: #222; }
.mobile-warning { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; padding: 12px; background: rgba(0,0,0,0.25); z-index: 9999; }
@media (max-width: 768px) {
  .mobile-warning { display: flex; }
}

/* Fallback styling if 98.css progress bar class is absent */
.progressbar { 
  display: inline-block; 
  height: 20px; 
  background: #ddd; 
  border: 2px solid #999; 
  box-shadow: inset -1px -1px 0 #fff, inset 1px 1px 0 #aaa; 
}
.progressbar > div {
  height: 100%; 
  width: 0%; 
  background: #0a5; 
}

/* Strong font-size override for 98.css */
.window, .window * { font-size: 18px; }
.hint.small { font-size: 14px !important; }
/* Smaller text for raw requirements and controls to prevent wrapping */
.req-raw summary { font-size: 14px !important; }
.req-raw pre { font-size: 12px !important; }
.window button, .window select, .window input { font-size: 14px; }
</file>

<file path="x402-cardano-examples-main/resource_server/templates/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>x402 Cardano Demo</title>
    <link rel="stylesheet" href="https://unpkg.com/98.css" />
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body>
    <div id="mobileWarning" class="mobile-warning" style="display:none;">
      <div class="window" style="width: 320px;">
        <div class="title-bar">
          <div class="title-bar-text">Notice</div>
          <div class="title-bar-controls">
            <button aria-label="Close" onclick="this.closest('.mobile-warning').style.display='none'"></button>
          </div>
        </div>
        <div class="window-body">
          <p>This demo currently works best on Desktop browsers.</p>
          <p>Please visit on a desktop device to continue.</p>
        </div>
      </div>
    </div>
    <main>
      <div class="window" style="width: 980px;">
        <div class="title-bar">
          <div class="title-bar-text">x402 Paywall · Cardano</div>
          <div class="title-bar-controls">
            <button aria-label="Help"></button>
            <button aria-label="Minimize"></button>
            <button aria-label="Close"></button>
          </div>
        </div>
        <div class="window-body">
          <pre class="ascii-banner">
        ___ _____  _____   _____               _                   
       /   |  _  |/ __  \ /  __ \             | |                  
__  __/ /| | |/' |`' / /' | /  \/ __ _ _ __ __| | __ _ _ __   ___  
\ \/ / /_| |  /| |  / /   | |    / _` | '__/ _` |/ _` | '_ \ / _ \ 
 >  <\___  \ |_/ /./ /___ | \__/\ (_| | | | (_| | (_| | | | | (_) |
/_/\_\   _/\___/ \_____/  \____/\__,_|_|  \__,_|\__,_|_| |_|\___/ 
          </pre>
          <div class="field-row-stacked">
            <p class="sub">
              This page is a demonstration of the x402 standard on Cardano.
            </p>
            <p class="hint small">This demo will mint you a meme coin (test only) after payment. Still in development — see the code on <a href="https://github.com/masumi-network/x402-cardano/tree/main" target="_blank" rel="noreferrer">GitHub</a>.</p>
          </div>

          <div class="field-row" style="justify-content: space-between; align-items: center;">
            <a href="https://www.x402.org/" target="_blank" rel="noreferrer">Learn more at x402.org</a>
            <img src="https://www.x402.org/_next/image?url=%2Fx402-button-large.png&w=640&q=75" alt="x402 Enabled" style="height: 28px" />
          </div>

          <fieldset id="stepIntro" style="margin-top: 10px;">
            <legend>Step 0 · What is x402?</legend>
            <div class="field-row-stacked">
              <p><strong>What is the x402 Standard?</strong> It’s a simple way for websites and APIs to say “Payment Required” using standard HTTP 402 and to tell you exactly how to pay. See <a href="https://www.x402.org/" target="_blank" rel="noreferrer">x402.org</a>.</p>
              <p><strong>What does this mean for Cardano?</strong> Your browser uses your wallet to build and sign a Cardano transaction (USDM in this demo) and retries the same URL with the payment attached.</p>
              <p><strong>Flow (high level):</strong> Request → 402 (includes payment requirements) → Sign & attach payment (X-PAYMENT header) → 200 unlocked.</p>
              <p class="hint small">After payment, we will mint a memecoin as a fun token of participation on the success screen. This is not an investment, it's just a simple Proof-Of-Concept. Do not speculate on the coin.</p>
              <div class="field-row" style="margin-top: 8px;">
                <button id="introNextBtn" class="default">Next: Payment Requirements</button>
              </div>
            </div>
          </fieldset>

          <fieldset id="stepReqs" style="margin-top: 10px; display:none;">
            <legend>Step 1 · Payment Requirements</legend>
            <div class="field-row-stacked">
              <div id="reqSummary" class="sub"></div>
              <p class="hint small">These values are sent by the server in the 402 Payment Required response body (PaymentRequirements). This page embeds them and uses them to build your transaction. When you pay, your signed transaction is sent back in the <code>X-PAYMENT</code> request header.</p>
              <details class="req-raw">
                <summary>View raw requirements</summary>
                <pre id="content" class="content" style="margin-top: 6px"></pre>
              </details>
              <div class="field-row" style="margin-top: 8px; align-items: center; gap: 8px;">
                <button id="reqBackBtn">Back</button>
                <button id="reqNextBtn" class="default">Next: Connect Wallet</button>
              </div>
            </div>
          </fieldset>

          <fieldset id="stepConnect" style="margin-top: 10px; display:none;">
            <legend>Step 2 · Connect Wallet</legend>
            <div class="field-row" style="margin-bottom: 6px;">
              <label for="walletSelect">Wallet</label>
              <select id="walletSelect" style="min-width: 200px"></select>
              <button id="rescanBtn">Rescan</button>
              <button id="connectBtn" class="default" style="display:none;">Connect</button>
            </div>
            <div class="field-row-stacked">
              <label for="addrBox">Connected address</label>
              <input id="addrBox" type="text" readonly value="" />
            </div>
            <div class="field-row" style="margin-top: 8px;">
              <button id="connectBackBtn">Back</button>
              <button id="connectNextBtn" class="default" disabled>Next: Pay</button>
            </div>
          </fieldset>

          <fieldset id="stepPay" style="margin-top: 10px; display:none;">
            <legend>Step 3 · Pay & Access</legend>
            <div class="field-row">
              <button id="payBtn" class="default" style="display:none;">Pay & Access</button>
              <span id="status" style="margin-left: 8px"></span>
            </div>
            <div class="field-row" style="margin-top:6px; align-items: center;">
              <div id="payProgress" class="progressbar" style="width: 320px; display:none;"><div style="width:0%"></div></div>
              <span id="progressLabel" class="hint small" style="margin-left: 8px; display:none;">Preparing…</span>
            </div>
            <p class="hint small" style="margin-top:6px;">Clicking “Pay & Access” constructs and signs a Cardano transaction in your wallet and resends this same URL with the signed tx in the <code>X-PAYMENT</code> header. The server validates and unlocks the content.</p>
          </fieldset>

          <fieldset id="stepPending" style="margin-top: 10px; display:none;">
            <legend>Step 4 · Waiting for Settlement</legend>
            <div class="field-row-stacked">
              <p class="hint small">We’ve submitted your transaction. We’ll check the blockchain every <strong>10 seconds</strong> and unlock this page once it’s confirmed.</p>
              <div class="field-row" style="align-items:center; gap:8px;">
                <div id="waitProgress" class="progressbar" style="width: 380px;"><div style="width:0%"></div></div>
                <span id="waitLabel" class="hint small">Checking soon…</span>
              </div>
              <div class="field-row" style="margin-top:6px;">
                <label for="txBox">Transaction</label>
                <input id="txBox" type="text" readonly value="" style="min-width: 520px;" />
                <button id="checkNowBtn">Check now</button>
              </div>
              <div class="field-row" style="margin-top:6px;">
                <a id="txExplorerLink" href="#" target="_blank" rel="noreferrer" style="display:none;">View on Cardano Explorer</a>
              </div>
            </div>
          </fieldset>

          <fieldset id="stepSuccess" style="margin-top: 10px; display:none;">
            <legend>Step 5 · Success</legend>
            <div class="field-row-stacked">
              <pre class="ascii-coin">|#######====================#######|
|#(₳)*     CARDANO x402       *(₳)#|
|#**          /===\   ********  **#|
|*# {₳}      | (") |             #*|
|#*  ******  | /v\ |  100 COINS  *#|
|#(₳)         \===/            (₳)#|
|##=========CARDANO x402=========##|
------------------------------------</pre>
              <p class="hint small">This page is a <strong>technical test</strong> only — not serious, not financial advice.<br/>You will receive Proof-of-Concept Memecoin in your wallet in a few minutes.</p>
              <div class="field-row" style="margin-top:6px;">
                <a id="successExplorerLink" href="#" target="_blank" rel="noreferrer" style="display:none;">View transaction on Cardano Explorer</a>
              </div>
              <div class="status-bar">
                <p class="status-bar-field">Memecoin Sent! (test, just for fun)</p>
                <p class="status-bar-field">x402 payment complete</p>
              </div>
            </div>
          </fieldset>

        </div>
      </div>

      <footer class="footer-note">
        <small>Demo brought to you by <a href="https://masumi.network" target="_blank" rel="noreferrer">Masumi Network</a> · <a href="https://www.x402.org/" target="_blank" rel="noreferrer">x402.org</a></small>
      </footer>
    </main>

    <script>
      window.__x402Requirements = {{ (requirements or {}) | tojson | safe }};
      window.__BF_PROJECT_ID = {{ (bf_key or '') | tojson | safe }};
    </script>
    <script src="{{ url_for('static', filename='app.js') }}"></script>
  </body>
  </html>
</file>

<file path="x402-cardano-examples-main/resource_server/app.py">
from __future__ import annotations

import base64
import hashlib
import json
import os
from datetime import datetime
from typing import Any, Dict, Tuple

import requests
from flask import Flask, jsonify, make_response, render_template, request


def load_env_from_file(path: str = ".env"):
    try:
        if not os.path.exists(path):
            return
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" in line:
                    k, v = line.split("=", 1)
                    os.environ.setdefault(k.strip(), v.strip())
    except Exception:
        pass


load_env_from_file()

app = Flask(__name__, static_folder="static", template_folder="templates")


# ---- Simple config for the demo ----
ASSET_USDM_MAINNET = (
    "c48cbb3d5e57ed56e276bc45f99ab39abe94e6cd7ac39fb402da47ad"
)
NETWORK = "cardano-mainnet"
# Updated recipient address as requested
PAY_TO = (
    "addr1q9m755p8q86d5rntr4wgn946jnz3uzt0a3p6028y4rpyjlh7k8mljp5j533gdxpk4krjeecmnzj7djrffs5jmu29ylmq7lye8k"
)
RESOURCE_URL = "/"  # protected resource is the root URL
MAX_TIMEOUT_SECONDS = 600
FACILITATOR_URL = os.environ.get("FACILITATOR_URL", "http://127.0.0.1:5051")
NMKR_API_TOKEN = os.environ.get("NMKR_API_TOKEN", "")
# Provided MintAndSendSpecific pattern (project/policy/qty/address?blockchain=Cardano)
NMKR_MINT_URL_TMPL = (
    "https://studio-api.nmkr.io/v2/MintAndSendSpecific/"
    "138fa984-45b2-4b3e-ab3a-489228bbe64b/"
    "f1928a69-cff1-43b7-9765-727bebf6dc78/100/{addr}?blockchain=Cardano"
)

# Track minted transactions to avoid double-calling (in-memory)
_MINTED_TX: set[str] = set()


def payment_requirements() -> Dict[str, Any]:
    return {
        "x402Version": 1,
        "error": "X-PAYMENT header is required",
        "accepts": [
            {
                "scheme": "exact",
                "network": NETWORK,
                # This USDM uses 6 decimals (1e6 units per 1 token)
                # Request exactly 2 USDM (2,000,000 units)
                "maxAmountRequired": "2000000",
                "asset": ASSET_USDM_MAINNET,
                "payTo": PAY_TO,
                "resource": RESOURCE_URL,
                "description": "Access to premium market data",
                "mimeType": "application/json",
                "outputSchema": None,
                "maxTimeoutSeconds": MAX_TIMEOUT_SECONDS,
                "extra": {
                    # Provide hints for client construction (no remote lookup)
                    # Asset Name Hex supplied by user: (333) USDM (0014df105553444d)
                    "assetNameHex": "0014df105553444d",
                    "assetFingerprint": "asset12ffdj8kk2w485sr7a5ekmjjdyecz8ps2cm5zed",
                    "decimals": 6,
                },
            }
        ],
    }


def b64_json_decode(b64_value: str) -> Dict[str, Any]:
    data = base64.b64decode(b64_value)
    return json.loads(data.decode("utf-8"))


def b64_json_encode(obj: Dict[str, Any]) -> str:
    raw = json.dumps(obj, separators=(",", ":"), ensure_ascii=False).encode("utf-8")
    return base64.b64encode(raw).decode("ascii")


def maybe_mint_for_tx(tx_id: str, payer_addr: str | None) -> None:
    try:
        if not tx_id or not payer_addr:
            return
        if tx_id in _MINTED_TX:
            return
        if not NMKR_API_TOKEN:
            return
        url = NMKR_MINT_URL_TMPL.format(addr=payer_addr)
        headers = {
            "accept": "text/plain",
            "Authorization": f"Bearer {NMKR_API_TOKEN}",
        }
        # Best-effort; do not block the response path too long
        try:
            requests.get(url, headers=headers, timeout=10)
        except Exception:
            # swallow errors in demo environment
            pass
        _MINTED_TX.add(tx_id)
    except Exception:
        pass


def decode_x_payment_header() -> Tuple[Dict[str, Any] | None, str | None]:
    x_payment_b64 = request.headers.get("X-PAYMENT")
    if not x_payment_b64:
        return None, "missing"
    try:
        decoded = b64_json_decode(x_payment_b64)
        return decoded, None
    except Exception as e:  # noqa: BLE001 - demo simplicity
        return None, f"invalid: {e}"


def facilitator_verify(x_payment_b64: str, requirements: Dict[str, Any]) -> Tuple[bool, str | None]:
    try:
        r = requests.post(
            f"{FACILITATOR_URL}/verify",
            json={"x_payment_b64": x_payment_b64, "payment_requirements": requirements},
            timeout=15,
        )
        data = r.json() if r.ok else {"isValid": False, "invalidReason": f"HTTP {r.status_code}"}
        try:
            print("[verify] status=", r.status_code, "resp=", data)
        except Exception:
            pass
        return bool(data.get("isValid")), data.get("invalidReason")
    except Exception as e:
        try:
            print("[verify] exception:", e)
        except Exception:
            pass
        return False, str(e)


def facilitator_settle(x_payment_b64: str, requirements: Dict[str, Any]) -> Tuple[bool, str | None, str | None]:
    try:
        r = requests.post(
            f"{FACILITATOR_URL}/settle",
            json={"x_payment_b64": x_payment_b64, "payment_requirements": requirements},
            timeout=60,
        )
        if not r.ok:
            # Pending responses may come with 202
            if r.status_code == 202:
                data = r.json()
                try:
                    print("[settle] 202 pending resp=", data)
                except Exception:
                    pass
                return False, data.get("transaction"), "invalid_transaction_state"
            try:
                print("[settle] non-OK status:", r.status_code, r.text[:200])
            except Exception:
                pass
            return False, None, f"HTTP {r.status_code}"
        data = r.json()
        if data.get("success"):
            try:
                print("[settle] success resp=", data)
            except Exception:
                pass
            return True, data.get("transaction"), None
        # Could be pending
        if r.status_code == 202 or data.get("pending"):
            try:
                print("[settle] pending resp=", data)
            except Exception:
                pass
            return False, data.get("transaction"), data.get("errorReason") or "invalid_transaction_state"
        return False, None, data.get("errorReason") or "settlement failed"
    except Exception as e:
        try:
            print("[settle] exception:", e)
        except Exception:
            pass
        return False, None, str(e)


def wants_json() -> bool:
    try:
        fmt = (request.args.get("format") or request.args.get("accept") or "").lower().strip()
        if fmt in {"json", "application/json"}:
            return True
        accept = (request.headers.get("Accept") or "").lower()
        if "application/json" in accept and "text/html" not in accept:
            return True
    except Exception:
        pass
    return False


def make_payment_required_page(reason: str | None = None):
    # Return 402 with JSON if API/CLI caller, otherwise HTML page for browsers
    reqs = payment_requirements()
    if wants_json():
        resp = make_response(jsonify(reqs), 402)
        resp.headers["Content-Type"] = "application/json"
    else:
        bf_key = os.environ.get("BLOCKFROST_PROJECT_ID", "")
        resp = make_response(render_template("index.html", requirements=reqs, bf_key=bf_key), 402)
        resp.headers["Content-Type"] = "text/html; charset=utf-8"
    if reason:
        resp.headers["X-PAYMENT-ERROR"] = reason[:200]
    return resp


@app.route("/client")
def client_page():
    # Serve the same UI but with 200 status (for testing)
    return render_template(
        "index.html",
        requirements=payment_requirements(),
        bf_key=os.environ.get("BLOCKFROST_PROJECT_ID", ""),
    )


@app.route("/", methods=["GET"])  # Protected resource at root
def protected_root():
    # If a tx hash is provided, check settlement status first (no resubmission)
    tx_qs = (request.args.get("tx") or "").strip()
    if tx_qs:
        reqs = payment_requirements()
        try:
            r = requests.post(
                f"{FACILITATOR_URL}/status",
                json={"transaction": tx_qs, "payment_requirements": reqs},
                timeout=15,
            )
            data = r.json() if r.content else {}
            if r.status_code == 200 and data.get("success"):
                # Mint once on success
                payer_addr = request.headers.get("X-PAYER-ADDRESS", "").strip()
                maybe_mint_for_tx(tx_qs, payer_addr)
                content = {
                    "message": "You’ve unlocked the protected resource via x402.",
                    "resource": "/",
                    "timestamp": datetime.utcnow().isoformat() + "Z",
                }
                resp = make_response(jsonify(content), 200)
                payment_response = {"success": "true", "network": NETWORK, "transaction": tx_qs}
                resp.headers["X-PAYMENT-RESPONSE"] = b64_json_encode(payment_response)
                return resp
            # Pending
            return make_response(jsonify({"pending": True, "transaction": tx_qs}), 202)
        except Exception:
            return make_payment_required_page("invalid_transaction_state")

    # We forward the original base64 header to the facilitator
    x_payment_b64 = request.headers.get("X-PAYMENT")
    if not x_payment_b64:
        # No or invalid header: show UI with 402
        return make_payment_required_page("missing")

    # Forward to facilitator verify
    reqs = payment_requirements()
    valid, reason = facilitator_verify(x_payment_b64, reqs)
    if not valid:
        return make_payment_required_page(reason)

    # Settle the transaction (may be pending)
    settled, tx_id, err = facilitator_settle(x_payment_b64, reqs)
    if not settled:
        # Inform client it's pending so it can poll status
        body = {"pending": True, "transaction": tx_id or "", "retryAfterSeconds": 10}
        return make_response(jsonify(body), 202)

    # Success: return the premium content and include X-PAYMENT-RESPONSE header
    # Mint once on success
    payer_addr = request.headers.get("X-PAYER-ADDRESS", "").strip()
    maybe_mint_for_tx(tx_id or "", payer_addr)
    content = {
        "message": "You’ve unlocked the protected resource via x402.",
        "resource": "/",
        "timestamp": datetime.utcnow().isoformat() + "Z",
    }

    resp = make_response(jsonify(content), 200)
    payment_response = {"success": "true", "network": NETWORK, "transaction": tx_id}
    resp.headers["X-PAYMENT-RESPONSE"] = b64_json_encode(payment_response)
    return resp




@app.get("/status")
def status_proxy():
    tx = request.args.get("tx", "").strip()
    if not tx:
        return jsonify({"success": False, "errorReason": "invalid_payload"}), 400
    reqs = payment_requirements()
    try:
        r = requests.post(
            f"{FACILITATOR_URL}/status",
            json={"transaction": tx, "payment_requirements": reqs},
            timeout=15,
        )
        data = r.json() if r.content else {}
        if r.status_code == 202 or data.get("pending"):
            return make_response(jsonify({"pending": True, "transaction": tx}), 202)
        if data.get("success"):
            return jsonify({"success": True, "transaction": tx, "network": data.get("network")}), 200
        return jsonify({"success": False, "errorReason": data.get("errorReason") or "invalid_transaction_state"}), 200
    except Exception as e:
        return jsonify({"success": False, "errorReason": "unexpected_settle_error"}), 200


# (Mock facilitator endpoints removed in minimal build; verification is in-process and mocked.)

if __name__ == "__main__":
    port = int(os.environ.get("PORT", "5000"))
    app.run(host="0.0.0.0", port=port, debug=True)
</file>

<file path="x402-cardano-examples-main/resource_server/requirements.txt">
Flask>=3.0,<4
requests>=2.31
cbor2>=5.6
</file>

<file path="x402-cardano-examples-main/.env.example">
# Required for facilitator_server (Cardano submission)
BLOCKFROST_PROJECT_ID=proj_mainnet_xxxxx
NETWORK=cardano-mainnet

# Used by resource_server to reach the facilitator
FACILITATOR_URL=http://127.0.0.1:5051
PORT=5000

# Optional: NMKR studio API token for mint+send after payment
NMKR_API_TOKEN=nmkr_bearer_token_here
</file>

<file path="x402-cardano-examples-main/.gitignore">
# Python
__pycache__/
*.py[cod]
.venv/
venv/

# Env/config
.env

# Logs
*.log
/tmp/

# MacOS
.DS_Store
</file>

<file path="x402-cardano-examples-main/README.md">
# x402 Cardano Examples (Flask)

Two small Flask services demonstrating the x402 “Payment Required” pattern on Cardano:

- resource_server (UI + paywall): Serves a Windows 98–styled page protected by HTTP 402. It embeds PaymentRequirements and lets a user connect a CIP‑30 wallet, build/sign a Cardano tx (USDM), and unlock the resource once on‑chain.
- facilitator_server (verify + settle): Receives the signed transaction, submits to Cardano (Blockfrost), and reports settlement status.

This is a technical demo (in development). It “mints a meme coin” as a fun success message — not serious, not financial advice.

Links:
- x402: https://www.x402.org/
- Repo: https://github.com/masumi-network/x402-cardano-examples

## Features

- 402 paywall at GET / with embedded PaymentRequirements
- CIP‑30 wallet selection (Nami, Eternl, Lace, Flint, Gero, etc.)
- Lucid + Blockfrost to build/sign/submit the tx in the browser (sign only; submission is server‑side)
- Pending step with progress/countdown + Cardanoscan explorer links
- Unlock only when confirmed on‑chain
- USDM payment of 2 units (2.000000) at 6 decimals

## Requirements

- Python 3.10+
- Blockfrost mainnet project ID
- Desktop browser with Cardano wallet extension (CIP‑30)

## Local setup

1) Install dependencies and create .env

```bash
python3 -m venv .venv
. .venv/bin/activate
pip install -r requirements.txt
cp .env.example .env
# Edit .env and set your Blockfrost key
```

2) Start facilitator (port from $PORT; defaults to 5051)

```bash
python3 facilitator_server/app.py
```

3) Start resource server (port from $PORT; defaults to 5000)

```bash
python3 resource_server/app.py
```

4) Visit

```
http://127.0.0.1:5000/
```

## Environment variables

Set in .env (and injected in Railway):

- BLOCKFROST_PROJECT_ID: Blockfrost API key (mainnet)
- NETWORK: cardano-mainnet (default)
- FACILITATOR_URL: URL of the facilitator (http://127.0.0.1:5051 when local)
- PORT: for each service (Railway sets this automatically)

## Deployment on Railway (no Docker required)

Railway runs one service per process. We’ll create two services in one project — one for the facilitator and one for the resource server — both from the same repo. Nixpacks will detect Python; you only need to set the root directories and start commands.

Steps (one‑time):

1) Connect the GitHub repo in Railway.

2) Create “facilitator” service
- Root Directory: `facilitator_server` (or `.` — both work)
- Start Command: `python app.py`
- Variables:
  - `BLOCKFROST_PROJECT_ID` = your key (from Blockfrost)
  - `NETWORK` = `cardano-mainnet`
  - (PORT is set by Railway)
- Deploy. Copy the public URL (e.g., `https://facilitator.up.railway.app`).

3) Create “resource” service
- Root Directory: `resource_server` (or `.` — both work)
- Start Command: `python app.py`
- Variables:
  - `FACILITATOR_URL` = facilitator public URL from step 2
  - `NETWORK` = `cardano-mainnet`
  - (PORT is set by Railway)
- Deploy. Open the resource URL in your desktop browser with a Cardano wallet.

Notes:
- You don’t need Docker for this setup. Railway’s Python builder (Nixpacks) just works.
- The UI runs entirely from the resource server; it posts payment to the resource server, which talks to the facilitator server.
- Ensure the resource server uses the facilitator URL (set the env variable, then redeploy).
- If you use subfolders as Root Directory, requirements are provided via a small `requirements.txt` in each subfolder that references the root (`-r ../requirements.txt`). If you set Root Directory to `.`, Railway will pick up the root `requirements.txt` directly.

Troubleshooting build on Railway:
- If build fails with “no requirements found”, set Root Directory to `.` or keep the provided `requirements.txt` inside each subfolder.
- If Python version issues arise, set an env var `PYTHON_VERSION=3.10.13` in Railway.
- Ensure BLOCKFROST_PROJECT_ID is set on the facilitator service.

## How it works (quick)

- Unpaid request to `/` → 402 with PaymentRequirements (includes asset, amount, payTo, timeout).
- User connects wallet and clicks “Pay & Access” → browser builds/signs the Cardano tx (USDM) and sends it in the `X-PAYMENT` header.
- Resource server calls facilitator `/verify`, then `/settle`.
- Facilitator submits the tx, returns `202 pending` if not yet visible; resource relays that to the UI.
- UI switches to a pending step and polls `/?tx=<hash>` every ~10s until the resource server sees it on‑chain and responds with `200` and the unlocked data.

## Error codes

Facilitator and resource return x402‑style error codes where applicable:

- invalid_x402_version, invalid_scheme, invalid_network
- invalid_payload, invalid_payment_requirements
- invalid_transaction_state (not confirmed or rejected)
- unexpected_verify_error, unexpected_settle_error

## Caveats

- This demo focuses on the x402 loop; it does not handle complex wallet behaviors, nor production security. Treat it as a starting point.
- If you change USDM policy or asset name hex, update resource_server/app.py (PaymentRequirements.extra.assetNameHex).
</file>

<file path="x402-cardano-examples-main/requirements.txt">
Flask>=3.0,<4
requests>=2.31
cbor2>=5.6
</file>

</files>
